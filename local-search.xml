<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS之fishhook</title>
    <link href="/2021/08/22/iOS%E4%B9%8Bfishhook/"/>
    <url>/2021/08/22/iOS%E4%B9%8Bfishhook/</url>
    
    <content type="html"><![CDATA[<h2 id="fishhook"><a href="#fishhook" class="headerlink" title="fishhook"></a>fishhook</h2><p><a href="https://github.com/facebook/fishhook">fishHook</a>是Facebook提供的一个动态修改链接mach-O文件的工具。利用MachO文件加载原理，通过重新绑定(rebind_symbols)懒加载表(Lazy Symbol Pointers)和非懒加载表(Non-Lazy Symbol Pointers)这两个表的指针达到C函数HOOK的目的。</p><blockquote><p>dyld加载macho文件和系统框架,对函数地址复制的过程，成为 <strong>“符号绑定“</strong></p></blockquote><h2 id="调试分析fishHook"><a href="#调试分析fishHook" class="headerlink" title="调试分析fishHook"></a>调试分析fishHook</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//</span><br><span class="hljs-comment">//  ViewController.m</span><br><span class="hljs-comment">//  fishhook</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by Cola on 2020/5/24.</span><br><span class="hljs-comment">//  Copyright © 2020 Cola. All rights reserved.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;fishhook.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>   <br>    <span class="hljs-comment">//一个rebinding hook一个函数,想要hook多个函数，可以将rebinding添加至数组</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//更改系统的NSLoga函数</span><br>    <span class="hljs-keyword">struct</span> rebinding nslog;<br>    nslog.name = <span class="hljs-string">&quot;NSLog&quot;</span>;<br>    nslog.replacement = myNSLog;<br>    nslog.replaced = &amp;sys_nslog;<br>    <br>    <span class="hljs-keyword">struct</span> rebinding rebs[<span class="hljs-number">1</span>] = &#123;nslog&#125;;<br>    <br>    <br>    rebind_symbols(rebs, <span class="hljs-number">1</span>);<br>     <br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;点击&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (*sys_nslog)(<span class="hljs-built_in">NSString</span> * _Nonnull format, ...);<br> <br><span class="hljs-comment">//定义一个新的函数</span><br><span class="hljs-keyword">void</span> myNSLog(<span class="hljs-built_in">NSString</span> * _Nonnull format, ...)&#123;<br>    format = [format stringByAppendingFormat:<span class="hljs-string">@&quot;\n HOOK成功🐂&quot;</span>];<br>    sys_nslog(format);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ol><li><p>通过machoView查看符号表(Lazy Symbol Pointers)的偏移量(比如NSLog的偏移量是) 0x00005000</p></li><li><p>在<code>rebind_symbols(rebs, 1);</code>下断点,</p></li><li><p>通过image list查看加载的macho文件和所有的框架</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">(lldb) image list<br>[  <span class="hljs-number">0</span>] E10158F5-<span class="hljs-number">413</span>E-<span class="hljs-number">35</span>E1-A349-<span class="hljs-number">8</span>AFA71FFC955 <span class="hljs-number">0</span>x0000000103db1000 <span class="hljs-regexp">/Users/</span>cola<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData<span class="hljs-regexp">/fishhook-dduxiymrdkidvtcxqmuqqwanbexr/</span>Build<span class="hljs-regexp">/Products/</span>Debug-iphonesimulator<span class="hljs-regexp">/fishhook.app/</span>fishhook <br>[  <span class="hljs-number">1</span>] EEA931D0-<span class="hljs-number">403</span>E-<span class="hljs-number">3</span>BC8-<span class="hljs-number">862</span>A-CBA037DE4A74 <span class="hljs-number">0</span>x00000001048e3000 <span class="hljs-regexp">/usr/</span>lib/dyld <br>[  <span class="hljs-number">2</span>] <span class="hljs-number">75369</span>F31-<span class="hljs-number">702</span>D-<span class="hljs-number">364</span>A-<span class="hljs-number">95</span>C3-<span class="hljs-number">8</span>AFA9DD4B3A2 <span class="hljs-number">0</span>x0000000103dbf000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span>dyld_sim <br>[  <span class="hljs-number">3</span>] <span class="hljs-number">56</span>E47800-<span class="hljs-number">2</span>CCB-<span class="hljs-number">3</span>B7D-B94B-CCF5F13D6BCF <span class="hljs-number">0</span>x00007fff256b8000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/</span>System<span class="hljs-regexp">/Library/</span>Frameworks<span class="hljs-regexp">/Foundation.framework/</span>Foundation <br>[  <span class="hljs-number">4</span>] <span class="hljs-number">3</span>EC683F6-<span class="hljs-number">36</span>EF-<span class="hljs-number">33</span>E1-<span class="hljs-number">8</span>B98-C95E12BA38D2 <span class="hljs-number">0</span>x00007fff513f6000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span>libobjc.A.dylib <br>[  <span class="hljs-number">5</span>] <span class="hljs-number">7881</span>AD7F-<span class="hljs-number">524</span>C-<span class="hljs-number">3</span>CFA-<span class="hljs-number">9595</span>-<span class="hljs-number">02</span>ED549166AA <span class="hljs-number">0</span>x00007fff4ff15000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span>libSystem.B.dylib <br><br>.......<br></code></pre></td></tr></table></figure></li><li><p>macho文件的首地址+第一步的偏移量，就是NSLog的真实地址,读NSLog的符号表地址</p><p>memory read  简写   x 0x0000000103db1000+0x00005000</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">(lldb) memory read 0x0000000103db1000+0x00005000<br>0x103db6000: fa 2d<span class="hljs-number"> 76 </span>25 ff 7f<span class="hljs-number"> 00 </span>00 f8 d1<span class="hljs-number"> 74 </span>25 ff 7f<span class="hljs-number"> 00 </span>00  .-v%......t%....<br>0x103db6010: f8<span class="hljs-number"> 26 </span>09<span class="hljs-number"> 48 </span>ff 7f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 44 </span>34 db<span class="hljs-number"> 03 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span> .&amp;.H....D4......<br></code></pre></td></tr></table></figure></li><li><p>其中前八个字节为NSLog的地址<br>查看4中的前八个字节的地址的汇编代码</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">(lldb) dis -s <span class="hljs-number">0x7fff25762dfa</span><br>Foundation`NSLog:<br>    <span class="hljs-number">0x7fff25762dfa</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x7fff25762dfb</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   <span class="hljs-variable">%rsp</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x7fff25762dfe</span> &lt;+<span class="hljs-number">4</span>&gt;:  subq   $<span class="hljs-number">0xd0</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsp</span><br>    <span class="hljs-number">0x7fff25762e05</span> &lt;+<span class="hljs-number">11</span>&gt;: testb  <span class="hljs-variable">%al</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%al</span><br>    <span class="hljs-number">0x7fff25762e07</span> &lt;+<span class="hljs-number">13</span>&gt;: je     <span class="hljs-number">0x7fff25762e2f</span>            <span class="hljs-comment">; &lt;+53&gt;</span><br>    <span class="hljs-number">0x7fff25762e09</span> &lt;+<span class="hljs-number">15</span>&gt;: movaps <span class="hljs-variable">%xmm0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span>xa<span class="hljs-number">0</span>(<span class="hljs-variable">%rbp</span>)<br>    <span class="hljs-number">0x7fff25762e10</span> &lt;+<span class="hljs-number">22</span>&gt;: movaps <span class="hljs-variable">%xmm1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">90</span>(<span class="hljs-variable">%rbp</span>)<br></code></pre></td></tr></table></figure><p>从中可以看见NSLog的地址</p></li><li><p>单步执行，执行fishhook的rebind_symbols方法后查看NSLog的真实地址</p><p>和4相比地址已经改变</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">(lldb) memory read 0x000000010f550000+0x00005000<br>0x10f555000:<span class="hljs-number"> 50 </span>14<span class="hljs-number"> 55 </span>0f<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00 f8 d1<span class="hljs-number"> 74 </span>25 ff 7f<span class="hljs-number"> 00 </span>00  P.U.......t%....<br>0x10f555010: f8<span class="hljs-number"> 26 </span>09<span class="hljs-number"> 48 </span>ff 7f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 54 </span>99<span class="hljs-number"> 34 </span>52 ff 7f<span class="hljs-number"> 00 </span>00  .&amp;.H....T.4R....<br></code></pre></td></tr></table></figure></li><li><p>查看前八个字节对应地址的汇编代码，发现已经被替换成我们的myNSlog方法</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">(lldb) dis -s <span class="hljs-number">010</span>f<span class="hljs-number">551450</span><br>fishhook`myNSLog:<br>    <span class="hljs-number">0x10f551450</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x10f551451</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   <span class="hljs-variable">%rsp</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x10f551454</span> &lt;+<span class="hljs-number">4</span>&gt;:  subq   $<span class="hljs-number">0x30</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsp</span><br>    <span class="hljs-number">0x10f551458</span> &lt;+<span class="hljs-number">8</span>&gt;:  movq   $<span class="hljs-number">0x0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-variable">%rbp</span>)<br>    <span class="hljs-number">0x10f551460</span> &lt;+<span class="hljs-number">16</span>&gt;: leaq   <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-variable">%rbp</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>    <span class="hljs-number">0x10f551464</span> &lt;+<span class="hljs-number">20</span>&gt;: movq   <span class="hljs-variable">%rdi</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">10</span>(<span class="hljs-variable">%rbp</span>)<br>    <span class="hljs-number">0x10f551468</span> &lt;+<span class="hljs-number">24</span>&gt;: movq   <span class="hljs-variable">%rax</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rdi</span><br>    <span class="hljs-number">0x10f55146b</span> &lt;+<span class="hljs-number">27</span>&gt;: movq   <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">10</span>(<span class="hljs-variable">%rbp</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsi</span><br>(lldb) <br></code></pre></td></tr></table></figure></li><li><p>调用原方法</p><p>因为系统默认绑定的地址被保存到了，自定义的变量中，可以通过地址调用该方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (*sys_nslog)(<span class="hljs-built_in">NSString</span> * _Nonnull format, ...);<br></code></pre></td></tr></table></figure><p>调用原方法</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">//定义一个新的函数</span><br>void myNSLog(NSString * <span class="hljs-variable">_Nonnull</span> <span class="hljs-built_in">format</span>, ...)&#123;<br>    <span class="hljs-built_in">format</span> = [<span class="hljs-built_in">format</span> stringByAppendingFormat:@<span class="hljs-string">&quot;\n HOOK成功🐂&quot;</span>];<br>    sys_nslog(<span class="hljs-built_in">format</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="fishHOOK原理"><a href="#fishHOOK原理" class="headerlink" title="fishHOOK原理"></a>fishHOOK原理</h2><p><strong>重新绑定符号表</strong></p><p>懒加载符号表与indirect symbols表一一对应</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/%E6%87%92%E5%8A%A0%E8%BD%BD%E7%AC%A6%E5%8F%B7%E8%A1%A8.png" class=""><p>indirect symbols表中NSLog的Data值为A6</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/indirectsymbols%E8%A1%A8.png" class=""><p>A6转为10进制为166,其中166对应着Symbols Table下的Symbols</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/Symbols.png" class=""><p>其中 #166在String Table Index表的偏移为D7，符号表基址为83AC，NSLog的地址为 83AC+D7=8483</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/StringTable.png" class=""><p>而fishHook则是逆过程，通过String Table表NSLog的地址，找到Lazy Symbols Pointers(懒加载符号表)中的NSLog符号表地址，获取懒加载符号表的偏移.</p><h2 id="fishHOOK能做什么"><a href="#fishHOOK能做什么" class="headerlink" title="fishHOOK能做什么"></a>fishHOOK能做什么</h2><ol><li><p>应用安全防护：</p><p> 将系统敏感函数，真实地址保存，并将该方法设置为宏定义,以后使用宏定义设置的方法，别人就无法HOOK该方法了，因为你使用的是函数的真实地址，并不是调用符号表中的函数地址，这样别人修改符号表是不影响程序的。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p> 三方框架有可能会用到该函数，如果fishhook加载的过早会导致三方框架失效。</p></li></ol><ol start="2"><li><p>启动优化、埋点、AOP</p><ul><li>定位所有方法的调用，hook objc_msgSend函数?</li><li>二进制重排(layout)的目的在于将hot code聚合在一起，即使得最经常执行的代码或最需要关键执行的代码（如启动阶段的顺序调用）聚合在一起，形成一个更紧凑的__TEXT段。</li></ul></li></ol><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>hook</tag>
      
      <tag>fishhook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之反调试</title>
    <link href="/2021/08/22/iOS%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <url>/2021/08/22/iOS%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="ptrace-反调"><a href="#ptrace-反调" class="headerlink" title="ptrace 反调"></a>ptrace 反调</h2><p>ptrace反调试，阻止LLDB附加调试</p><p>在Unix 系统中，提供了一个系统调用 ptrace 用于实现断点调试和对进程进行跟踪和控制，而 PT_DENY_ATTACH 是苹果增加的一个 ptrace 选项，这个参数用来告诉系统，阻止调试器依附，本质就是通过26号系统调用来完成的，目前大多反调试都利用该方案,代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;dlfcn.h&gt;<br><br>#import &lt;sys/types.h&gt;<br><br>typedef int (*ptrace_ptr_t)(int _request, pid_t pid, caddr_t _addr, int _data);<br><br>#if !defined(PT_DENT_ATTACH)<br><br>#define PT_DENT_ATTACH 31<br><br>#endif<br><br>void disable_debug() &#123;<br><br>        void * handle = dlopen(0, RTLD_GLOBAL|RTLD_NOW);<br>    <br>        ptrace_ptr_t ptrace_ptr = dlsym(handle, &quot;ptrace&quot;);<br>    <br>        ptrace_ptr(PT_DENT_ATTACH, 0, 0, 0);<br>    <br>        dlclose(handle);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="sysctl反调试"><a href="#sysctl反调试" class="headerlink" title="sysctl反调试"></a>sysctl反调试</h2><p>当一个进程被调试的时候，该进程会有一个标记来标记自己正在被调试，所以可以通过sysctl去查看当前进程的信息，看有没有这个标记位即可检查当前调试状态。</p><p>函数介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">函数的返回值若为<span class="hljs-number">0</span>时，证明没有错误，其他数字为错误码。<br><br>arg1 传入一个数组，该数组中的第一个元素指定本请求定向到内核的哪个子系统。第二个及其后元素依次细化指定该系统的某个部分。<br><br>arg2 数组中的元素数目<br><br>arg3 一个结构体，指向一个供内核存放该值的缓冲区，存放进程查询结果<br><br>arg4 缓冲区的大小<br><br>arg5/arg6 为了设置某个新值，arg5参数指向一个大小为arg6参数值的缓冲区。如果不准备指定一个新值，那么arg5应为一个空指针，arg6因为<span class="hljs-number">0.</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, u_int, <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span> *, <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span>)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objective-c"><br>#import &lt;sys/sysctl.h&gt;<br><br>#import &lt;sys/types.h&gt;<br><br>#import &lt;unistd.h&gt;<br><br>static bool is_debugger_present(void) &#123;<br><br>    int name[4];//存放字节码，查询信息<br><br>    struct kinfo_proc info;//接受进程查询结果信息的结构体<br><br>    size_t info_size = sizeof(info);//结构体的大小<br><br>    info.kp_proc.p_flag = 0;<br><br>    name[0] = CTL_KERN;//内核查看<br><br>    name[1] = KERN_PROC;//进程查看<br><br>    name[2] = KERN_PROC_PID;//进程ID<br><br>    name[3] = getpid();//获取pid<br><br>    int proc_err = sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0);<br><br>    if (proc_err == -1) &#123; //判断是否出现了异常<br><br>        exit(-1);<br><br>    &#125;<br><br>    //info.kp_proc.p_flag中存放的是标志位（二进制），在proc.h文件中有p_flag的宏定义，通过&amp;运算可知对应标志位的值是否为0。（若结果值为0则对应标志位为0）。其中P_TRACED为正在跟踪调试过程。<br><br>    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="syscall反调"><a href="#syscall反调" class="headerlink" title="syscall反调"></a>syscall反调</h2><p>直接调用这个函数:</p><p>其中PT_DENT_ATTACH的值为31，直接填31即可。SYS_ptrace的值为26，可以引入&lt;sys/syscall.h&gt;头文件后直接调用宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;sys/syscall.h&gt;<br><br>syscall(SYS_ptrace,PT_DENT_ATTACH,0,0,0);<br></code></pre></td></tr></table></figure><p>为从实现从用户态切换到内核态，系统提供了一个系统调用函数syscall，上面讲到的ptrace也是通过系统调用去实现的。而ptrace的编号为26，也就是SYS_ptrace的值:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">26</span>. ptrace               <span class="hljs-number">801</span>e<span class="hljs-number">812</span>c T<br></code></pre></td></tr></table></figure><p>其他函数编号可以在这里Kernel Syscalls查阅</p><p>但是syscall在iOS10之后废弃了。代替它的函数在</p><p>&lt;sys/kdebug_signpost.h&gt;里，叫kdebug_signpost()</p><h2 id="SIGSTOP-当检测到有断点触发时停止调试"><a href="#SIGSTOP-当检测到有断点触发时停止调试" class="headerlink" title="SIGSTOP(当检测到有断点触发时停止调试))"></a>SIGSTOP(当检测到有断点触发时停止调试))</h2><p>通过捕获系统SIGSTOP信号来判断。</p><p>如果程序没有断点。那这个是没有用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, dispatch_get_main_queue());<br><br>    dispatch_source_set_event_handler(source, ^&#123;<br><br>        exit(0);<br><br>    &#125;);<br><br>    dispatch_resume(source);<br>isatty<br><br>isatty方法也可以用来检测是否正在被调试<br><br>#import &lt;unistd.h&gt;<br><br>if (isatty(1)) &#123;<br><br>   exit(0);   <br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h2><p>isatty方法也可以用来检测是否正在被调试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#import &lt;unistd.h&gt;</span><br><span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">1</span>)) &#123;<br>   <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);   <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;sys/ioctl.h&gt;<br>void Anti_ioctl() &#123;<br>    if (!ioctl(1, TIOCGWINSZ)) &#123;<br>        exit(1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，上述这些方式只能简单地防止 App 被动态调试，其实 ptrace、sysctl、syscall 等函数本身也可以被静态修改或 Hook。而且即便能有效阻止了调试，App 仍然可以通过 tweak 去 Hook App 内部的方法实现，也可以通过 dylib 注入去修改 App 的功能</p><p>我们只好从多方面考虑，尽可能提高安全性，比如防止 tweak 依附、防止网络请求抓包、对敏感数据进行加解密、代码混淆、检查二进制 binary 签名是否匹配；关键逻辑用更底层的 C 函数实现（虽然 C 函数也是可以被 Hook，例如 Facebook 开源的 fishhook），等等，同时我们也可以检查手机是否已经越狱，并对越狱机做特殊处理。</p><h2 id="内联-svc-ptrace-实现和内联-svc-syscall-ptrace-实现"><a href="#内联-svc-ptrace-实现和内联-svc-syscall-ptrace-实现" class="headerlink" title="内联 svc + ptrace 实现和内联 svc + syscall + ptrace 实现"></a>内联 svc + ptrace 实现和内联 svc + syscall + ptrace 实现</h2><p> 其实这两种方法都等同于直接或间接使用 ptrace, 此时系统调用号是 SYS_ptrace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs objective-c"> static __attribute__((always_inline)) void AntiDebugASM() &#123;<br><br>#ifdef __arm__<br><br>    asm volatile(<br><br>                 &quot;mov r0,#31\n&quot;<br><br>                 &quot;mov r1,#0\n&quot;<br><br>                 &quot;mov r2,#0\n&quot;<br><br>                 &quot;mov r12,#26\n&quot;<br><br>                 &quot;svc #80\n&quot;<br><br>                 );<br><br>#endif<br><br>#ifdef __arm64__<br><br>    asm volatile(<br><br>                 &quot;mov x0,#26\n&quot;<br><br>                 &quot;mov x1,#31\n&quot;<br><br>                 &quot;mov x2,#0\n&quot;<br><br>                 &quot;mov x3,#0\n&quot;<br><br>                 &quot;mov x16,#0\n&quot;<br><br>                 &quot;svc #128\n&quot;<br><br>                 );<br><br>#endif<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内联汇编调用exit函数"><a href="#内联汇编调用exit函数" class="headerlink" title="内联汇编调用exit函数"></a>内联汇编调用exit函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static __attribute__((always_inline)) void OPENME() &#123;<br>    asm volatile(<br>                 &quot;mov x0,#0\n&quot;<br>                 &quot;mov x16,#1\n&quot;<br>                 &quot;svc #80\n&quot;<br>                 &quot;mov x1, #0\n&quot;<br>                 &quot;mov sp, x1\n&quot;<br>                 &quot;mov x29, x1\n&quot;<br>                 &quot;mov x30, x1\n&quot;<br>                 &quot;ret&quot;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>对于fishhook交换系统函数的绕过方式，我们可以通过将sysctl等函数调用放到动态库中，以保证检测函数可以在进攻注入的代码之前执行。动态库的加载顺序为Build Phases下的Link Binary With Libaraies中的排列顺序。</p><h2 id="svc-syscall-ptrace-反反调试"><a href="#svc-syscall-ptrace-反反调试" class="headerlink" title="svc + syscall + ptrace 反反调试"></a>svc + syscall + ptrace 反反调试</h2> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/youshaoduo/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">83688732</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>反调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之cycript</title>
    <link href="/2021/08/22/iOS-cycript/"/>
    <url>/2021/08/22/iOS-cycript/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript混合了OC、JavaScript语法的解释器，我们能够在一个命令中使用Oc或者JavaScript，甚至两者并用。它能够挂钩正在运行的进程，能够在运行时修改很多东西。</p><p><a href="http://www.cycript.org/manual/#97846f1e-fda4-43bc-8432-45bb1115c433">官方参考手册</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>1.越狱手机安装Cycript插件，ssh登录到手机中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">cycript -<span class="hljs-selector-tag">p</span> pid<br></code></pre></td></tr></table></figure><p>2.使用MonkeyDev新建MonkeyApp工程，运行需要动态调试的App,Monkey默认开启了Cycript服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CHConstructor&#123;<br>    NSLog(INSERT_SUCCESS_WELCOME);<br>    <br>    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;<br>        <br>#ifndef __OPTIMIZE__<br>        CYListenServer(6666);<br><br>        MDCycriptManager* manager = [MDCycriptManager sharedInstance];<br>        [manager loadCycript:NO];<br><br>        NSError* error;<br>        NSString* result = [manager evaluateCycript:@&quot;UIApp&quot; error:&amp;error];<br>        NSLog(@&quot;result: %@&quot;, result);<br>        if(error.code != 0)&#123;<br>            NSLog(@&quot;error: %@&quot;, error.localizedDescription);<br>        &#125;<br>#endif<br>        <br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要Cycript链接到目标应用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cycript</span> -r IP:<span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>UIApp</li><li>NSHomeDirectory()</li><li>[[NSBundle mainBundle] bundleIdentifier]</li><li>UIApp.delegate</li><li>UIApp.keyWindow</li><li>UIApp.keyWindow.recursiveDescription().toString()</li><li>UIApp.keyWindow.rootViewController </li><li>#address :获取该对象</li><li>*#address:打印该对象成员变量</li><li>?exit</li></ul><h3 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">alert = [[<span class="hljs-built_in">UIAlertView</span> alloc]initWithTitle:<span class="hljs-string">&quot;@@&quot;</span> message:<span class="hljs-string">&quot;hahaha&quot;</span> delegate:<span class="hljs-literal">nil</span> cancelButtonTitle:<span class="hljs-string">&quot;OK&quot;</span> otherButtonTitles:<span class="hljs-literal">nil</span>]<br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">[alert <span class="hljs-keyword">show</span>]<br>[#<span class="hljs-number">0x1046bcbc0</span> <span class="hljs-keyword">show</span>]<br>alert.<span class="hljs-keyword">show</span>()<br></code></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>将手机语言设置未英文（方便定位），进入设置-关于</p></li><li><p>打印当前页面的所有信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">UIApp.keyWindow.recursiveDescription().toString()<br><br><span class="hljs-comment">//只显示一部分</span><br> &lt;PSTableCell: <span class="hljs-number">0x10392e000</span>; baseClass = UITableViewCell; frame = (<span class="hljs-number">0</span> <span class="hljs-number">290</span>; <span class="hljs-number">375</span> <span class="hljs-number">44</span>); text = <span class="hljs-string">&#x27;Network&#x27;</span>; autoresize = W; tag = <span class="hljs-number">4</span>; layer = &lt;CALayer: <span class="hljs-number">0x2811e46a0</span>&gt;&gt;\n<br></code></pre></td></tr></table></figure><p>可以看见Network的PSTableCell以及对象地址</p></li><li><p>隐藏/显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//隐藏</span><br>[#<span class="hljs-number">0x10392e000</span> setHidden:YES]<br><span class="hljs-comment">//显示</span><br>[#<span class="hljs-number">0x10392e000</span> setHidden:NO]<br></code></pre></td></tr></table></figure></li><li><p>通过nextResponder找到cell对应的controller</p><p>通过三次nextResponder最终找到了controller-&gt;PSGAboutController</p> <img src="/2021/08/22/iOS-cycript/images/%E4%BF%AE%E6%94%B9controller.png" class=""></li><li><p>修改controller的标题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[#<span class="hljs-number">0x104137400</span> setTitle:<span class="hljs-string">&quot;Cola&quot;</span>]<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>hook</tag>
      
      <tag>cycript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之Tweak</title>
    <link href="/2021/08/22/iOS-Tweak/"/>
    <url>/2021/08/22/iOS-Tweak/</url>
    
    <content type="html"><![CDATA[<h2 id="编写HOOK插件"><a href="#编写HOOK插件" class="headerlink" title="编写HOOK插件"></a>编写HOOK插件</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>. 终端输入<span class="hljs-selector-tag">nic</span><span class="hljs-selector-class">.pl</span><br><span class="hljs-selector-tag">2</span>. <span class="hljs-selector-tag">Choose</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">Template</span> (required): <span class="hljs-selector-tag">10</span><br><span class="hljs-selector-tag">3</span>. <span class="hljs-selector-tag">Project</span> <span class="hljs-selector-tag">Name</span> (required): 工程名<br><span class="hljs-selector-tag">4</span>. <span class="hljs-selector-tag">Package</span> <span class="hljs-selector-tag">Name</span> <span class="hljs-selector-attr">[com.yourcompany.tututest]</span>:  包名:<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span><br><span class="hljs-selector-tag">5</span>. <span class="hljs-selector-tag">Author</span>/<span class="hljs-selector-tag">Maintainer</span> <span class="hljs-selector-tag">Name</span> <span class="hljs-selector-attr">[lk]</span>: 作者<br><span class="hljs-selector-tag">6</span>. <span class="hljs-selector-attr">[iphone/tweak]</span> <span class="hljs-selector-tag">MobileSubstrate</span> <span class="hljs-selector-tag">Bundle</span> <span class="hljs-selector-tag">filter</span> <span class="hljs-selector-attr">[com.apple.springboard]</span>: 要<span class="hljs-selector-tag">Hook</span>的包名<br><span class="hljs-selector-tag">7</span>. <span class="hljs-selector-attr">[iphone/tweak]</span> <span class="hljs-selector-tag">List</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">applications</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">terminate</span> <span class="hljs-selector-tag">upon</span> <span class="hljs-selector-tag">installation</span> (space-separated, <span class="hljs-string">&#x27;-&#x27;</span> for none) <span class="hljs-selector-attr">[SpringBoard]</span>: 回车默认<br><br></code></pre></td></tr></table></figure><h3 id="工程文件简介"><a href="#工程文件简介" class="headerlink" title="工程文件简介"></a>工程文件简介</h3><p>创建好的工程下共有4个文件</p> <img src="/2021/08/22/iOS-Tweak/images/tweakproject.png" class=""><ul><li><p>Makefile   编译文件</p></li><li><p>Tweak.x    编写HOOK文件</p></li><li><p>control     插件作者、版本信息</p></li><li><p>demo001.plist  设置要HOOK的Bundle ID</p></li></ul><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><p>指定工程用到的文件,框架,库等信息,将整个过程自动化</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">INSTALL_TARGET_PROCESSES = SpringBoard<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(THEOS)</span>/makefiles/common.mk<br><br>TWEAK_NAME = demo001<br><br>demo001_FILES = Tweak.x<br>demo001_CFLAGS = -fobjc-arc<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(THEOS_MAKE_PATH)</span>/tweak.mk<br></code></pre></td></tr></table></figure><ol><li>INSTALL_TARGET_PROCESSES = SpringBoard 目标安装的项目</li><li>include $(THEOS)/makefiles/common.mk 固定写法 </li><li>TWEAK_NAME = demo001 tweak的名称</li><li>demo001_FILES = Tweak.x tweak源文件,多个文件以空格分隔</li><li>include $(THEOS_MAKE_PATH)/tweak.mk 通过include命令指定不同的.mk文件</li></ol><p>除了上面的信息格式,我们还可以添加以下信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">我们如何通过进行指定SDK?<br>TARGET = iPhone:latest:8.0 <br><br>我们如何导入framework?<br>demo001_FRAMWORKS = UIKit  <br><br>我们如何指定处理器架构<br>ARCHS = armv7 arm64  <br><br>我么如何链接Mach-O对象<br>demo001_LDFLAGS = -lx<br>注意<br>-lx 代表链接libx.a或libx.dylib,即给x加上lib的前缀,以及.a或.dylib的后缀,可以根据自己的项目进行调整<br><br></code></pre></td></tr></table></figure><h4 id="Tweak-x"><a href="#Tweak-x" class="headerlink" title="Tweak.x"></a>Tweak.x</h4><p>xm 中的x代表这个文件支持Logos语法</p><p>x 如果后缀名是单独的x,说明源文件支持Logos和C语法;</p><p>xm 如果后缀名是xm,说明源文件支持Logos和C/C++语法.</p><p>.xi 将首先作为objective-c进行预处理，然后Logos将处理结果，然后将进行编译。</p><p>.xmi 将首先作为objective-c ++进行预处理，然后Logos将处理结果，然后将进行编译。</p><h4 id="demo001-plist"><a href="#demo001-plist" class="headerlink" title="demo001.plist"></a>demo001.plist</h4><p>用于指定需要注入的目标文件的Bundle ID</p><h4 id="control"><a href="#control" class="headerlink" title="control"></a>control</h4><p>指定deb包的一些信息,包括名字,描述,版本号等</p><h3 id="编写HOOK代码"><a href="#编写HOOK代码" class="headerlink" title="编写HOOK代码"></a>编写HOOK代码</h3><p>编辑tweak.x</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-comment">//hook ViewController的test方法</span><br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> ViewController<br><br>-<span class="ruby"> (void)test&#123;</span><br><span class="ruby"></span><br>    NSLog(@&quot;🍺🍺🍺HOOK🍺🍺🍺&quot;);<br>&#125;<br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> THEOS_DEVICE_IP = localhost<br><span class="hljs-builtin-name">export</span> THEOS_DEVICE_PORT = 2222<br></code></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>使用iproxy转发手机22端口到本地2222</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iproxy</span> <span class="hljs-number">2222</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>终端输入 make；make package install</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span><br><span class="hljs-built_in">make</span> <span class="hljs-keyword">package</span> install<br></code></pre></td></tr></table></figure><h2 id="Logos语法"><a href="#Logos语法" class="headerlink" title="Logos语法"></a>Logos语法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//i</span>phonedevwiki.net<span class="hljs-regexp">/index.php/</span>Logos<br></code></pre></td></tr></table></figure><table><thead><tr><th>Logos语法</th><th>功能解释</th><th>事例</th></tr></thead><tbody><tr><td>%hook</td><td>需要hook哪个类</td><td>%hook Classname</td></tr><tr><td>%end</td><td>代码块结束标记</td><td>%end</td></tr><tr><td>%group</td><td>分组</td><td>%group Groupname</td></tr><tr><td>%new</td><td>添加新方法</td><td>%new(signature)</td></tr><tr><td>%ctor</td><td>构造函数</td><td>%ctor { … }</td></tr><tr><td>%dtor</td><td>析构函数</td><td>%dtor { … }</td></tr><tr><td>%log</td><td>输出打印</td><td>%log; %log([(), …]);</td></tr><tr><td>%orig</td><td>保持原有方法</td><td>%orig；%orig(arg1, …)；</td></tr><tr><td>%c</td><td>动态获取类</td><td>%c([+/-]Class)；</td></tr></tbody></table><h3 id="1-hook-end"><a href="#1-hook-end" class="headerlink" title="1. %hook %end"></a>1. %hook %end</h3><p>指定需要hook的class,必须以％end结尾。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-comment">// hook SpringBoard类里面的_menuButtonDown函数,先打印一句话,再之子那个函数原始的操作</span><br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBorad<br>-<span class="ruby"> (void)<span class="hljs-symbol">_menuButtonDown:</span>(id)down</span><br><span class="ruby"></span>&#123;<br>    NSLog(@&quot;111111&quot;);<br><span class="hljs-tag">   %<span class="hljs-selector-tag">orig</span></span>; // 调用原始的_menuButtonDown函数<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="2-group"><a href="#2-group" class="headerlink" title="2.%group"></a>2.%group</h3><p>该指令用于将%hook分组，便于代码管理及按条件初始化分组，必须以%end结尾。 </p><p>一个％group可以包含多个%hook,所有不属于某个自定义group的％hook会被隐式归类到％group_ungrouped中。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">group</span></span> iOS8<br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> IOS8_SPECIFIC_CLASS<br><span class="hljs-comment">    // your code here</span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end hook<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end group ios8<br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">group</span></span> iOS9<br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> IOS9_SPECIFIC_CLASS<br><span class="hljs-comment">    // your code here</span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end hook<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end group ios9<br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">ctor</span></span> &#123;<br>    if (kCFCoreFoundationVersionNumber &gt; 1200) &#123;<br><span class="hljs-tag">        %<span class="hljs-selector-tag">init</span>(iOS9)</span>;<br>    &#125; else &#123;<br><span class="hljs-tag">        %<span class="hljs-selector-tag">init</span>(iOS8)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-new"><a href="#3-new" class="headerlink" title="3.%new"></a>3.%new</h3><p>在%hook内部使用，给一个现有class添加新函数，功能与class_addMethod相同. </p><p>注：<br>Objective-C的category与class_addMethod的区别： </p><p>前者是静态的而后者是动态的。使用%new添加,而不需要向.h文件中添加函数声明,如果使用category,可能与遇到这样那样的错误.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBoard<br><span class="hljs-tag">%<span class="hljs-selector-tag">new</span></span><br>-<span class="ruby"> (void)addNewMethod</span><br><span class="ruby"></span>&#123;<br>    NSLog(@&quot;动态添加一个方法到SpringBoard&quot;);<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="4-ctor"><a href="#4-ctor" class="headerlink" title="4.%ctor"></a>4.%ctor</h3><p>tweak的constructor,完成初始化工作；如果不显示定义，Theos会自动生成一个%ctor,并在其中调用%init(_ungrouped)。</p><p>%ctor一般可以用来初始化%group,以及进行MSHookFunction等操作,如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#ifndef KCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KCFCoreFoundationVersionNumber_iOS_8_0      1140.10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>%ctor<br>&#123;<br>    %<span class="hljs-keyword">init</span>;<br><br>    <span class="hljs-keyword">if</span> (KCFCoreFoundationVersionNumber &gt;= KCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; KCFCoreFoundationVersionNumber &gt; KCFCoreFoundationVersionNumber_iOS_8_0)<br>    %<span class="hljs-keyword">init</span>(iOS7Hook);<br> <span class="hljs-keyword">if</span> (KCFCoreFoundationVersionNumber &gt;= KCFCoreFoundationVersionNumber_iOS_8_0)<br>    %<span class="hljs-keyword">init</span>(iOS8Hook);<br>MSHookFunction((<span class="hljs-keyword">void</span> *)&amp;AudioServicesPlaySystemSound,(<span class="hljs-keyword">void</span> *)&amp;replaced_AudioServerPlaySystemSound,(<span class="hljs-keyword">void</span> **)&amp;orginal_AudioServicesPlaySystemSound);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-dtor"><a href="#5-dtor" class="headerlink" title="5.%dtor"></a>5.%dtor</h3><p>Generate an anonymous deconstructor (of default priority).</p><h3 id="6-log"><a href="#6-log" class="headerlink" title="6.%log"></a>6.%log</h3><p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog,可以％log([(),…..])的格式追加其他打印信息。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBorad<br>-<span class="ruby"> (void)<span class="hljs-symbol">_menuButtonDown:</span>(id)down</span><br><span class="ruby"></span>&#123;<br><span class="hljs-tag">    %<span class="hljs-selector-tag">log</span>((NSString *)</span>@&quot;iosre&quot;,(NSString *)@&quot;Debug&quot;);<br><span class="hljs-tag">    %<span class="hljs-selector-tag">orig</span></span>; // 调用原始的_menuButtonDown方法<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="7-orig"><a href="#7-orig" class="headerlink" title="7.%orig"></a>7.%orig</h3><p>该指令在%hook内部使用，执行被hook的函数的原始代码；也可以用％orig更改原始函数的参数。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBorad<br>-<span class="ruby"> (void)<span class="hljs-symbol">setCustomSubtitleText:</span>(id)arg1 <span class="hljs-symbol">withColor:</span>   (id)arg2</span><br><span class="ruby"></span>&#123;<br><span class="hljs-tag">    %<span class="hljs-selector-tag">orig</span>(@&quot;change arg2&quot;,arg2)</span>;// 将arg2的参数修 改为&quot;change arg2&quot;<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="8-init"><a href="#8-init" class="headerlink" title="8.%init"></a>8.%init</h3><p>该指令用于初始化某个％group，必须在%hook或％ctor内调用；如果带参数，则初始化指定的group，如果不带参数，则初始化_ungrouped. </p><p>注： 切记，只有调用了％init,对应的%group才能起作用！</p><h3 id="9-c"><a href="#9-c" class="headerlink" title="9.%c"></a>9.%c</h3><p>该指令的作用等同于objc_getClass或NSClassFromString,即动态获取一个类的定义，在%hook或％ctor内使用 。</p><p>调用ViewController中的Method方法</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">[[[%c(ViewController) alloc ] init]<span class="hljs-function"><span class="hljs-keyword">Method</span>];</span> <br></code></pre></td></tr></table></figure><h2 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h2><p>hook demo方法并添加打印入参</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> <br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;ViewController.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br> <span class="hljs-comment">//点击事件</span><br>- (<span class="hljs-keyword">IBAction</span>)compute;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>    <br>&#125;<br> <br>- (<span class="hljs-keyword">IBAction</span>)compute &#123;<br>    <br>    [<span class="hljs-keyword">self</span> demo:<span class="hljs-string">@&quot;66&quot;</span>];<br>    <br>&#125;<br> <br>- (<span class="hljs-keyword">void</span>)demo:(<span class="hljs-built_in">NSString</span> *)str&#123;<br>   <span class="hljs-built_in">NSString</span> *res = [str stringByAppendingString:<span class="hljs-string">@&quot;🐂🐂🐂&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(res);<br>  <br>    <br>&#125;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><p>logify.pl生成.xm文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//根据class-dump后的ViewController.h生成.x文件</span><br>logify.pl <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewController</span>.</span></span>h &gt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Tweak</span>.</span></span>x<br></code></pre></td></tr></table></figure><p>我们之关系程序中自己写的方法</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-comment">//经过删减过后的Tweak.x文件</span><br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> ViewController<br> <br>-<span class="ruby"> (void)<span class="hljs-symbol">demo:</span>(id)arg1 &#123; %log; %orig; &#125;</span><br><span class="ruby"></span><span class="hljs-tag"> </span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br><br></code></pre></td></tr></table></figure><p>将生成的Tweak.x文件替换theos生成的Tweak.x文件后编译安装即可</p><p>查看打印日志</p> <img src="/2021/08/22/iOS-Tweak/images/logify.png" class="">]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>hook</tag>
      
      <tag>tweak</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS文件结构</title>
    <link href="/2021/08/22/IOS%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2021/08/22/IOS%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>目录结构</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs coq">/<br>|<br><span class="hljs-type">---Developer</span>/<br>|<br><span class="hljs-type">---Applications</span>/<br>|<br><span class="hljs-type">---Library</span>/<br>|<br><span class="hljs-type">---System</span>/<br>|<br><span class="hljs-type">---bin</span>/<br>|<br><span class="hljs-type">---sbin</span>/<br>|<br><span class="hljs-type">---boot</span>/<br>|<br><span class="hljs-type">---cores</span>/<br>|<br><span class="hljs-type">---dev</span>/<br>|<br><span class="hljs-type">---usr</span>/<br>|<br><span class="hljs-type">---lib</span>/<br>|<br><span class="hljs-type">---mnt</span>/<br>|<br><span class="hljs-type">---tmp</span> -&gt; private/var/tmp/<br>|<br><span class="hljs-type">---etc</span> -&gt; private/etc/<br>|<br><span class="hljs-type">---User</span> -&gt; /var/mobile/<br>|<br><span class="hljs-type">---var</span> -&gt; private/var/<br>|<br><span class="hljs-type">---private</span>/<br></code></pre></td></tr></table></figure><h2 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h2><h3 id="1-Developer"><a href="#1-Developer" class="headerlink" title="1. /Developer"></a>1. /Developer</h3><pre><code>开发者相关库、工具</code></pre><h3 id="2-Applications"><a href="#2-Applications" class="headerlink" title="2. /Applications"></a>2. /Applications</h3><pre><code>系统APP</code></pre><h3 id="3-Library"><a href="#3-Library" class="headerlink" title="3. /Library"></a>3. /Library</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用户缓存数据<br></code></pre></td></tr></table></figure><p>越狱相关文件会存放该目录下</p><p>3.1 /Library/dpkg <code>cydia dpkg目录</code></p><pre><code>安装插件使用的文件路径、插件卸载脚本、插件签名/var/lib/dpkg/infoinfo|--- re.frida.server.list 所使用的文件|--- re.frida.server.md5sums 签名|--- re.frida.server.prerm 卸载脚本</code></pre><p>3.2 /Library/LaunchDaemons  <code>越狱后添加后台运行程序,以plist文件形式存放</code></p><p>3.3 /Library/MobileSubstrate <code>越狱插件相关目录</code></p><pre><code>/Library/MobileSubstrate/DynamicLibraries 越狱插件安装目录,结构如下DynamicLibraries |---inject.plist|---inject.dylibplist文件中包含要hook的app或组件的信息，cydia负责将对应的dylib加载到hook的进程中</code></pre><p> 3.4 /Library/PreferenceBundles <code>越狱插件的界面，如FlyJB会在设置中有个设置界面，对应该目录下的资源文件,注:要想使用界面功能需要先安装P  referenceLoader插件</code></p><p> 3.5 /Library/PreferenceLoader/Preferences <code>越狱插件的用户偏好设置</code></p><p> 3.6 /Library/Ringtones <code>系自带的来电铃声存放目录(ACC文件结构)</code></p><h3 id="4-System"><a href="#4-System" class="headerlink" title="4.  /System"></a>4.  /System</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统缓存数据、库文件<br></code></pre></td></tr></table></figure><p>4.1 /System/Library/LaunchDaemons</p><pre><code>设置系统守护进程目录，plist文件设置</code></pre><p>4.1 /System/Library/Frameworks   /System/Library/PrivateFrameworks</p><pre><code>系统动态库</code></pre><h3 id="5-bin-sbin"><a href="#5-bin-sbin" class="headerlink" title="5. /bin  /sbin"></a>5. /bin  /sbin</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">命令<br></code></pre></td></tr></table></figure><h3 id="6-boot"><a href="#6-boot" class="headerlink" title="6. /boot"></a>6. /boot</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">引导相关，该文件夹为空<br></code></pre></td></tr></table></figure><h3 id="7-dev"><a href="#7-dev" class="headerlink" title="7. /dev"></a>7. /dev</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">设备文件<br></code></pre></td></tr></table></figure><h3 id="8-usr"><a href="#8-usr" class="headerlink" title="8. /usr"></a>8. /usr</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统核心库、命令<br></code></pre></td></tr></table></figure><p>8.1  /usr/lib/substrate <code>越狱核心库文件</code></p><pre><code>substrate|--- SubstrateBootstrap.dylib|--- SubstrateInserter.dylib|--- SubstrateLoader.dylib运行APP会加载3个dylib</code></pre><h3 id="9-tmp"><a href="#9-tmp" class="headerlink" title="9. /tmp"></a>9. /tmp</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">软连接到 <span class="hljs-regexp">/private/</span>tmp/<br></code></pre></td></tr></table></figure><h3 id="10-etc"><a href="#10-etc" class="headerlink" title="10. /etc"></a>10. /etc</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">软连接到 <span class="hljs-regexp">/private/</span>etc/<br></code></pre></td></tr></table></figure><h3 id="11-User"><a href="#11-User" class="headerlink" title="11. /User"></a>11. /User</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">软件接到 <span class="hljs-regexp">/var/m</span>obile/<br></code></pre></td></tr></table></figure><h3 id="12-var"><a href="#12-var" class="headerlink" title="12. /var"></a>12. /var</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">软件接到 <span class="hljs-keyword">private</span>/<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><h3 id="13-private"><a href="#13-private" class="headerlink" title="13. /private"></a>13. /private</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">核心文件系统<br></code></pre></td></tr></table></figure><p>13.1 /private/etc <code>配置文件</code></p><p>13.2 /private/system_data <code>空文件夹</code></p><p>13.3 /private/xarts <code>unknow</code></p><p>13.4 /private/var</p><pre><code>系统核心目录，root、mobile家目录、app安装目录、用户数据、存储.........都在该目录下</code></pre><h2 id="private-var目录"><a href="#private-var目录" class="headerlink" title="/private/var目录"></a>/private/var目录</h2><h3 id="1-Keychains"><a href="#1-Keychains" class="headerlink" title="1. Keychains"></a>1. Keychains</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Keychains</span> 加密后数据<br></code></pre></td></tr></table></figure><p>   1.1  /var/Keychains/keychain-2.db</p><pre><code>存放加密后数据</code></pre><p>1.2 /var/Keychains/TrustStore.sqlite3</p><pre><code>导入证书数据</code></pre><h3 id="2-MobileDevice"><a href="#2-MobileDevice" class="headerlink" title="2. MobileDevice"></a>2. MobileDevice</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">描述文件<br></code></pre></td></tr></table></figure><p>2.1 /var/MobileDevice/ProvisioningProfiles</p><pre><code>安装的描述文件</code></pre><h3 id="3-MobileSoftwareUpdate"><a href="#3-MobileSoftwareUpdate" class="headerlink" title="3. MobileSoftwareUpdate"></a>3. MobileSoftwareUpdate</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统升级相关<br></code></pre></td></tr></table></figure><h3 id="4-binpack"><a href="#4-binpack" class="headerlink" title="4. binpack"></a>4. binpack</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">checkra</span>越狱后的checkra<span class="hljs-number">1</span>n APP安装目录<br></code></pre></td></tr></table></figure><h3 id="5-cache"><a href="#5-cache" class="headerlink" title="5. cache"></a>5. cache</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">缓存目录，apt会缓存数据到该目录<br></code></pre></td></tr></table></figure><h3 id="6-containers"><a href="#6-containers" class="headerlink" title="6. containers"></a>6. containers</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">用户<span class="hljs-keyword">APP</span>安装目录、共享数据<br></code></pre></td></tr></table></figure><p>6.1 /var/containers/Bundle/Application</p><pre><code>用户APP安装目录</code></pre><p>6.2 /var/containers/Shared</p><pre><code>    APP共享数据目录</code></pre><h3 id="7-db"><a href="#7-db" class="headerlink" title="7. db"></a>7. db</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统文件，铃声，壁纸，系统设置，界面，ui<br></code></pre></td></tr></table></figure><h3 id="8-installd"><a href="#8-installd" class="headerlink" title="8. installd"></a>8. installd</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">安装APP，安装APP时可能会先缓存到<span class="hljs-regexp">/var/i</span>nstalld<span class="hljs-regexp">/Library/</span>Caches/com.apple.mobile.installd.staging<br></code></pre></td></tr></table></figure><h3 id="9-keybags"><a href="#9-keybags" class="headerlink" title="9. keybags"></a>9. keybags</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">锁屏密码相关<br></code></pre></td></tr></table></figure><h3 id="10-lib"><a href="#10-lib" class="headerlink" title="10. lib"></a>10. lib</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">cydia相关文件<br></code></pre></td></tr></table></figure><p>10.1 /var/lib/apt <code>apt相关文件</code></p><p>10.2 /var/lib/cydia/firmware.ver <code>cydia版本</code></p><p>10.3 /var/lib/dpkg <code>软链接到/Library/dpkg</code></p><h3 id="11-log-logs"><a href="#11-log-logs" class="headerlink" title="11. log logs"></a>11. log logs</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">日志相关<br></code></pre></td></tr></table></figure><h3 id="12-networkd"><a href="#12-networkd" class="headerlink" title="12. networkd"></a>12. networkd</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">网络相关<br></code></pre></td></tr></table></figure><h3 id="13-preferences"><a href="#13-preferences" class="headerlink" title="13. preferences"></a>13. preferences</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">偏好设置<br></code></pre></td></tr></table></figure><h3 id="14-run"><a href="#14-run" class="headerlink" title="14. run"></a>14. run</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">UNKNOW</span><br></code></pre></td></tr></table></figure><h3 id="15-vm"><a href="#15-vm" class="headerlink" title="15. vm"></a>15. vm</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">虚拟内存<br></code></pre></td></tr></table></figure><h3 id="16-wireless"><a href="#16-wireless" class="headerlink" title="16. wireless"></a>16. wireless</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">UNKNOW</span><br></code></pre></td></tr></table></figure><h3 id="17-tmp"><a href="#17-tmp" class="headerlink" title="17. tmp"></a>17. tmp</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">临时文件<br></code></pre></td></tr></table></figure><h3 id="18-root"><a href="#18-root" class="headerlink" title="18. root"></a>18. root</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">root用户家目录<br></code></pre></td></tr></table></figure><h3 id="19-mobile"><a href="#19-mobile" class="headerlink" title="19. mobile"></a>19. mobile</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">mobile用户家目录<br></code></pre></td></tr></table></figure><p>19.1 Documents <code>mobile用户文档,CrackerXI会脱壳到该目录下</code></p><p>19.2 Media <code>相册、电子书、录音等</code></p><pre><code>相册照片/var/mobile/Media/DCIMiTunes上传的多媒体文件目录/var/mobile/Media/iTunes_Control照片里的图片/var/mobile/Media/Photos语音备忘录/var/mobile/Media/Recordings</code></pre><p>​    </p><p>19.3 Library <code>mobile用户缓存数据</code></p><pre><code>APP安装后生成的安装路径、沙箱目录名称 会存储在该DB/var/mobile/Library/FrontBoard/applicationState.db存储通讯录/var/mobile/Library/AddressBook存储短信/var/mobile/Library/SMS存储备忘录/var/mobile/Library//var/mobile/Library</code></pre><p>19.4 Containers <code>APP沙箱、共享数据等</code></p><pre><code>APP沙箱目录/var/mobile/Containers/Data/Application/xxxxAPP沙箱目录|--- Documents 文档目录,存储一些文件|--- Library 缓存数据|   ||   --- Caches 缓存|   ||   --- Preferences 用户偏好设置，一般该目录下会存在.plist|   | |   --- Cookies 使用WebKit时cookie存储路径|   ||   --- WebKit/WebsiteData  H5本地缓存数据、IndexedDB、WebSQL等|   ||   --- SplashBoard/Snapshots 挂起快照,启动图缓存|   ||   --- .....|--- SystemData APP运行产生的数据一般很少使用|--- tmp  临时文件</code></pre><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReactNative分析</title>
    <link href="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/"/>
    <url>/2021/08/22/ReactNative%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，支持iOS和安卓两大平台</p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><p>核心代码为js编写，在安装包assest目录下存放index.android.bundle（有可能重命名，因为rn本身仅仅做了混淆，使用编辑器打开即可分析js代码。</p><p>注：部分APP可能会将index.android.bundle加密，运行时解密加载</p><h3 id="2-1-数据解密"><a href="#2-1-数据解密" class="headerlink" title="2.1 数据解密"></a>2.1 数据解密</h3><h4 id="2-1-1-通过请求包关键字定位到加密点"><a href="#2-1-1-通过请求包关键字定位到加密点" class="headerlink" title="2.1.1 通过请求包关键字定位到加密点"></a>2.1.1 通过请求包关键字定位到加密点</h4> <img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%8A%A0%E5%AF%86%E7%82%B9.png" class=""><h4 id="2-1-2-新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密"><a href="#2-1-2-新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密" class="headerlink" title="2.1.2 新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密"></a>2.1.2 新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密</h4> <img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/node%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%A7%A3%E5%AF%86.png" class=""><h4 id="2-1-3编写burp插件，java调用js加解密方法"><a href="#2-1-3编写burp插件，java调用js加解密方法" class="headerlink" title="2.1.3编写burp插件，java调用js加解密方法"></a>2.1.3编写burp插件，java调用js加解密方法</h4><p>xxxxx</p><h3 id="2-2-bundle代码篡改"><a href="#2-2-bundle代码篡改" class="headerlink" title="2.2 bundle代码篡改"></a>2.2 bundle代码篡改</h3><p>对于非对称加密需要将bundle中的公钥进行替换，所以需要对bundle进行篡改。<br>index.android.bundle中的js最终是需要被load到内存中，所以在某一时刻是可以获取，将load前的index.android.bundle进行篡改。</p><h4 id="2-2-1-分析rn加载流程"><a href="#2-2-1-分析rn加载流程" class="headerlink" title="2.2.1 分析rn加载流程"></a>2.2.1 分析rn加载流程</h4><p><strong>com.facebook.react.ReactNativeHost.createReactInstanceManager</strong>方法</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/createReactInstanceManager.png" class=""><p>如上图 <strong>小1</strong> 由用户指定bundle路径，一般来说如果bundle加密了，解密后会将jSBundleFile设置为bundle解密后文件路径，由RN负责加载，此时可以HOOK该方法，进行解密后的bundle dump。</p><p>进入<strong>jSBundleFile</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ReactInstanceManagerBuilder <span class="hljs-title">setJSBundleFile</span><span class="hljs-params">(String str)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!str.startsWith(<span class="hljs-string">&quot;assets://&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> setJSBundleLoader(JSBundleLoader.createFileLoader(str));<br>    &#125;<br>    <span class="hljs-keyword">this</span>.mJSBundleAssetUrl = str;<br>    <span class="hljs-keyword">this</span>.mJSBundleLoader = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  解密后的文件路径固然不能是assets开头的，所以会走setJSBundleLoader流程</p><p>  dump bundle脚本，获取到bundle文件后即可进行篡改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ReactInstanceManagerBuilder = Java.use(<span class="hljs-string">&quot;com.facebook.react.ReactInstanceManagerBuilder&quot;</span>);<br>ReactInstanceManagerBuilder.setJSBundleFile.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bundle path is :&quot;</span>,path);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>.setJSBundleFile(path);<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上图 <strong>小2</strong> 如果用户未指定jSBundleFile，则默认调用setBundleAssetName方法，如下图会加载assets路径下的<strong>index.android.bundle</strong>(这也是为什么app资源路径下bundle默认名为index.android.bundle的原因)</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/setBundleAssetName.png" class=""><h4 id="2-2-2-篡改bundle"><a href="#2-2-2-篡改bundle" class="headerlink" title="2.2.2 篡改bundle"></a>2.2.2 篡改bundle</h4><h5 id="2-2-2-1-将index-android-bundle中的加密方法删除"><a href="#2-2-2-1-将index-android-bundle中的加密方法删除" class="headerlink" title="2.2.2.1 将index.android.bundle中的加密方法删除"></a>2.2.2.1 将index.android.bundle中的加密方法删除</h5><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E7%AF%A1%E6%94%B9bundle.png" class=""><h5 id="2-2-2-2-push至手机sd卡下"><a href="#2-2-2-2-push至手机sd卡下" class="headerlink" title="2.2.2.2 push至手机sd卡下"></a>2.2.2.2 push至手机sd卡下</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">adb</span> <span class="hljs-keyword">push</span> xxxx /sdcard<br></code></pre></td></tr></table></figure><h5 id="2-2-2-3-HOOK-setBundleAssetName，load修改后bundle"><a href="#2-2-2-3-HOOK-setBundleAssetName，load修改后bundle" class="headerlink" title="2.2.2.3 HOOK setBundleAssetName，load修改后bundle"></a>2.2.2.3 HOOK setBundleAssetName，load修改后bundle</h5><p>因为setBundleAssetName方法会对当前入参路径拼接assets://，所以在该方法下不能简单的HOOK修改入参（bundle路径），故HOOK该方法，篡改代码逻辑，强制走上面分析中的<strong>小1</strong>流程</p><p>frida hook脚本如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ReactInstanceManagerBuilder = Java.use(<span class="hljs-string">&quot;com.facebook.react.ReactInstanceManagerBuilder&quot;</span>);<br><span class="hljs-keyword">var</span> JSBundleLoader = Java.use(<span class="hljs-string">&quot;com.facebook.react.bridge.JSBundleLoader&quot;</span>)<br>ReactInstanceManagerBuilder.setBundleAssetName.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bundle path is :&quot;</span>,path);<br>    <span class="hljs-keyword">var</span> newPath = <span class="hljs-string">&quot;/storage/emulated/0/index.android.bundle&quot;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.setJSBundleLoader(JSBundleLoader.$new().createFileLoader(newPath));<br>&#125;;<br></code></pre></td></tr></table></figure><p>burp抓包未篡改js与篡改js后请求包对比</p><p>未篡改，数据已加密</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E5%8A%A0%E5%AF%86.png" class=""><p>篡改后，明文</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E8%A7%A3%E5%AF%86.png" class="">]]></content>
    
    
    <categories>
      
      <category>ReactNative</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
      <tag>ReactNative</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go交叉编译</title>
    <link href="/2021/08/22/go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <url>/2021/08/22/go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="查看支持架构"><a href="#查看支持架构" class="headerlink" title="查看支持架构"></a>查看支持架构</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">go tool dist list</span><br></code></pre></td></tr></table></figure><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>Linux elf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build hello.go<br></code></pre></td></tr></table></figure><p>arm架构</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">GOARM</span>=7 <span class="hljs-attribute">GOARCH</span>=arm <span class="hljs-attribute">GOOS</span>=linux go build<br></code></pre></td></tr></table></figure><p>其中-w为去掉调试信息，-s为去掉符号表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs GOOS">GOOS=linux GOARCH=mips64  go build -ldflags &quot;-s -w&quot; main.go<br></code></pre></td></tr></table></figure><p>参数解析</p><p>GOOS：目标操作系统<br>GOARCH：目标操作系统的架构</p><table><thead><tr><th>OS</th><th>ARCH</th><th>OS version</th></tr></thead><tbody><tr><td>linux</td><td>386 / amd64 / arm</td><td>&gt;= Linux 2.6</td></tr><tr><td>darwin</td><td>386 / amd64</td><td>OS X (Snow Leopard + Lion)</td></tr><tr><td>freebsd</td><td>386 / amd64</td><td>&gt;= FreeBSD 7</td></tr><tr><td>windows</td><td>386 / amd64</td><td>&gt;= Windows 2000</td></tr></tbody></table><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p> 在网络上的诸多教程中可能会看到下面的编译命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build hello.go<br></code></pre></td></tr></table></figure><p>其中CGO_ENABLED=0的意思是使用C语言版本的GO编译器，</p><p>参数配置为0的时候就关闭C语言版本的编译器了。</p><p>自从golang1.5以后go就使用go语言编译器进行编译了。</p><p>在golang1.9当中没有使用CGO_ENABLED参数发现依然可以正常编译。当然使用了也可以正常编译。</p><p>比如把CGO_ENABLED参数设置成1，即在编译的过程当中使用CGO编译器，我发现依然是可以正常编译的。</p><p>实际上如果在go当中使用了C的库，</p><p>比如import “C”默认使用go build的时候就会启动CGO编译器，当然我们可以使用CGO_ENABLED=0来控制go build是否使用CGO编译器。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter编译release版本</title>
    <link href="/2021/08/22/flutter%E7%BC%96%E8%AF%91release%E7%89%88%E6%9C%AC/"/>
    <url>/2021/08/22/flutter%E7%BC%96%E8%AF%91release%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="1-生成jks"><a href="#1-生成jks" class="headerlink" title="1. 生成jks"></a>1. 生成jks</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">keytool -genkey -v -keystore ~/<span class="hljs-built_in">key</span>.jks -keyalg RSA -keysize <span class="hljs-number">2048</span> -validity <span class="hljs-number">10000</span> -<span class="hljs-built_in">alias</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="2-创建key-properities"><a href="#2-创建key-properities" class="headerlink" title="2. 创建key.properities"></a>2. 创建key.properities</h2><p>flutter-project/android下创建key.properities</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">storePassword</span> = <span class="hljs-number">123456</span><br><span class="hljs-attr">keyPassword</span> = <span class="hljs-number">123456</span><br><span class="hljs-attr">keyAlias</span> = key<br><span class="hljs-attr">storeFile</span> = xxx/xxx/key.jks<br></code></pre></td></tr></table></figure><h2 id="3-修改build-gradle"><a href="#3-修改build-gradle" class="headerlink" title="3.修改build.gradle"></a>3.修改build.gradle</h2><p>flutter-project/android/app/build.gradle</p><p>android {}上面粘贴</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> keystorePropertiesFile = rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;key.properties&quot;</span>)<br><span class="hljs-keyword">def</span> keystoreProperties = <span class="hljs-keyword">new</span> Properties()<br>keystoreProperties.load(<span class="hljs-keyword">new</span> FileInputStream(keystorePropertiesFile))<br><br></code></pre></td></tr></table></figure><p>修改buildTypes</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">buildTypes</span> &#123;<br>    <span class="hljs-section">release</span> &#123;<br>        <span class="hljs-attribute">signingConfig</span> signingConfigs.release<br>        debuggable <span class="hljs-literal">false</span><br>        minifyEnabled <span class="hljs-literal">true</span><br>        shrinkResources <span class="hljs-literal">true</span><br>       // proguardFile getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>修改signingConfigs</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">signingConfigs &#123;<br>    release &#123;<br>        keyAlias keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;keyAlias&#x27;</span>]</span><br>        keyPassword keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;keyPassword&#x27;</span>]</span><br>        storeFile keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;storeFile&#x27;</span>]</span> ? file(keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;storeFile&#x27;</span>]</span>) : null<br>        storePassword keystoreProperties[<span class="hljs-string">&#x27;storePassword&#x27;</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-可选-设置编译架构"><a href="#4-可选-设置编译架构" class="headerlink" title="4. [可选] 设置编译架构"></a>4. [可选] 设置编译架构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">buildTypes</span> &#123;<br>    <span class="hljs-section">release</span> &#123;<br>        <span class="hljs-attribute">signingConfig</span> signingConfigs.release<br>        ndk &#123;<br>            <span class="hljs-attribute">abiFilters</span> <span class="hljs-string">&#x27;armeabi-v7a&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-编译"><a href="#5-编译" class="headerlink" title="5. 编译"></a>5. 编译</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flutter build apk</span> <br></code></pre></td></tr></table></figure><h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><h3 id="找不到-pro文件"><a href="#找不到-pro文件" class="headerlink" title="找不到.pro文件"></a>找不到.pro文件</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Execution failed <span class="hljs-keyword">for</span> task <span class="hljs-string">&#x27;:app:minifyReleaseWithProguard&#x27;</span>.             <br>&gt; java.io.IOException: Please correct <span class="hljs-keyword">the</span> above warnings <span class="hljs-keyword">first</span>. <br></code></pre></td></tr></table></figure><p>将修改修改buildTypes里的注释打开，并在flutter-project/android/app/创建proguard-rules.pro</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 代码混淆压缩比，在0~7之间，默认为5，一般不做修改</span><br><br>-optimizationpasses <span class="hljs-number">5</span><br><br><span class="hljs-meta"># 去除编译时警告</span><br><br>-ignorewarnings<br><br><span class="hljs-meta">#不压缩输入的类文件</span><br><br>-dontshrink<br><br><span class="hljs-meta">#不优化输入的类文件</span><br><br>-dontoptimize<br><br><br><span class="hljs-meta"># 混合时不使用大小写混合，混合后的类名为小写</span><br><br>-dontusemixedcaseclassnames<br><br><span class="hljs-meta"># 指定不去忽略非公共库的类</span><br><br>-dontskipnonpubliclibraryclasses<br><br><span class="hljs-meta"># 这句话能够使我们的项目混淆后产生映射文件</span><br><br><span class="hljs-meta"># 包含有类名-&gt;混淆后类名的映射关系</span><br><br>-verbose<br><br><span class="hljs-meta"># 指定不去忽略非公共库的类成员</span><br><br>-dontskipnonpubliclibraryclassmembers<br><br><span class="hljs-meta"># 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。</span><br><br>-dontpreverify<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker命令</title>
    <link href="/2021/08/22/docker%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/22/docker%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-源设置"><a href="#1-源设置" class="headerlink" title="1. 源设置"></a>1. 源设置</h2><p>/etc/docker/daemon.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><br><span class="hljs-attr">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://alzgoonw.mirror.aliyuncs.com&quot;</span>]<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-镜像仓库"><a href="#2-镜像仓库" class="headerlink" title="2. 镜像仓库"></a>2. 镜像仓库</h2><ol><li><p>docker login [OPTIONS] [SERVER]</p><p>登录镜像仓库</p><p>-u:用户名</p><p>-p:密码</p><p>example：    </p></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docler <span class="hljs-keyword">login</span> -u username -p <span class="hljs-keyword">password</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>docker logout</p><p>登出镜像仓库</p></li><li><p>docker search [OPTIONS] images</p><p>–automated :只列出automated build类型的镜像</p><p>–no-trunc：显示完整的镜像描述</p><p>-s：列出收藏数不小于指定值的镜像</p><p>example：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> search -s <span class="hljs-number">20</span> unbuntu  //列出收藏数不小于<span class="hljs-number">20</span>的ubuntu镜像<br></code></pre></td></tr></table></figure></li><li><p>docker pull [OPTIONS] name[:TAG@DIGEST]</p><p>-a：拉起所有tagged镜像</p><p>–disable-content-trust：忽略镜像校验，默认开启</p><p>example：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker pull unbuntu  <span class="hljs-regexp">//</span>拉去ubuntu最新版镜像<br></code></pre></td></tr></table></figure></li><li><p>docker push [OPTIONS] NAME[:TAG]</p><p>将本地镜像上传到镜像仓库，首先要登录到镜像仓库，还要登录到Docker Hub创建对应名称的仓库，然后用tag命令给镜像打标签，只有打完标签后才能上传。</p></li><li><p>docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/] [USERNAME/] NAME[:TAG]</p><p>标记本地镜像，归入某一仓库。</p><p>完整版push：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag ubuntu:latest eara<span class="hljs-number">0</span>/ubuntu:v<span class="hljs-number">1</span><br><span class="hljs-attribute">docker</span> Hub创建对应仓库<br><span class="hljs-attribute">docker</span> push area<span class="hljs-number">0</span>/ubuntu:v<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h2><ol><li><p>docker run</p><p>创建一个新的容器并运行</p><p>常用指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sell">-i选项表示使用交互模式，始终保持输入流开放<br>-t选项表示分配一个伪终端，一般两个参数结合时使用-it，即可在容器中利用打开的伪终端进行交互操作<br>-d选项: 后台运行容器，并返回容器ID--name选项可以指定docker run命令启动的容器名字，若无此选项，Docker将为容器随机分配一个名字<br>-c选项：用于给运行在容器中的所有进程分配CPU的shares值，这是一个相对权重，实际的处理速度还与宿主机的CPU相       关<br>-m选项：用于限制为容器中所有进程分配的内存总量，以B、K、M、G为单位-v选项：用于挂载一个volume，可以用多个<br>-v参数同时挂载多个volume。volume的格式为[host-dir]:[container-dir]:[rw|ro]<br>-p选项：用于将容器内部端口映射给宿主机的端口，其常见格式为：主机(宿主)端口:容器内部端口<br>-P选项：随机端口映射，容器内部端口随机映射到宿主机的端口<br></code></pre></td></tr></table></figure><p>example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it ubuntu /bin/bash    //启动并返回终端<br>docker run -itd --name ubuntu-test ubuntu /bin/bash  //后台启动并返回终端<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>docker start</p><p>启动一个或多个已经停止的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start b750bbbcfd88 <br></code></pre></td></tr></table></figure></li><li><p>docker stop</p><p>停止一个运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop b750bbbcfd88<br></code></pre></td></tr></table></figure></li><li><p>docker restart</p><p>重启容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart b<span class="hljs-number">750</span>bbbcfd<span class="hljs-number">88</span><br></code></pre></td></tr></table></figure></li><li><p>docker rm</p><p>删除容器</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">f <span class="hljs-symbol">:</span>通过SIGKILL信号强制删除一个运行中的容器</span><br><span class="ruby"></span>-<span class="ruby">l <span class="hljs-symbol">:</span>移除容器间的网络连接，而非容器本身</span><br><span class="ruby"></span>-<span class="ruby">v <span class="hljs-symbol">:-v</span> 删除与容器关联的卷</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rm -f b<span class="hljs-number">750</span>bbbcfd<span class="hljs-number">88</span><br></code></pre></td></tr></table></figure></li><li><p>docker kill</p><p>杀掉运行中的容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> kill -s kill b<span class="hljs-number">750</span>bbbcfd<span class="hljs-number">88</span><br></code></pre></td></tr></table></figure><p>PS.常见rm和kill组合命令</p><p>杀掉所有正在运行的容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker kill <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure><p>删除所有正在运行的容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>docker exec和docker attach</p><p>在运行中的容器执行命令</p><p>attach：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> attach <span class="hljs-number">1</span>e<span class="hljs-number">560</span>fca<span class="hljs-number">3906</span>   // 如果从这个容器退出，会导致容器的停止。<br></code></pre></td></tr></table></figure><p>exec:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-d :分离模式: 在后台运行</span><br><span class="hljs-deletion">-i :即使没有附加也保持STDIN 打开</span><br><span class="hljs-deletion">-t :分配一个伪终端</span><br></code></pre></td></tr></table></figure><p>example：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it <span class="hljs-number">243</span>c32535da7 <span class="hljs-regexp">/bin/</span>bash    <span class="hljs-regexp">//</span>返回shell<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-导出和导入"><a href="#4-导出和导入" class="headerlink" title="4. 导出和导入"></a>4. 导出和导入</h2><ul><li>export和import</li></ul><ol><li><p>docker export</p><p>导出镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> export <span class="hljs-number">1</span>e<span class="hljs-number">560</span>fca<span class="hljs-number">3906</span> &gt; ubuntu.tar<br></code></pre></td></tr></table></figure></li><li><p>docker import</p><p>导入镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat docker<span class="hljs-regexp">/ubuntu.tar | docker import - demo/u</span>buntu:v1<br>docker import http:<span class="hljs-regexp">//</span>demo.com     <span class="hljs-regexp">//</span>支持从url导入<br></code></pre></td></tr></table></figure></li><li><p>save和load</p><ol><li>docker save</li></ol><p>将指定镜像保存为tar文件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker <span class="hljs-built_in">save</span> -o nginx.tar nginx:<span class="hljs-built_in">last</span><br></code></pre></td></tr></table></figure><ol start="2"><li>docker load</li></ol><p>导入使用docker save命令导出的镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> nginx<span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="docker-save和docker-export的区别"><a href="#docker-save和docker-export的区别" class="headerlink" title="docker save和docker export的区别"></a>docker save和docker export的区别</h3><ol><li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li><li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li><li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li></ol><h2 id="5-端口"><a href="#5-端口" class="headerlink" title="5.端口"></a>5.端口</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-<span class="hljs-selector-tag">p</span> <span class="hljs-number">1234</span>-<span class="hljs-number">1236</span>:<span class="hljs-number">1222</span>-<span class="hljs-number">1224</span>     <span class="hljs-comment">//指定范围添加端口</span><br>docker run -d -<span class="hljs-selector-tag">p</span> <span class="hljs-number">5001</span>:<span class="hljs-number">5000</span> training/webapp python app<span class="hljs-selector-class">.py</span> <span class="hljs-comment">//容器5000端口映射到主机5001</span><br>docker port bf08b7f2cd89<span class="hljs-comment">//查看映射端口</span><br></code></pre></td></tr></table></figure><h2 id="6-镜像管理"><a href="#6-镜像管理" class="headerlink" title="6. 镜像管理"></a>6. 镜像管理</h2><ol><li><p>docker images</p><p>通过docker images命令可以列出主机上的镜像，默认只列出最顶层的镜像，可以使用-a选项显示出所有镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker images -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure></li><li><p>docker rmi</p><p>docker rmi命令用于删除镜像，删除镜像时，如果已有基于该镜像启动的容器存在，则无法直接删除，需要先用rm命令删除容器。这两个子命令都提供 -f 选项，可强制删除存在容器的镜像或启动中的容器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi kali:<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>docker commit</p><p>docker commit命令可以将一个容器固化为一个新的镜像。当需要制定特定的镜像时，会进行修改容器的配置，比如在容器中安装一些特定的工具等，通过commit命令可以将这些修改保存起来，使其不会因为容器的停止而丢失。</p><ul><li>-a:提交的镜像作者</li><li>-c :使用Dockerfile指令来创建镜像</li><li>-m :提交时的说明文字</li><li>-p :在commit时，将容器暂停</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> commit -a <span class="hljs-string">&quot;demo&quot;</span> <span class="hljs-number">66</span>d<span class="hljs-number">682605023</span> kali:<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="7-运维相关"><a href="#7-运维相关" class="headerlink" title="7. 运维相关"></a>7. 运维相关</h2><ol><li><p>docker ps</p><p>常用的选项有-a和-l，-a选项可以查看所有的容器，包括停止的容器；-l选项只查看最新创建的容器，包括不在运行的容器</p></li><li><p>docker rename</p><p>重命名容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rename <span class="hljs-number">12312391</span> newname<br></code></pre></td></tr></table></figure></li><li><p>docer stats</p><p>显示容器资源的使用情况统计信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> stats <span class="hljs-number">12312391</span><br></code></pre></td></tr></table></figure></li><li><p>docker top</p><p>查看运行的进程信息</p></li><li><p>docker cp</p><p>主机与容器之间数据拷贝</p><p>example：</p><ul><li><p>将本目录下的test.php文件复制到容器的’/var/www/html/‘目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp test.php <span class="hljs-number">5198</span>ec963e43:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span><br></code></pre></td></tr></table></figure></li><li><p>将容器内’/var/www/html/index.php’复制到本机/root目录下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp <span class="hljs-number">5198</span>ec963e43:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/i</span>ndex.php <span class="hljs-regexp">/root/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>docker diff</p><p>查看容器文件结构</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> diff <span class="hljs-number">5198</span>ec<span class="hljs-number">963</span>e<span class="hljs-number">43</span><br></code></pre></td></tr></table></figure></li><li><p>docker events</p><p>从服务器获取实时时间</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f:根据条件过滤事件</span><br><span class="hljs-deletion">--since:从指定的时间戳后显示所有事件</span><br><span class="hljs-deletion">--until:流水时间显示到指定的时间为止</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> events --since=<span class="hljs-string">&quot;&quot;</span><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">21</span><span class="hljs-string">&quot; </span><br></code></pre></td></tr></table></figure></li><li><p>docker history</p><p>查看指定镜像的创建历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> TAG<br></code></pre></td></tr></table></figure></li><li><p>docker inspect</p><p>来查看 Docker 的底层信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 243c32535da7<br></code></pre></td></tr></table></figure></li><li><p>docker logs</p><p>查看容器打印日志</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> logs -f bf<span class="hljs-number">08</span>b<span class="hljs-number">7</span>f<span class="hljs-number">2</span>cd<span class="hljs-number">89</span>  //查看日志<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-文件映射"><a href="#8-文件映射" class="headerlink" title="8. 文件映射"></a>8. 文件映射</h2><ol><li>主机卷的映射</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker run -it -v <span class="hljs-regexp">/root/</span>software:<span class="hljs-regexp">/software --privileged=true  docker.io/</span>centos <span class="hljs-regexp">/bin/</span>bash<br><br>-v 挂载目录<span class="hljs-regexp">/root/</span>software 本地目录 /software容器目录，在创建前容器是没有software目录的容器会自己创建<br>--privileged=<span class="hljs-keyword">true</span> 关闭安全权限，否则你容器操作文件夹没有权限<br></code></pre></td></tr></table></figure><ol start="2"><li><p>通过docker创建卷</p><p>此种方式不必考虑权限问题，docker会为我们处理好权限。 </p><ul><li>创建 docker volume create –name v1</li><li>查看 docker inspect v1</li><li>删除数据卷 docker volume rm v1</li></ul><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -v v1:/usr/local/nginx --name nginx  //v1为创建的卷<br></code></pre></td></tr></table></figure></li><li><p>使用共享存储的映射</p></li></ol><p>将一台主机做为nfs主机， 创建相应的文件夹，并将其共享给docker的两台主机，两台docker主机将分享的文件夹映射到容器中，使得对应的容器可以共享到nfs主机的内容。可以将http等服务器的相应的页面文件夹使用这种形式，从而实现多个容器跑一个业务</p><p>nfs主机配置【192.168.6.77】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# yum -y install nfs-utils<br>[root@nfs ~]# vim /etc/exports<br>/public  *(rw)<br>[root@nfs ~]# systemctl restart nfs-server<br>Failed to restart nfs-serve.service: Unit not found<br>[root@nfs ~]# mkdir /public<br>[root@nfs ~]# cd /public/<br>[root@nfs public]# touch nfs.txt<br>[root@nfs public]# ls<br>nfs.txt<br><br>docker1主机配置<br>[root@docker1 ~]# vim /etc/fstab <br>192.168.6.77:/public /mnt/nfs nfs defaults,_netdev 0 0<br>[root@docker1 ~]# mkdir  /mnt/nfs <br>[root@docker1 ~]# systemctl restart nfs-server<br>[root@docker1 ~]# mount -a<br>[root@docker1 ~]# df -h<br>192.168.6.77:/public   17G  3.2G   14G   19% /mnt/nfs<br>[root@docker1 ~]# docker run -it -v /mnt/nfs/:/zhuhaiyan 192.168.6.153:5000/myos<br>[root@c7c376e3755a /]# cd /zhuhaiyan <br>[root@c7c376e3755a zhuhaiyan]# ls<br>nfs.txt<br><br>docker2主机配置<br>[root@docker2 ~]# vim /etc/fstab <br>192.168.6.77:/public /mnt/nfs nfs defaults,_netdev 0 0<br>[root@docker2 ~]# mkdir  /mnt/nfs <br>[root@docker2 ~]# systemctl restart nfs-server<br>[root@docker2 ~]# mount -a<br>[root@docker2 ~]# df -h<br>192.168.6.77:/public   17G  3.2G   14G   19% /mnt/nfs<br>[root@docker2 ~]# docker run -it -v /mnt/nfs/:/zhuhaiyan 192.168.6.153:5000/myos<br>[root@cdd805771d07 /]# cd /zhuhaiyan/<br>[root@cdd805771d07 zhuhaiyan]# ls<br>nfs.txt<br></code></pre></td></tr></table></figure><h2 id="9-网络设置"><a href="#9-网络设置" class="headerlink" title="9. 网络设置"></a>9. 网络设置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker network create -d bridge test  <span class="hljs-regexp">//</span>新建网络<br><br>-d：参数指定 Docker 网络类型，有 bridge、overlay。<br><br>docker network ls。 <span class="hljs-regexp">//</span>查看创建的网络<br><br>docker run -itd --name test1 --network test ubuntu <span class="hljs-regexp">/bin/</span>bash   <span class="hljs-regexp">//</span>--network指定使用的网络<br><br></code></pre></td></tr></table></figure><p>配置 DNS</p><p>可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dns&quot;</span> : [<br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span>,<br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p><p>配置完，需要重启 docker 才能生效。</p><p>启动时设置DNS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --rm host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu<br><br>-h HOSTNAME或者--hostname=HOSTNAME:设定容器的主机名，它会被写到容器内的 /etc/hostname 和      /etc/hosts。<br>--dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。<br>--dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。<br></code></pre></td></tr></table></figure><h2 id="10-Dockerfile"><a href="#10-Dockerfile" class="headerlink" title="10 .Dockerfile"></a>10 .Dockerfile</h2><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><ol><li>案例：</li></ol><p>创建Dockerfile文件</p><p><strong>vi Dockerfile</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM docker.io/kalilinux/kali-linux-docker<br>RUN echo &#x27;test&#x27; &gt; /root/test<br></code></pre></td></tr></table></figure><p>创建镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker build -t kali:test .   // kali:test（镜像名称:镜像标签）,最后的 . 代表本次执行的上下文路径<br></code></pre></td></tr></table></figure><ol start="2"><li><p>FROM 和 RUN 指令的作用</p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p></li></ol><p>shell 格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>, <span class="hljs-string">&quot;参数1&quot;</span>, <span class="hljs-string">&quot;参数2&quot;</span>]</span><br><span class="hljs-comment"># 例如：</span><br><span class="hljs-comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="bash"> yum install wget</span><br><span class="hljs-keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="bash"> tar -xvf redis.tar.gz</span><br><br>以上执行会创建 <span class="hljs-number">3</span> 层镜像。可简化为以下格式：<br><br><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="bash"> yum install wget \</span><br><span class="bash">  &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="bash">  &amp;&amp; tar -xvf redis.tar.gz</span><br><br>如上，以 &amp;&amp; 符号连接命令，这样执行后，只会创建 <span class="hljs-number">1</span> 层镜像。<br></code></pre></td></tr></table></figure><h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>上面中，有提到指令最后一个 <strong>.</strong> 是上下文路径，那么什么是上下文路径呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t kali:test .<br></code></pre></td></tr></table></figure><p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p><p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p><p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p><h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf">COPY [--chown=<span class="hljs-attribute">&lt;user&gt;</span>:<span class="hljs-attribute">&lt;group&gt;</span>] <span class="hljs-attribute">&lt;源路径1&gt;</span>...  <span class="hljs-attribute">&lt;目标路径&gt;</span><br>COPY [--chown=<span class="hljs-attribute">&lt;user&gt;</span>:<span class="hljs-attribute">&lt;group&gt;</span>] [&quot;<span class="hljs-attribute">&lt;源路径1&gt;</span>&quot;,...  &quot;<span class="hljs-attribute">&lt;目标路径&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><p>**[–chown=:]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span><br><span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><pre><code>    因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，**所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。**</code></pre><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ENTRYPOINT</span>&gt;</span> &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CMD</span>&gt;</span>&quot;<br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="bash">  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ docker run  nginx:test -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <code> &quot;&quot;</code> 有什么好处么？让我们来看几个场景。</p><p>场景一：让镜像变成像命令一样使用</p><p>  假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM ubuntu:<span class="hljs-number">16.04</span><br>RUN apt-get update \<br>&amp;&amp; apt-get install -y curl \<br>&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*<br>CMD [ <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://ip.cn&quot;</span> ]<br></code></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> myip<br>当前 IP：61.148.226.66 来自：北京市 联通<br></code></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl ，那么如果我们希望显示 HTTP头信息，就需要加上 -i 参数。那么我们可以直接加 <code>-i 参数</code>给 <code>docker run myip</code> 么？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ docker run myip <span class="hljs-operator">-</span>i<br>docker: <span class="hljs-type">Error</span> response from daemon: invalid header field value <span class="hljs-string">&quot;oci runtime error: con</span><br><span class="hljs-string">tainer_linux.go:247: starting container process caused <span class="hljs-subst">\&quot;</span>exec: <span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>-i<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>: executable</span><br><span class="hljs-string">file not found in $PATH<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span>.<br></code></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错， <code>executable file not found</code> 。之前我们说过，跟在镜像名后面的是 command ，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD ，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 -i 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ docker run myip curl -s http:<span class="hljs-comment">//ip.cn -i</span><br></code></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM ubuntu:<span class="hljs-number">16.04</span><br>RUN apt-get update \<br>&amp;&amp; apt-get install -y curl \<br>&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*<br>ENTRYPOINT [ <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://ip.cn&quot;</span> ]<br></code></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 docker run myip -i ：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ docker run myip<br>当前 IP：<span class="hljs-number">61.148</span><span class="hljs-number">.226</span><span class="hljs-number">.66</span> 来自：北京市 联通<br>$ docker run myip -i<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-keyword">Server</span>: nginx/<span class="hljs-number">1.8</span><span class="hljs-number">.0</span><br><span class="hljs-type">Date</span>: Tue, <span class="hljs-number">22</span> Nov <span class="hljs-number">2016</span> <span class="hljs-number">05</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40</span> GMT<br>Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; charset=UTF<span class="hljs-number">-8</span><br>Vary: Accept-<span class="hljs-keyword">Encoding</span><br>X-Powered-<span class="hljs-keyword">By</span>: PHP/<span class="hljs-number">5.6</span><span class="hljs-number">.24</span><span class="hljs-number">-1</span>~dotdeb+<span class="hljs-number">7.1</span><br>X-<span class="hljs-keyword">Cache</span>: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span><br>X-<span class="hljs-keyword">Cache</span>-Lookup: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span><br>X-<span class="hljs-keyword">Cache</span>: MISS from proxy<span class="hljs-number">-2</span>_6<br>Transfer-<span class="hljs-keyword">Encoding</span>: chunked<br>Via: <span class="hljs-number">1.1</span> <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>, <span class="hljs-number">1.1</span> proxy<span class="hljs-number">-2</span>_6:<span class="hljs-number">8006</span><br><span class="hljs-keyword">Connection</span>: keep-alive<br><br>当前 IP：<span class="hljs-number">61.148</span><span class="hljs-number">.226</span><span class="hljs-number">.66</span> 来自：北京市 联通<br></code></pre></td></tr></table></figure><p>  可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后， CMD 的内容将会作为参数传给 ENTRYPOINT ，而这里 -i 就是新的 CMD ，因此会作为参数传给 curl ，从而达到了我们预期的效果。</p><p>场景二：应用运行前的准备工作</p><p>  启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>  此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p><p>  这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span><br><br>...<br><br><span class="hljs-keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><br>...<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6379</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [ <span class="hljs-string">&quot;redis-server&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>  可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 dockerentrypoint.sh 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>...<br><span class="hljs-comment"># allow the container to be started with `--user`</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&#x27;redis-server&#x27;</span> -a <span class="hljs-string">&quot;<span class="hljs-subst">$(id -u)</span>&quot;</span> = <span class="hljs-string">&#x27;0&#x27;</span> ]; <span class="hljs-keyword">then</span><br><br>    chown -R redis .<br>    <span class="hljs-built_in">exec</span> su-exec redis <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><p>  该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> -it redis id<br><span class="hljs-attribute">uid</span>=0(root) <span class="hljs-attribute">gid</span>=0(root) <span class="hljs-attribute">groups</span>=0(root)<br></code></pre></td></tr></table></figure><p>  而使用 <code>service nginx start</code> 命令，则是希望 <code>systemd</code> 来以后台守护进程形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 CMD [ “sh”, “-c”, “service nginxstart”] ，<strong>因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结束了， sh 作为主进程退出了，自然就会令容器退出。</strong></p><p>  正确的做法是<strong>直接执行 nginx 可执行文件</strong>，并且要求以前台形式运行。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p><strong>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</strong></p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">WORKDIR <span class="hljs-attribute">&lt;工作目录路径&gt;</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">USER <span class="hljs-attribute">&lt;用户名&gt;</span>[:<span class="hljs-attribute">&lt;用户组&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>  容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">VOLUME</span> /<span class="hljs-class"><span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>  这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">docker</span> run -d -v mydata:/<span class="hljs-class"><span class="hljs-keyword">data</span> xxxx</span><br></code></pre></td></tr></table></figure><p>  在这行命令中，就使用了 mydata 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p><p> </p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ARG <span class="hljs-attribute">&lt;参数名&gt;</span>[=<span class="hljs-attribute">&lt;默认值&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos">HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><br>HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt; : 这边 <span class="hljs-built_in">CMD</span> 后面跟随的命令使用，可以参考 <span class="hljs-built_in">CMD</span> 的用法。<br></code></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ONBUILD <span class="hljs-attribute">&lt;其它指令&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SO函数运行顺序</title>
    <link href="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="加载运行流程"><a href="#加载运行流程" class="headerlink" title="加载运行流程"></a>加载运行流程</h2> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class=""><h3 id="1-init"><a href="#1-init" class="headerlink" title="1. _init"></a>1. _init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">void</span> _init(<span class="hljs-keyword">void</span>) &#123; &#125; <br></code></pre></td></tr></table></figure><p>编译生成后会在<code>.init</code>段</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/readelf.png" class=""><p>IDA反编译对应<code>_init_proc</code>方法</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/init_proc.png" class="" width="600" height="1100"><h3 id="2-constructor"><a href="#2-constructor" class="headerlink" title="2. constructor"></a>2. constructor</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs delphi">__attribute__( (<span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(1)</span>) ) <span class="hljs-title">void</span> <span class="hljs-title">aaaa</span><span class="hljs-params">( void )</span></span><br><span class="hljs-function"><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">LOGI( &quot;constructor constructor 1 called&quot; );</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">__<span class="hljs-title">attribute__</span><span class="hljs-params">( (<span class="hljs-keyword">constructor</span>(2)</span>) ) <span class="hljs-title">void</span> <span class="hljs-title">aaaa</span><span class="hljs-params">( void )</span></span><br><span class="hljs-function"><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">LOGI( &quot;constructor constructor 2 called&quot; );</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>根据设置的优先级依次调用,编译生成后会在.init_array段</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/init_array.png" class=""><p>IDA分析 ctrl+s定位到.init_array段</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/ida_init_array.png" class=""><p>点击进入方法实现</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/%E8%BF%9B%E5%85%A5%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png" class="" width="600" height="400"><h3 id="3-JNI-OnLoad"><a href="#3-JNI-OnLoad" class="headerlink" title="3. JNI_OnLoad"></a>3. JNI_OnLoad</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-keyword">void</span>* reserved)</span></span>&#123;<br>    <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;jni onload called&quot;</span>);<br>   <span class="hljs-comment">//TODO</span><br>    <span class="hljs-keyword">return</span> JNI_VERSION_1_4;  <span class="hljs-comment">//这里很重要，必须返回版本，否则加载会失败。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="源码分析（Android10）"><a href="#源码分析（Android10）" class="headerlink" title="源码分析（Android10）"></a>源码分析（Android10）</h2><p>Android加载动态库有三种方式</p><ul><li><p>System.loadLibrary  </p><p>java中方法,不需要指定so路径，系统会自动补全</p></li><li><p>System.load</p><p>java中方法,需要指定so路径</p></li><li><p>dlopen</p><p>bionic库中方法，需要指定so路径</p></li></ul><h3 id="java-load-so"><a href="#java-load-so" class="headerlink" title="java load so"></a>java load so</h3><p> System.loadLibrary与System.load的实现在<code>/libcore/ojluni/src/main/java/java/lang/System.java</code>中</p><p>最终都会调用<code>/libcore/ojluni/src/main/java/java/lang/Runtime.java</code>下的native方法<code>nativeLoad</code></p><p>因为<code>System.load </code>的入参不是so文件的绝对路径，所以在系统需要从<code>java.library.path</code>属性中获取系统库的地址，遍历该so文件在哪个路径下，最终返回绝对路径，一般的<code>java.library.path</code>为</p><ul><li><p>/vendor/lib</p></li><li><p>/system/lib</p></li><li><p>/data/app-lib/com.xxxxx-1</p></li></ul><p>nativeLoad的JNI实现在<code>/libcore/ojluni/src/main/native/Runtime.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Runtime_nativeLoad</span><span class="hljs-params">(JNIEnv* env, jclass ignored, jstring javaFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                   jobject javaLoader, jclass caller)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> JVM_NativeLoad(env, javaFilename, javaLoader, caller);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>/art/openjdkjvm/OpenjdkJvm.cc</code>下得<code>JVM_NativeLoad</code>方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jstring <span class="hljs-title">JVM_NativeLoad</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 jstring javaFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 jobject javaLoader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 jclass caller)</span> </span>&#123;<br>  <br>    art::JavaVMExt* vm = art::Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetJavaVM</span>();<br>    <span class="hljs-keyword">bool</span> success = vm-&gt;<span class="hljs-built_in">LoadNativeLibrary</span>(env,<br>                                         filename.<span class="hljs-built_in">c_str</span>(),<br>                                         javaLoader,<br>                                         caller,<br>                                         &amp;error_msg);<br>  <span class="hljs-comment">// Don&#x27;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span><br>  env-&gt;<span class="hljs-built_in">ExceptionClear</span>();<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(error_msg.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>调用当前文件中的<code>LoadNativeLibrary</code>方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">JavaVMExt::LoadNativeLibrary</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">const</span> std::string&amp; path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  jobject class_loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  jclass caller_class,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  std::string* error_msg)</span> </span>&#123;<br>     ......<br><br>  <span class="hljs-keyword">void</span>* handle = android::<span class="hljs-built_in">OpenNativeLibrary</span>(<br>      env,<br>      runtime_-&gt;<span class="hljs-built_in">GetTargetSdkVersion</span>(),<br>      path_str,<br>      class_loader,<br>      (caller_location.<span class="hljs-built_in">empty</span>() ? <span class="hljs-literal">nullptr</span> : caller_location.<span class="hljs-built_in">c_str</span>()),<br>      library_path.<span class="hljs-built_in">get</span>(),<br>      &amp;needs_native_bridge,<br>      &amp;nativeloader_error_msg);<br><br>  <br>  <span class="hljs-keyword">bool</span> was_successful = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">void</span>* sym = library-&gt;<span class="hljs-built_in">FindSymbol</span>(<span class="hljs-string">&quot;JNI_OnLoad&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (sym == <span class="hljs-literal">nullptr</span>) &#123;<br>    was_successful = <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">VLOG</span>(jni) &lt;&lt; <span class="hljs-string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;]&quot;</span>;<br>    <span class="hljs-keyword">using</span> JNI_OnLoadFn = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)(JavaVM*, <span class="hljs-keyword">void</span>*);<br>    JNI_OnLoadFn jni_on_load = <span class="hljs-keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);<br>    <span class="hljs-keyword">int</span> version = (*jni_on_load)(<span class="hljs-keyword">this</span>, <span class="hljs-literal">nullptr</span>);<br><br>.........<br><br>    <span class="hljs-keyword">if</span> (version == JNI_ERR) &#123;<br>      <span class="hljs-built_in">StringAppendF</span>(error_msg, <span class="hljs-string">&quot;JNI_ERR returned from JNI_OnLoad in \&quot;%s\&quot;&quot;</span>, path.<span class="hljs-built_in">c_str</span>());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (JavaVMExt::<span class="hljs-built_in">IsBadJniVersion</span>(version)) &#123;<br>      <span class="hljs-built_in">StringAppendF</span>(error_msg, <span class="hljs-string">&quot;Bad JNI version returned from JNI_OnLoad in \&quot;%s\&quot;: %d&quot;</span>,<br>                    path.<span class="hljs-built_in">c_str</span>(), version);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      was_successful = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  library-&gt;<span class="hljs-built_in">SetResult</span>(was_successful);<br>  <span class="hljs-keyword">return</span> was_successful;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用了<code>android::OpenNativeLibrary</code>方法加载SO文件，加载成功后会查找符号表是否有<code>JNI_OnLoad</code>,如果有则根据<code>JNI_OnLoad</code>的地址进行调用，然后判断返回值<code>version</code>是否正确,这也是为什么<code>JNI_OnLoad</code>要返回版本的原因。</p><p>所以可以通过<code>OpenNativeLibrary</code>方法对<code>JNI_OnLoad</code>进行HOOK（此时SO已加载但还未执行JNI_OnLoad方法）</p><p>上面的运行流程中<code>JNI_OnLoad</code>排在第三位，也就是说<code>_init</code>和<code>constructor</code>在<code>OpenNativeLibrary</code>方法中就以执行</p><p>继续分析<code>OpenNativeLibrary</code>方法，在<code>/system/core/libnativeloader/native_loader.cpp</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">OpenNativeLibrary</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-keyword">int32_t</span> target_sdk_version, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        jobject class_loader, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* caller_location, jstring library_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">bool</span>* needs_native_bridge, <span class="hljs-keyword">char</span>** error_msg)</span> </span>&#123;<br> <br>  <br>  <span class="hljs-keyword">if</span> (class_loader == <span class="hljs-literal">nullptr</span>) &#123;<br>    *needs_native_bridge = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (caller_location != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">android_namespace_t</span>* boot_namespace = <span class="hljs-built_in">FindExportedNamespace</span>(caller_location);<br>      <span class="hljs-keyword">if</span> (boot_namespace != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">const</span> android_dlextinfo dlextinfo = &#123;<br>            .flags = ANDROID_DLEXT_USE_NAMESPACE,<br>            .library_namespace = boot_namespace,<br>        &#125;;<br>        <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">android_dlopen_ext</span>(path, RTLD_NOW, &amp;dlextinfo);<br>        <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>          *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">dlerror</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> handle;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">dlopen</span>(path, RTLD_NOW);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">dlerror</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125;<br> <br> ........<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">OpenNativeLibraryInNamespace</span>(ns, path, needs_native_bridge, error_msg);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">OpenNativeLibraryInNamespace</span><span class="hljs-params">(NativeLoaderNamespace* ns, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-keyword">bool</span>* needs_native_bridge, <span class="hljs-keyword">char</span>** error_msg)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (ns-&gt;<span class="hljs-built_in">is_android_namespace</span>()) &#123;<br>    android_dlextinfo extinfo;<br>    extinfo.flags = ANDROID_DLEXT_USE_NAMESPACE;<br>    extinfo.library_namespace = ns-&gt;<span class="hljs-built_in">get_android_ns</span>();<br><br>    <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">android_dlopen_ext</span>(path, RTLD_NOW, &amp;extinfo);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">dlerror</span>());<br>    &#125;<br>    *needs_native_bridge = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">NativeBridgeLoadLibraryExt</span>(path, RTLD_NOW, ns-&gt;<span class="hljs-built_in">get_native_bridge_ns</span>());<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">NativeBridgeGetError</span>());<br>    &#125;<br>    *needs_native_bridge = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>/bionic/libdl/libdl.cpp</code>中的<code>android_dlopen_ext</code>方法加载SO,该方法最终会调用linker中的<code>do_dlopen</code>,linker的实现在<code>/bionic/linker/linker.cpp</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">do_dlopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">const</span> android_dlextinfo* extinfo,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* caller_addr)</span> </span>&#123;<br><br>  .......<br>    <br>  soinfo* si = <span class="hljs-built_in">find_library</span>(ns, translated_name, flags, extinfo, caller);<br>  <span class="hljs-keyword">if</span> (si != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">void</span>* handle = si-&gt;<span class="hljs-built_in">to_handle</span>();<br>    si-&gt;<span class="hljs-built_in">call_constructors</span>();<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>find_library方法才是真正的加载SO，执行定位动态节、解析动态节、加载动态节 、重定位等，像SO抹头、自定义Linker等加固方式都是在这里做的文章。在低版本中加载SO文件后返回的是soinfo结构体，高版本返回的是to_handle后的指针。</p><p><code>do_dlopen</code>方法调用了<code>call_constructors</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">soinfo::call_constructors</span><span class="hljs-params">()</span> </span>&#123;<br> <br>......<br>    <br>  <span class="hljs-built_in">call_function</span>(<span class="hljs-string">&quot;DT_INIT&quot;</span>, init_func_, <span class="hljs-built_in">get_realpath</span>());<br>  <span class="hljs-built_in">call_array</span>(<span class="hljs-string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="hljs-literal">false</span>, <span class="hljs-built_in">get_realpath</span>());<br><br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>调用call_function和call_array并根据<code>init_func_</code>,<code>init_array_</code>符号地址执行对应的方法</p><p>获取符号表的实现<code>/bionic/linker/linker.cpp</code>中的<code>soinfo::prelink_image</code>方法，在<code>find_library</code>方法执行完成后就已获取到符号信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">soinfo::prelink_image</span><span class="hljs-params">()</span> </span>&#123;<br><br>........<br><br><span class="hljs-keyword">case</span> DT_INIT:<br>  init_func_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">linker_ctor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DT_FINI:<br>  fini_func_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">linker_dtor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DT_INIT_ARRAY:<br>  init_array_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DT_INIT_ARRAYSZ:<br>  init_array_count_ = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in">ElfW</span>(Addr));<br>  <span class="hljs-keyword">break</span>;<br>........<br>&#125;<br></code></pre></td></tr></table></figure><p>call_function实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">call_function</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> char* function_name __unused,</span></span><br><span class="hljs-params"><span class="hljs-function">                          linker_ctor_function_t <span class="hljs-keyword">function</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> char* realpath __unused</span>)</span> &#123;<br> ......<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g_argc, g_argv, g_envp</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>call_array实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call_array</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* array_name __unused,F* functions, <span class="hljs-keyword">size_t</span> count,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">bool</span> reverse,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* realpath)</span> </span>&#123; <br>  <br>  <span class="hljs-keyword">int</span> begin = reverse ? (count - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> end = reverse ? <span class="hljs-number">-1</span> : count;<br>  <span class="hljs-keyword">int</span> step = reverse ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i != end; i += step) &#123;<br>    <span class="hljs-built_in">call_function</span>(<span class="hljs-string">&quot;function&quot;</span>, functions[i], realpath);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>call_array最终遍历所有<code>DT_INIT_ARRAY</code>的地址后调用<code>call_function</code>方法执行。</p><p>所以对于<code>_init</code>和<code>construcor</code>方法的HOOK时机，可以选择<code>call_function</code>方法(SO已完成加载,_init、construcor还未执行)</p><h3 id="Native-load-so"><a href="#Native-load-so" class="headerlink" title="Native load so"></a>Native load so</h3><p>native <code>dlopen</code>的实现在<code> /bionic/libdl/libdl.cpp</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__attribute__((__weak__))<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">dlopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* caller_addr = __builtin_return_address(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> __loader_dlopen(filename, flag, caller_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会调用<code>/bionic/linker/linker.cpp</code>中的<code>do_dlopen</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>java层loadso执行方法顺序 <code>_init--&gt;constructor--&gt;JNI_OnLoad</code></li><li>NDK开发dlopen方法loadso执行方法顺序 <code>_init--&gt;constructor</code></li><li>无论Java层还是NDK开发中的dlopen最终都会调用linker的<code>do_dlopen</code>方法</li><li>可以选择<code>OpenNativeLibrary</code>、<code>call_function</code>完成对<code>JNI_OnLoad</code>、<code>_init</code>、<code>constructor</code>方法的HOOK</li></ul>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDB调试APP</title>
    <link href="/2021/08/22/JDB%E8%B0%83%E8%AF%95APP/"/>
    <url>/2021/08/22/JDB%E8%B0%83%E8%AF%95APP/</url>
    
    <content type="html"><![CDATA[<h2 id="1-以调试模式运行APP"><a href="#1-以调试模式运行APP" class="headerlink" title="1. 以调试模式运行APP"></a>1. 以调试模式运行APP</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> start -D  <span class="hljs-keyword">com</span>.cola.jni/<span class="hljs-keyword">com</span>.cola.jni.MainActivity<br></code></pre></td></tr></table></figure><h2 id="2-转发端口到本地"><a href="#2-转发端口到本地" class="headerlink" title="2.转发端口到本地"></a>2.转发端口到本地</h2><p>使用<code>DDMS</code>转发端口</p> <img src="/2021/08/22/JDB%E8%B0%83%E8%AF%95APP/images/ddms.png" class=""><p>或者通过<code>adb</code>转发到本地</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">adb jdwp  <span class="hljs-comment">#获取可调试APP PID(判断目标APP是否可调试，将ro.debuggable设为1可调试所有APP)</span><br>adb forward tcp:<span class="hljs-number">8700</span> jdwp:$jdwp_pid<br></code></pre></td></tr></table></figure><h2 id="JDB附加"><a href="#JDB附加" class="headerlink" title="JDB附加"></a>JDB附加</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">jdb -connect com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jdi</span><span class="hljs-selector-class">.SocketAttach</span>:hostname=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>,port=<span class="hljs-number">8700</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>jdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOSP导入IDE</title>
    <link href="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/"/>
    <url>/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码导入-Android-Studio"><a href="#Java代码导入-Android-Studio" class="headerlink" title="Java代码导入 Android Studio"></a>Java代码导入 Android Studio</h2><h3 id="1-source-build-envsetup-sh"><a href="#1-source-build-envsetup-sh" class="headerlink" title="1.source build/envsetup.sh"></a>1.source build/envsetup.sh</h3><h3 id="2-编译生成-idegen-jar"><a href="#2-编译生成-idegen-jar" class="headerlink" title="2.编译生成 idegen.jar"></a>2.编译生成 idegen.jar</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mmm development<span class="hljs-regexp">/tools/i</span>degen/ <br></code></pre></td></tr></table></figure><p>运行完毕上面的命令之后，就在根目录生成了2个文件：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">android.ipr </span>和 <span class="hljs-keyword">android.iml</span><br></code></pre></td></tr></table></figure><h3 id="3-排除不必要的模块，提高加载速度"><a href="#3-排除不必要的模块，提高加载速度" class="headerlink" title="3.排除不必要的模块，提高加载速度"></a>3.排除不必要的模块，提高加载速度</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">打开<span class="hljs-keyword">android.iml, </span>找到excludeFolder属性,只添加framework<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/abi&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/art&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/bionic&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/bootable&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/build&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/cts&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/dalvik&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/developers&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/development&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/device&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/docs&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/external&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/hardware&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/libcore&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/libnativehelper&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/ndk&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/out&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/pdk&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/prebuilts&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/sdk&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/system&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/tools&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/kernel&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="4-使用Android-Studio直接android-ipr文件"><a href="#4-使用Android-Studio直接android-ipr文件" class="headerlink" title="4.使用Android Studio直接android.ipr文件"></a>4.使用Android Studio直接android.ipr文件</h3><h3 id="5-存在问题"><a href="#5-存在问题" class="headerlink" title="5.存在问题"></a>5.存在问题</h3><p>打开的Java代码，查看集成关系或者调用关系的时候，还是会跳转到.class文件中，而不是相应的Java类?</p><h4 id="5-1-删除多余的JDK和SDK"><a href="#5-1-删除多余的JDK和SDK" class="headerlink" title="5.1 删除多余的JDK和SDK"></a>5.1 删除多余的JDK和SDK</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E7%9A%84JDK%E5%92%8CSDK.png" class=""><h4 id="5-2添加JDK"><a href="#5-2添加JDK" class="headerlink" title="5.2添加JDK"></a>5.2添加JDK</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E6%B7%BB%E5%8A%A0sdk.png" class=""><h4 id="5-3删除JDK中Classpath和Sourcepath中的内容"><a href="#5-3删除JDK中Classpath和Sourcepath中的内容" class="headerlink" title="5.3删除JDK中Classpath和Sourcepath中的内容"></a>5.3删除JDK中Classpath和Sourcepath中的内容</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E5%88%A0%E9%99%A4Classpath.png" class=""><h4 id="5-4-删除SDK中Classpath和Sourcepath中的内容"><a href="#5-4-删除SDK中Classpath和Sourcepath中的内容" class="headerlink" title="5.4 删除SDK中Classpath和Sourcepath中的内容"></a>5.4 删除SDK中Classpath和Sourcepath中的内容</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E5%88%A0%E9%99%A4Sourcepath.png" class=""><h4 id="5-5-配置Modules"><a href="#5-5-配置Modules" class="headerlink" title="5.5 配置Modules"></a>5.5 配置Modules</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E9%85%8D%E7%BD%AEModules.png" class=""><h4 id="5-6把framework添加到Dependencies中"><a href="#5-6把framework添加到Dependencies中" class="headerlink" title="5.6把framework添加到Dependencies中"></a>5.6把framework添加到Dependencies中</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies1.png" class=""><ul><li></li></ul> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies2.png" class=""><ul><li></li></ul> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies3.png" class=""><ul><li></li></ul> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies4.png" class=""><h4 id="5-7-确定Project-SDK选择正确"><a href="#5-7-确定Project-SDK选择正确" class="headerlink" title="5.7 确定Project SDK选择正确"></a>5.7 确定Project SDK选择正确</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E7%A1%AE%E5%AE%9AProjectSDK.png" class=""><h2 id="Native代码导入CLion"><a href="#Native代码导入CLion" class="headerlink" title="Native代码导入CLion"></a>Native代码导入CLion</h2><h3 id="1-打开开关，编译时生成CMakeLists-txt"><a href="#1-打开开关，编译时生成CMakeLists-txt" class="headerlink" title="1.打开开关，编译时生成CMakeLists.txt"></a>1.打开开关，编译时生成CMakeLists.txt</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SOONG_GEN_CMAKEFILES</span>=1<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SOONG_GEN_CMAKEFILES_DEBUG</span>=1<br></code></pre></td></tr></table></figure><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">make</span> -j<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="3-生成CMakeLists-txt"><a href="#3-生成CMakeLists-txt" class="headerlink" title="3.生成CMakeLists.txt"></a>3.生成CMakeLists.txt</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">out<span class="hljs-regexp">/development/i</span>de<span class="hljs-regexp">/clion/</span>xxxx<br></code></pre></td></tr></table></figure><h3 id="4-创建CMakeLists-txt用于合并"><a href="#4-创建CMakeLists-txt用于合并" class="headerlink" title="4. 创建CMakeLists.txt用于合并"></a>4. 创建CMakeLists.txt用于合并</h3><p><code>在clion目录下创建CMakeLists.txt</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.6</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(AOSP-Native)</span></span><br><br><span class="hljs-comment">//用到了哪个模块再导入即可，要保证改目录下有CMakeLists.txt</span><br><span class="hljs-comment">// 添加子模块，导入了部分工程</span><br><span class="hljs-function"><span class="hljs-title">add_subdirectory</span><span class="hljs-params">(frameworks/native)</span></span><br>.......<br></code></pre></td></tr></table></figure><h3 id="5-CLion导入"><a href="#5-CLion导入" class="headerlink" title="5. CLion导入"></a>5. CLion导入</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 打开CLion<br><span class="hljs-bullet">2.</span> 选择「open xxxxxx」<br><span class="hljs-bullet">3.</span> 指定包含 CMakeLists.txt 的目录out/development/ide/clion<br><span class="hljs-bullet">4.</span> 选择「Open Existing Project」<br></code></pre></td></tr></table></figure><h3 id="6-更改工程根目录"><a href="#6-更改工程根目录" class="headerlink" title="6.更改工程根目录"></a>6.更改工程根目录</h3><p>设置root为aosp源码根目录</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">T<span class="hljs-function"><span class="hljs-title">ools</span> -&gt;</span> CM<span class="hljs-function"><span class="hljs-title">ake</span> -&gt;</span> Change Project Root<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://www.jianshu.com/p/<span class="hljs-number">2</span>ba<span class="hljs-number">5</span>d<span class="hljs-number">6</span>bd<span class="hljs-number">461</span>e<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>rom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android SO库与源码对应关系</title>
    <link href="/2021/08/22/Android-so%E5%BA%93%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/"/>
    <url>/2021/08/22/Android-so%E5%BA%93%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>libandroid.so     <code>frameworks/base/native/android</code></p></li><li><p>libandroid_runtime.so    <code>frameworks/base/core/jni</code></p></li><li><p>libandroidfw.so    <code>frameworks/base/libs/androidfw</code></p></li><li><p>libaudioutils.so    <code>system/media/audio_utils</code></p></li><li><p>libbinder.so    <code>frameworks/native/libs/binder</code></p></li><li><p>libbluedroid.so    <code>system/bluetooth/bluedroid</code></p></li><li><p>libc.so    <code>bionic/libc</code></p></li><li><p>libcamera_client.so    <code>frameworks/av/camera</code></p></li><li><p>libcorkscrew.so    <code>system/core/libcorkscrew</code></p></li><li><p>libcpustats.so    <code>frameworks/native/libs/cpustats</code></p></li><li><p>libcrypto.so    <code>external/openssl</code></p></li><li><p>libcutils.so    <code>system/core/libcutils</code></p></li><li><p>libdbus.so    <code>external/dbus/dbus</code></p></li><li><p>libdvm.so    <code>dalvik/vm</code></p></li><li><p>libart.so    <code>art/runtime</code></p></li><li><p>libemoji.so    <code>frameworks/opt/emoji</code></p></li><li><p>libETC1.so    <code>frameworks/native/opengl/libs</code></p></li><li><p>libgccdemangle    <code>external/gcc-demangle</code></p></li><li><p>libgui.so    <code>frameworks/native/libs/gui</code></p></li><li><p>libgabi++.so    <code>abi/cpp</code></p></li><li><p>libGLESv1_CM.so    <code>frameworks/native/opengl/libs</code></p></li><li><p>libharfbuzz.so    <code>external/harfbuzz</code></p></li><li><p>libhwui.so    <code>frameworks/base/libs/hwui</code></p></li><li><p>libhardware_legacy.so    <code>hardware/libhardware_legacy</code></p></li><li><p>libjpeg.so    <code>external/jpeg</code></p></li><li><p>libmedia.so    <code>frameworks/av/media/libmedia</code></p></li><li><p>libmedia_native.so    <code>frameworks/av/media/libmedia_native</code></p></li><li><p>libnetutils.so    <code>system/core/libnetutils</code></p></li><li><p>libstagefright_foundation.so    <code>frameworks/av/media/libstagefright/foundation</code></p></li><li><p>libsonivox.so    <code>external/sonivox</code></p></li><li><p>libspeexresampler    <code>external/speex</code></p></li><li><p>libstlport.so    <code>external/stlport</code></p></li><li><p>libssl.so    <code>external/openssl</code></p></li><li><p>libui.so    <code>frameworks/native/libs/ui</code></p></li><li><p>libutils.so    <code>frameworks/native/libs/utils</code></p></li><li><p>libusbhost.so    <code>system/core/libusbhost</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Magisk开启ro.debuggable调试</title>
    <link href="/2021/08/22/Magisk%E5%BC%80%E5%90%AFro-debuggable%E8%B0%83%E8%AF%95/"/>
    <url>/2021/08/22/Magisk%E5%BC%80%E5%90%AFro-debuggable%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">magisk resetprop ro.debuggable <span class="hljs-number">1</span><br><span class="hljs-comment">#查看ro.debuggable</span><br>getprop ro.debuggable<br><span class="hljs-comment">#重启</span><br>stop;start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>magisk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pixel XL AOSP源码编译</title>
    <link href="/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <url>/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>操作系统 ：虚拟机 ubuntu 16.04</li><li>内存 ：12G</li><li>硬盘 ：150G</li><li>CPU ：4核</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="1-源码分支获取"><a href="#1-源码分支获取" class="headerlink" title="1. 源码分支获取"></a>1. 源码分支获取</h3><p>根据手机型号下载对应的版本，通过以下网站获取pixel XL android 10版本的源码标记 android-10.0.0_r17</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds<br></code></pre></td></tr></table></figure> <img src="/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/images/%E6%BA%90%E7%A0%81%E5%88%86%E6%94%AF%E8%8E%B7%E5%8F%96.png" class=""><h3 id="2-下载android源码"><a href="#2-下载android源码" class="headerlink" title="2.下载android源码"></a>2.下载android源码</h3><p>repo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo apt-get install git-core<br>sudo apt-get install git-core curl<br>mkdir ~/<span class="hljs-built_in">bin</span>/<br>cd ~/<span class="hljs-built_in">bin</span><br><br>curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/<span class="hljs-built_in">bin</span>/repo<br>chmod a+x ~/<span class="hljs-built_in">bin</span>/repo<br>gedit ~/.bashrc<br></code></pre></td></tr></table></figure><p>在~/.bashrc里添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#国内镜像</span><br>export REPO_URL=<span class="hljs-string">&#x27;https://aosp.tuna.tsinghua.edu.cn/git-repo&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-同步代码"><a href="#3-同步代码" class="headerlink" title="3. 同步代码"></a>3. 同步代码</h3><h4 id="3-1-第一种方式"><a href="#3-1-第一种方式" class="headerlink" title="3.1 第一种方式"></a>3.1 第一种方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cd ~/work/sources/android-<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>_r17<br>repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>_r17<br>repo sync -c --no-tags --prune -f -j4  <span class="hljs-comment">#线程根据cpu核数决定 一般为cpu核数x2，此处采用4线程</span><br></code></pre></td></tr></table></figure><p>参数介绍:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs //参数说明">-c, --current-branch fetch only current branch from server.<br>这个选项指定只获取执行 repo init 时 -b 选项所指定的分支，不会获取远端服务器的分支信息。<br>例如服务器上新增了其他分支，使用 -c 选项同步后，在本地 git 仓库执行 git branch -r 命令看不到服务器新增的分支名。如果不加 -c 选项，那么同步的时候，会打印 [new branch] 这样的信息，使用 git branch -r 命令可查看到服务器新增的分支。<br><br>–no-tags don’t fetch tags.<br>该选项指定不获取服务器上的tag信息。<br><br>–prune delete refs that no longer exist on the remote.<br>如果远端服务器已经删除了某个分支，在 repo sync 时加上 --prune 选项，可以让本地仓库删除对这个分支的跟踪引用。<br><br>-j JOBS, --jobs=JOBS projects to fetch simultaneously (default 2).<br>指定启用多少个线程来同步。<br>例如上面的 -j 4 指定用4个线程来同步。如果没有提供该选项，默认是用2个线程。<br><br>-f：即使某个项目同步失败，也继续同步其他项目。<br><br>总的来说，在 repo sync -c --no-tags --prune -j 4 命令中，使用 -c 和 --no-tags 选项可以减少需要同步的内容，从而减少要占用的本地代码空间，也可以减少一些同步时间。<br>使用 -j 选项来指定启用多线程进行同步，可以加快执行速度，也就减少了同步时间。<br>使用 --prune 选项去掉已删除分支的跟踪引用，一般不会用到，这个选项可加可不加。<br></code></pre></td></tr></table></figure><h4 id="3-1-第二种方式-未尝试此方法不知道是否可行"><a href="#3-1-第二种方式-未尝试此方法不知道是否可行" class="headerlink" title="3.1 第二种方式(未尝试此方法不知道是否可行)"></a>3.1 第二种方式(未尝试此方法不知道是否可行)</h4><p>下载源码的初始化包（加速源码下载） 大约60G</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/aosp-monthly/</span>aosp-latest.tar<br></code></pre></td></tr></table></figure><p>解压缩,解压缩完成之后会多出来~/aosp目录<br>切进去</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> zxvf aosp-latest.tar<br></code></pre></td></tr></table></figure><p>cd  aosp </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>_r17<br>repo sync -c --no-tags --prune -f -j4  <span class="hljs-comment">#线程根据cpu核数决定 一般为cpu核数x2，此处采用4线程</span><br></code></pre></td></tr></table></figure><h3 id="4-驱动下载"><a href="#4-驱动下载" class="headerlink" title="4. 驱动下载"></a>4. 驱动下载</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>developers.google.com<span class="hljs-regexp">/android/</span>drivers<span class="hljs-comment">#sailfishqp1a.190711.020</span><br></code></pre></td></tr></table></figure><p>下载google_devices-sailfish-qp1a.191005.007.a3-a1615a0f.tgz</p><p>qcom-sailfish-qp1a.191005.007.a3-191228fe.tgz<br>两个压缩包，191005.007.a3为当时最新版本驱动</p> <img src="/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/images/%E9%A9%B1%E5%8A%A8%E4%B8%8B%E8%BD%BD.png" class=""><p>下载完成后解压会获得两个.sh脚本文件，运行两个脚本后会生成vendor文件夹，将vendor文件夹拷贝到<strong>源码根目录</strong>下</p><h3 id="5-编译环境"><a href="#5-编译环境" class="headerlink" title="5. 编译环境"></a>5. 编译环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git-core openjdk-8-jdk gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libxml2-utils xsltproc unzip<br></code></pre></td></tr></table></figure><h3 id="6-编译脚本准备"><a href="#6-编译脚本准备" class="headerlink" title="6. 编译脚本准备"></a>6. 编译脚本准备</h3><p>进去源码根目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">source ./build/envsetup.sh <br>lunch aosp_sailfish-userdebug <span class="hljs-comment">#也可以命令行lunch回车稍等片刻输入 然后输入15即可</span><br><br><span class="hljs-comment">#调整一个Java参数，要不然会出现Java OOM错误</span><br>export JACK_SERVER_VM_ARGUMENTS=<span class="hljs-string">&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m&quot;</span><br><br></code></pre></td></tr></table></figure><p>注: 我们可以在aosp/build/tools/buildinfo.sh  vendor_buildinfo.sh 这两个文件中直接修改手机品牌的名字,厂家等信息</p><h3 id="7-开始编译"><a href="#7-开始编译" class="headerlink" title="7. 开始编译"></a>7. 开始编译</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">make -j6   <span class="hljs-comment">#线程视配置而定</span><br><br><span class="hljs-comment">#编译的结果在 ~/aosp/out/target/product/marlin 文件夹中</span><br><span class="hljs-comment">#比较重要的几个是：</span><br><br>boot.img<br>recovery.img<br>ramdisk.img<br>system.img<br>userdata.img<br></code></pre></td></tr></table></figure><h3 id="8-刷机"><a href="#8-刷机" class="headerlink" title="8. 刷机"></a>8. 刷机</h3><p>回到源码根目录下输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fastboot flashall -w</span><br></code></pre></td></tr></table></figure><p>注 lanch命令为我们设置好了ANDROID_PRODUCT_OUT变量的值为编译文件目录确保它的值和编译后镜像输出目录的路径值一致。如果不一致的话，重新设置ANDROID_PRODUCT_OUT的值与编译后镜像输出目录路径值一致。 </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="fastboot"><a href="#fastboot" class="headerlink" title="fastboot"></a>fastboot</h3><p>一、Fastboot</p><p>1.1 Recovery模式(卡刷)</p><p>在系统进行定制时，编译系统会编译出一份ZIP的压缩包，里面是一些系统分区镜像，提供给客户进行手动升级、恢复系统。需要提前将压缩包内置SDcard，在Recovery模式进行。</p><p>进入Recovery方法：将手机完全关机后，按住音量键下(上)+电源键，进入BootLoader界面。用音量加减来控制光标，电源键来进行确认(有的机器只能用音量下键进行选择，上键是确认键)。说明：有的机器可能没有预装Recovery。</p><p>1.2 Recovery模式(线刷)</p><p>在安卓手机中Fastboot是一种比Recovery更底层的刷机模式。使用USB数据线连接手机的一种刷机模式。这就是所谓的线刷，与Recovery模式相比Fastboot需要掌握一些烧机命令，对于某些系统卡刷来说，线刷更可靠，安全。</p><p>二、Android系统分区介绍</p><ul><li><p>bootloader     系统开机引导类似电脑BIOS，这块刷错手机就会<strong>变成砖</strong></p></li><li><p>radio     通讯模块、基带、WIFI、Bluetooth等衔接硬件的驱动软件</p></li><li><p>recovery     系统故障时负责恢复</p></li><li><p>boot     Linux嵌入式系统内核</p></li><li><p>system     系统文件、应用</p></li><li><p>cache     系统运行时产生的缓存</p></li><li><p>userdata     用户使用APP产生的缓存数据</p></li></ul><h3 id="模块编译介绍"><a href="#模块编译介绍" class="headerlink" title="模块编译介绍"></a>模块编译介绍</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#除了通过make命令编译可以整个android源码外,Google也为我们提供了相应的命令来支持单独模块的编译.</span><br><span class="hljs-comment">#编译环境初始化(即执行source build/envsetup.sh)之后,我们可以得到一些有用的指令,除了上边用到的lunch,还有以下:</span><br><br>  - croot: Changes directory to the top of the tree.<br>  - m: Makes <span class="hljs-keyword">from</span> the top of the tree.<br>  - mm: Builds <span class="hljs-built_in">all</span> of the modules <span class="hljs-keyword">in</span> the current directory.<br>  - mmm: Builds <span class="hljs-built_in">all</span> of the modules <span class="hljs-keyword">in</span> the supplied directories.<br>  - cgrep: Greps on <span class="hljs-built_in">all</span> local C/C++ files.<br>  - jgrep: Greps on <span class="hljs-built_in">all</span> local Java files.<br>  - resgrep: Greps on <span class="hljs-built_in">all</span> local res/*.xml files.<br>  - godir: Go to the directory containing a file.<br></code></pre></td></tr></table></figure><p>其中mmm指令就是用来编译指定目录.通常来说,每个目录只包含一个模块.比如这里我们要编译Launcher2模块,执行指令:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mmm packages<span class="hljs-regexp">/apps/</span>Launcher2/<br></code></pre></td></tr></table></figure><p>稍等一会之后,如果提示:</p><p>make completed success fully </p><p>即表示编译完成,此时在out/target/product/gereric/system/app就可以看到编译的Launcher2.apk文件了.</p><h3 id="重新打包系统镜像"><a href="#重新打包系统镜像" class="headerlink" title="重新打包系统镜像"></a>重新打包系统镜像</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">编译好指定模块后,如果我们想要将该模块对应的apk集成到系统镜像中,需要借助<span class="hljs-keyword">make</span> snod指令重新打包系统镜像,这样我们新生成的<span class="hljs-built_in">system</span>.img中就包含了刚才编译的Launcher2模块了.重启机器之后生效.<br></code></pre></td></tr></table></figure><h3 id="单独安装模块"><a href="#单独安装模块" class="headerlink" title="单独安装模块"></a>单独安装模块</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">我们在不断的修改某些模块,总不能每次编译完成后都要重新打包<span class="hljs-built_in">system</span>.img,然后重启手机吧?有没有什么简单的方法呢?<br>在编译完后,借助adb install命令直接将生成的apk文件安装到设备上即可,相比使用<span class="hljs-keyword">make</span> snod,会节省很多事件.<br></code></pre></td></tr></table></figure><h3 id="编译目录介绍"><a href="#编译目录介绍" class="headerlink" title="编译目录介绍"></a>编译目录介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs out/target/product/generic/system```目录下的常用目录:"><br>- Android系统自带的apk文件都在```out/target/product/generic/system/apk```目录下<br>- 一些可执行文件(比如C编译的执行),放在```out/target/product/generic/system/bin```目录下<br>- 动态链接库放在```out/target/product/generic/system/lib```目录下<br>- 硬件抽象层文件都放在```out/targer/product/generic/system/lib/hw```目录下<br><br>### 源码目录介绍<br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109203736099-1901913006.png)<br><br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109203759902-672469351.png)<br><br><br>### lunch 后面的参数介绍<br><br></code></pre></td></tr></table></figure><p>lunch aosp_arm-eng</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br>该命令表示针对模拟器进行完整编译，并且所有调试功能均处于启用状态。<br><br>如果您没有提供任何参数就运行命令，lunch 将提示您从菜单中选择一个目标。<br><br>所有编译目标都采用 BUILD-BUILDTYPE 形式，其中 BUILD 是表示特定功能组合的代号。<br><br>BUILDTYPE 是以下类型之一：<br><br><br>|<span class="hljs-string"> 编译类型  </span>|<span class="hljs-string"> 使用情况                                                     </span>|<br>|<span class="hljs-string"> --------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> user      </span>|<span class="hljs-string"> 适用于生产环境                                               </span>|<br>|<span class="hljs-string"> userdebug </span>|<span class="hljs-string"> 与“user”类似，但具有 root 权限和可调试性；是进行调试时的首选编译类型 </span>|<br>|<span class="hljs-string"> eng       </span>|<span class="hljs-string"> eng具有额外调试工具的开发配置                            </span>|<br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109203911293-1939592244.png)<br><br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109204041185-295820055.png)<br><br><br><br> <span class="hljs-comment">### 单独刷入某个 img：</span><br><br>fastboot刷入命令格式：fastboot flash 系统分区 对应的name.img<br><br> ```shell<br>cd out/target/product/marlin<br>fastboot flash boot_a boot.img<br>fastboot flash boot_b boot.img<br>fastboot flash system system.img<br>fastboot flash system_b system_other.img<br>fastboot flash vendor vendor.img<br>fastboot flash userdata userdata.img<br>fastboot flash userdata data.img<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wengliuhu/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">107979371</span> 源码目录介绍<br>https:<span class="hljs-regexp">//</span>developers.google.cn<span class="hljs-regexp">/android/im</span>ages<span class="hljs-comment">#marlin 官网刷机包，救砖</span><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/u012417380/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">73196722</span> lunch参数介绍<br>https:<span class="hljs-regexp">//</span>source.android.com<span class="hljs-regexp">/source/</span>building 官网刷机教程<br>https:<span class="hljs-regexp">//</span>www.dazhuanlan.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">12</span><span class="hljs-regexp">/09/</span><span class="hljs-number">5</span>dedf04e496e7  Android8 分区表变化和相关信息<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>rom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pixel XL内核编译</title>
    <link href="/2021/08/22/pixel-XL%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <url>/2021/08/22/pixel-XL%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>操作系统 ：虚拟机 ubuntu 16.04</li><li>内存 ：8G</li><li>硬盘 ：150G</li><li>CPU ：4核</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>注： 编译环境见pixel XL源码编译</p><h3 id="1-源码分支获取"><a href="#1-源码分支获取" class="headerlink" title="1. 源码分支获取"></a>1. 源码分支获取</h3><p>根据手机型号选择分支名称</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>source.android.google.cn<span class="hljs-regexp">/setup/</span>build/building-kernels?hl=zh-cn<span class="hljs-comment">#customize-build</span><br></code></pre></td></tr></table></figure><p>Pixel XL的分支名称为android-msm-marlin-3.18-pie-qpr2</p> <img src="/2021/08/22/pixel-XL%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/images/%E5%88%86%E6%94%AF%E5%90%8D%E7%A7%B0.png" class=""><h3 id="2-下载源码"><a href="#2-下载源码" class="headerlink" title="2. 下载源码"></a>2. 下载源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#共4G文件需要梯子，挂个vpn 大约2个小时下完</span><br>mkdir android-kernel &amp;&amp; cd android-kernel<br><br>repo init -u https://android.googlesource.com/kernel/manifest -b android-msm-marlin-<span class="hljs-number">3.18</span>-pie-qpr2<br>repo sync<br></code></pre></td></tr></table></figure><h3 id="3-构建"><a href="#3-构建" class="headerlink" title="3. 构建"></a>3. 构建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#构建aarch64的内核版本</span><br>./build/build.sh  BUILD_CONFIG=common/build.config.gki.aarch64<br></code></pre></td></tr></table></figure><p>注:此处可能会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">build/buildinfo/buildinfo.py <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure><p>编辑build.config,将EXTRA_CMDS=’python build/buildinfo/buildinfo.py’ 删除，实测可以编译成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">KERNEL_DIR=private/msm-google<br>. $&#123;ROOT_DIR&#125;/$&#123;KERNEL_DIR&#125;/build.config.common<br>POST_DEFCONFIG_CMDS=<span class="hljs-string">&quot;check_defconfig &amp;&amp; compression_tool_and_files lz4&quot;</span><br>EXTRA_CMDS=<span class="hljs-string">&#x27;python build/buildinfo/buildinfo.py&#x27;</span>      <span class="hljs-comment"># &lt;----删除此行</span><br>STOP_SHIP_TRACEPRINTK=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>编译成功后内核二进制文件、模块和相应的映像位于 out/android-msm-marlinxxxxx/dist 目录下。</p><h3 id="4-刷机"><a href="#4-刷机" class="headerlink" title="4. 刷机"></a>4. 刷机</h3><h4 id="4-1-临时刷入"><a href="#4-1-临时刷入" class="headerlink" title="4.1 临时刷入"></a>4.1 临时刷入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#刷入out/xxx/Image.lz4-dtb </span><br><span class="hljs-comment">#临时有效，重启恢复之前内核</span><br><br>adb reboot bootloader<br>fastboot boot Image.lz4-dtb  <br></code></pre></td></tr></table></figure><h4 id="4-2-永久刷入"><a href="#4-2-永久刷入" class="headerlink" title="4.2 永久刷入"></a>4.2 永久刷入</h4><h5 id="4-2-1-拷贝内核文件到AOSP项目下"><a href="#4-2-1-拷贝内核文件到AOSP项目下" class="headerlink" title="4.2.1 拷贝内核文件到AOSP项目下"></a>4.2.1 拷贝内核文件到AOSP项目下</h5><p>将<code>out/xxx/Image.lz4-dtb</code> 拷贝到<code> device/google/marlin-kernel</code>下（以防万一拷贝之前备份<code>device/google/marlin-kernel/Image.lz4-dtb</code>）</p><h5 id="4-2-2-编译aosp"><a href="#4-2-2-编译aosp" class="headerlink" title="4.2.2  编译aosp"></a>4.2.2  编译aosp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">source build/envsetup.sh<br>lunch <span class="hljs-number">15</span>   <span class="hljs-comment">#根据机型选择不同版本</span><br>make bootimage<br></code></pre></td></tr></table></figure><h5 id="4-2-3-编译完成刷入系统"><a href="#4-2-3-编译完成刷入系统" class="headerlink" title="4.2.3 编译完成刷入系统"></a>4.2.3 编译完成刷入系统</h5><p>刷入/out/target/product/marlin/boot.img</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fastboot flash boot boot.img<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>rom</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb查看当前Activity</title>
    <link href="/2021/08/22/adb%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DActivity/"/>
    <url>/2021/08/22/adb%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DActivity/</url>
    
    <content type="html"><![CDATA[<h2 id="Android-8-1前"><a href="#Android-8-1前" class="headerlink" title="Android 8.1前"></a>Android 8.1前</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> dumpsys activity | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;mFocus&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Android-8-1-后"><a href="#Android-8-1-后" class="headerlink" title="Android 8.1 后"></a>Android 8.1 后</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> dumpsys activity | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;mResume&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb设置代理</title>
    <link href="/2021/08/22/adb%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2021/08/22/adb%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings put global http_proxy 127.0.0.1:8888<br></code></pre></td></tr></table></figure><h2 id="移除代理（需要重启）："><a href="#移除代理（需要重启）：" class="headerlink" title="移除代理（需要重启）："></a>移除代理（需要重启）：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings delete global http_proxy<br><br>adb shell settings delete global global_http_proxy_host<br><br>adb shell settings delete global global_http_proxy_port<br><br>adb reboot<br></code></pre></td></tr></table></figure><h2 id="不重启移除代理"><a href="#不重启移除代理" class="headerlink" title="不重启移除代理:"></a>不重启移除代理:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings put global http_proxy :0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>am常用命令</title>
    <link href="/2021/08/21/am%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/21/am%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="拨打电话10086"><a href="#拨打电话10086" class="headerlink" title="拨打电话10086"></a>拨打电话10086</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell am start -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.CALL</span> -d tel:<span class="hljs-number">10086</span><br></code></pre></td></tr></table></figure><h2 id="打开网址"><a href="#打开网址" class="headerlink" title="打开网址"></a>打开网址</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell am start -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.VIEW</span> -d  http:<span class="hljs-comment">//gityuan.com</span><br></code></pre></td></tr></table></figure><h2 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h2><p> 启动包名为<code>com.yuanhh.app</code>，主Activity为<code>.MainActivity</code>  且extra数据以”website”为key, “yuanh.com”为value</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.yuanhh.app/.MainActivity -es website gityuan.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><h2 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">adb shell am broadcast -a com.android.test <span class="hljs-params">--es</span> test_string <span class="hljs-string">&quot;this is test string&quot;</span> <span class="hljs-params">--ei</span> test_int 100 <span class="hljs-params">--ez</span> test_boolean <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>命令列表：</p><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">实现方法</th></tr></thead><tbody><tr><td align="left">am start [options] <INTENT></td><td align="left">启动Activity</td><td align="left">startActivityAsUser</td></tr><tr><td align="left">am startservice <INTENT></td><td align="left">启动Service</td><td align="left">startService</td></tr><tr><td align="left">am stopservice <INTENT></td><td align="left">停止Service</td><td align="left">stopService</td></tr><tr><td align="left">am broadcast <INTENT></td><td align="left">发送广播</td><td align="left">broadcastIntent</td></tr><tr><td align="left">am kill <PACKAGE></td><td align="left">杀指定后台进程</td><td align="left">killBackgroundProcesses</td></tr><tr><td align="left">am kill-all</td><td align="left">杀所有后台进程</td><td align="left">killAllBackgroundProcesses</td></tr><tr><td align="left">am force-stop <PACKAGE></td><td align="left">强杀进程</td><td align="left">forceStopPackage</td></tr><tr><td align="left">am hang</td><td align="left">系统卡住</td><td align="left">hang</td></tr><tr><td align="left">am restart</td><td align="left">重启</td><td align="left">restart</td></tr><tr><td align="left">am bug-report</td><td align="left">创建bugreport</td><td align="left">requestBugReport</td></tr><tr><td align="left">am dumpheap <pid> <file></td><td align="left">进程pid的堆信息输出到file</td><td align="left">dumpheap</td></tr><tr><td align="left">am send-trim-memory <pid> <level></td><td align="left">收紧进程的内存</td><td align="left">setProcessMemoryTrimLevel</td></tr><tr><td align="left">am monitor</td><td align="left">监控</td><td align="left">MyActivityController.run</td></tr></tbody></table><p>am命令实的实现方式在Am.java，最终几乎都是调用<code>ActivityManagerService</code>相应的方法来完成的，<code>am monitor</code>除外。比如前面概述中介绍的命令<code>am start -a android.intent.action.VIEW -d http://gityuan.com</code>， 启动Acitivty最终调用的是ActivityManagerService类的startActivityAsUser()方法来完成的。再比如<code>am kill-all</code>命令，最终的实现工作是由ActivityManagerService的killBackgroundProcesses()方法完成的</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>主要是启动Activity命令<code>am start [options] </code>使用options参数，接下来列举Activity命令的[options]参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">-D: 允许调试功能<br>-W: 等待app启动完成<br>-R &lt;COUNT&gt;: 重复启动Activity COUNT次<br>-S: 启动activity之前，先调用forceStopPackage()方法强制停止app.<br>–opengl-trace: 运行获取OpenGL函数的trace<br>–user &lt;USER_ID&gt; | current: 指定用户来运行App,默认为当前用户。<br>–start-profiler &lt;FILE&gt;: 启动profiler，并将结果发送到 &lt;FILE&gt;;<br>-P &lt;FILE&gt;: 类似 –start-profiler，不同的是当app进入idle状态，则停止profiling<br>–sampling INTERVAL: 设置profiler 取样时间间隔，单位ms;<br></code></pre></td></tr></table></figure><p>启动Activity的实现原理： 存在-W参数则调用startActivityAndWait()方法来运行，否则startActivityAsUser()。</p><h2 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">am</span> send-trim-memory  <span class="hljs-symbol">&lt;pid&gt;</span> <span class="hljs-symbol">&lt;level&gt;</span><br></code></pre></td></tr></table></figure><p>例如： 向pid=12345的进程，发出level=RUNNING_LOW的收紧内存命令</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">am send-<span class="hljs-keyword">trim</span>-<span class="hljs-keyword">memory</span> <span class="hljs-number">12345</span> RUNNING_LOW。<br></code></pre></td></tr></table></figure><p>那么level取值范围为： HIDDEN、RUNNING_MODERATE、BACKGROUND、RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于am的子命令，startservice, stopservice, broadcast, kill, profile start, profile stop, dumpheap的可选参数都允许设置<code>--user </code>。目前市面上的绝大多数手机还是单用户模式，故可以忽略该参数，默认为当前用户。</p><p>例如：启动id=10010的用户的指定service。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">am startservice --<span class="hljs-keyword">user</span> <span class="hljs-title">10010</span><br></code></pre></td></tr></table></figure><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent的参数和flags较多，分为3种类型参数，常用参数，Extra参数，Flags参数</p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-a </code>: 指定Intent action， 实现原理Intent.setAction()；</li><li><code>-n </code>: 指定组件名，格式为{包名}/.{主Activity名}，实现原理Intent.setComponent(）；</li><li><code>-d </code>: 指定Intent data URI</li><li><code>-t </code>: 指定Intent MIME Type</li><li> <code>-c &lt;CATEGORY&gt; [-c &lt;CATEGORY&gt;] ...]:</code>:指定Intent category，实现原理Intent.addCategory()</li><li><code>-p </code>: 指定包名，实现原理Intent.setPackage();</li><li><code>-f </code>: 添加flags，实现原理Intent.setFlags(int )，紧接着的参数必须是int型；</li></ul><p>实例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">am start -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.VIEW</span><br>am start -n com<span class="hljs-selector-class">.yuanhh</span>.app/<span class="hljs-selector-class">.MainActivity</span><br>am start -d <span class="hljs-attribute">content</span>://contacts/people/<span class="hljs-number">1</span><br>am start -t image/png<br>am start -c android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.category</span>.APP_CONTACTS<br></code></pre></td></tr></table></figure><h3 id="Extra参数"><a href="#Extra参数" class="headerlink" title="Extra参数"></a>Extra参数</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><table><thead><tr><th>参数</th><th>-e/-es</th><th>-esn</th><th>-ez</th><th>-ei</th><th>-el</th><th>-ef</th><th>-eu</th><th>-ecn</th></tr></thead><tbody><tr><td>类型</td><td>String</td><td>(String)null</td><td>boolean</td><td>int</td><td>long</td><td>float</td><td>uri</td><td>component</td></tr></tbody></table><p>比如参数es是Extra String首字母简称，实例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.yuanhh.app/.MainActivity -es website gityuan.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>此处<code>-es website gityuan.com</code>，等价于Intent.putExtra(“website”, “gityuan.com”);</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><table><thead><tr><th>参数</th><th>-esa</th><th>-eia</th><th>-ela</th><th>-efa</th></tr></thead><tbody><tr><td>数组类型</td><td>String[]</td><td>int[]</td><td>long[]</td><td>float[]</td></tr></tbody></table><p>比如参数eia，是Extra int array首字母简称，多个value值之间以逗号隔开.。</p><p>实例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">am</span> start -n com.yuanhh.app/.MainActivity -ela weekday <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>此处<code>-ela weekday 1,2,3,4,5</code>，等价于Intent.putExtra(“weekday”, new int[]{1,2,3,4,5});</p><h4 id="ArrayList类型"><a href="#ArrayList类型" class="headerlink" title="ArrayList类型"></a>ArrayList类型</h4><table><thead><tr><th>参数</th><th>-esal</th><th>-eial</th><th>-elal</th><th>-efal</th></tr></thead><tbody><tr><td>List类型</td><td>String</td><td>int</td><td>long</td><td>float</td></tr></tbody></table><p>比如参数efal，是Extra float Array List首字母简称，多个value值之间以逗号隔开。</p><p>实例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">am</span> start -n com.yuanhh.app/.MainActivity -efal nums <span class="hljs-number">1</span>.<span class="hljs-number">2</span>,<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>此处<code>-efal nums 1.2,2.2</code>，等价于先构造ArrayList变量，再通过putExtra放入第二个参数。</p><h3 id="Flags参数"><a href="#Flags参数" class="headerlink" title="Flags参数"></a>Flags参数</h3><p>在参数类型1中，提到有<code>-f </code>，是通过<code>Intent.setFlags(int )</code>方法，来设置Intent的flags.本小节也是关于flags，是通过<code>Intent.addFlags(int )</code>方法。如下所示，所有的flags参数。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">[--grant-read-uri-permission] [--grant-write-uri-permission]<br>[--grant-persistable-uri-permission] [--grant-prefix-uri-permission]<br>[--debug-log-resolution]<br>[--exclude-stopped-packages] [--include-stopped-packages]<br>[--activity-brought-to-front] [--activity-clear-top]<br>[--activity-clear-when-task-reset] [--activity-exclude-from-recents]<br>[--activity-launched-from-history] [--activity-multiple-task]<br>[--activity-no-animation] [--activity-no-history]<br>[--activity-no-user-action] [--activity-previous-is-top]<br>[--activity-reorder-to-front] [--activity-reset-task-if-needed]<br>[--activity-single-top] [--activity-clear-task]<br>[--activity-task-on-home]<br>[--receiver-registered-only] [--receiver-replace-pending]<br></code></pre></td></tr></table></figure><p>例如，发送action=”broadcast.demo”的广播，并且对于forceStopPackage()的应用不允许接收该广播，命令如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">am broadcast -<span class="hljs-keyword">a</span> broadcast.demo <span class="hljs-comment">--exclude-stopped-packages</span><br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ea84febaa7bd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>adb</tag>
      
      <tag>am</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS13.3.1 越狱后设置中未显示越狱插件</title>
    <link href="/2021/08/21/IOS13-3-1-%E8%B6%8A%E7%8B%B1%E5%90%8E%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%9C%AA%E6%98%BE%E7%A4%BA%E8%B6%8A%E7%8B%B1%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/08/21/IOS13-3-1-%E8%B6%8A%E7%8B%B1%E5%90%8E%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%9C%AA%E6%98%BE%E7%A4%BA%E8%B6%8A%E7%8B%B1%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ol><li>进入 cydia 重新安装 <code>cydia substrate</code>如果还未显示，重新安装 <code>Preference Loader</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>越狱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot+JWT Token验证</title>
    <link href="/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/"/>
    <url>/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-pom-xml-添加依赖"><a href="#1-pom-xml-添加依赖" class="headerlink" title="1. pom.xml 添加依赖"></a>1. pom.xml 添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.auth0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-application-yml"><a href="#2-application-yml" class="headerlink" title="2. application.yml"></a>2. application.yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jwt:</span><br>  <span class="hljs-attr">expire:</span> <span class="hljs-number">86400000</span>      <span class="hljs-comment">#jwt有效时间(24小时)</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">secret</span>        <span class="hljs-comment"># 签名密钥</span><br></code></pre></td></tr></table></figure><h2 id="3-工具类生成、验证token、根据token提取用户ID"><a href="#3-工具类生成、验证token、根据token提取用户ID" class="headerlink" title="3. 工具类生成、验证token、根据token提取用户ID"></a>3. 工具类生成、验证token、根据token提取用户ID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">//token有效时长</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">long</span> EXPIRE_TIME;<br>    <span class="hljs-comment">//密钥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String SECRET;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecret</span><span class="hljs-params">(String secret)</span> </span>&#123;<br>        JwtUtil.SECRET= secret;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt.expire&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExpireTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> date)</span> </span>&#123;<br>        JwtUtil.EXPIRE_TIME= date;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成签名，24小时后过期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getToken</span><span class="hljs-params">(String userId)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Date date = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);<br>            Algorithm algorithm = Algorithm.HMAC256(SECRET);<br>            <span class="hljs-keyword">return</span> JWT.create()<br>                    <span class="hljs-comment">// 将 user id 保存到 token 里面</span><br>                    .withAudience(userId)<br>                    .withExpiresAt(date)<br>                    <span class="hljs-comment">// token 的密钥</span><br>                    .sign(algorithm);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据token获取userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String userId = JWT.decode(token).getAudience().get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> userId;<br>        &#125; <span class="hljs-keyword">catch</span> (JWTDecodeException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DecodedJWT <span class="hljs-title">verify</span><span class="hljs-params">(String token)</span></span>&#123;<br>        JWTVerifier build = JWT.require(Algorithm.HMAC256(SECRET)).build();<br>        <span class="hljs-keyword">return</span> build.verify(token);  <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-添加拦截器"><a href="#4-添加拦截器" class="headerlink" title="4. 添加拦截器"></a>4. 添加拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object)</span> </span>&#123;<br>        <span class="hljs-comment">//OPTIONS请求默认通过</span><br>        <span class="hljs-keyword">if</span> (httpServletRequest.getMethod().equals(<span class="hljs-string">&quot;OPTIONS&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//获取请求头X-Token字段</span><br>        String token = httpServletRequest.getHeader(<span class="hljs-string">&quot;X-Token&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            JwtUtil.verify(token);<br>        &#125;<span class="hljs-keyword">catch</span> (SignatureVerificationException e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;无效签名&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;token过期&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (AlgorithmMismatchException e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;token算法不一致&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;token无效&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-配置拦截器"><a href="#5-配置拦截器" class="headerlink" title="5. 配置拦截器"></a>5. 配置拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> JwtInterceptor())<br>                <span class="hljs-comment">//拦截的路径</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//排除登录接口</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/prod-api/user/login&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/prod-api/user/logout&quot;</span>);<br>        WebMvcConfigurer.<span class="hljs-keyword">super</span>.addInterceptors(registry);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-controller层实现登录方法和获取用户信息"><a href="#6-controller层实现登录方法和获取用户信息" class="headerlink" title="6. controller层实现登录方法和获取用户信息"></a>6. controller层实现登录方法和获取用户信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;JSONObject&gt; <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String userInfo)</span></span>&#123;<br>    JSONObject jsonObject = JSON.parseObject(userInfo);<br>    String username = (String) jsonObject.get(<span class="hljs-string">&quot;username&quot;</span>);  <span class="hljs-comment">//获取登录账号</span><br>    String password = (String) jsonObject.get(<span class="hljs-string">&quot;password&quot;</span>);  <span class="hljs-comment">//登录密码</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 验证用户密码是否正确（此处省略）</span><br><span class="hljs-comment">     */</span>        <br><br>    JSONObject dataJson = <span class="hljs-keyword">new</span> JSONObject();<br>    dataJson.put(<span class="hljs-string">&quot;token&quot;</span>,JwtUtil.getToken(username));  <span class="hljs-comment">//将生成token发送至用户</span><br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;登录成功&quot;</span>, dataJson);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h2><p>登录成功返回token</p> <img src="/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/images/login.png" class=""><p>更改请求x-token，被拦截器拦截返回错误信息</p> <img src="/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/images/token.png" class=""><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/lingade/springboot-jwt">SpringBoot+JWT Token验证</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JWT</tag>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frida加载APK/DEX文件并调用方法</title>
    <link href="/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-AndroidStudio创建项目"><a href="#1-AndroidStudio创建项目" class="headerlink" title="1. AndroidStudio创建项目"></a>1. AndroidStudio创建项目</h2><p>创建returnNum方法</p> <img src="/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/images/as.png" class=""><h2 id="2-build项目，将apk-push手机中"><a href="#2-build项目，将apk-push手机中" class="headerlink" title="2. build项目，将apk push手机中"></a>2. build项目，将apk push手机中</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb push 1.apk /data/local/tmp<br></code></pre></td></tr></table></figure><h2 id="3-Frida加载APK调用方法"><a href="#3-Frida加载APK调用方法" class="headerlink" title="3. Frida加载APK调用方法"></a>3. Frida加载APK调用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> DEXFactory = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadAPK</span>(<span class="hljs-params">path</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> ActivityThread = Java.use(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);<br>    <span class="hljs-keyword">var</span> app = ActivityThread.currentApplication();<br>    Java.classFactory.cacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/cache&quot;</span>;<br>    Java.classFactory.codeCacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/code_cache&quot;</span>;<br>    <span class="hljs-keyword">var</span> DexClassLoader = Java.use(<span class="hljs-string">&quot;dalvik.system.DexClassLoader&quot;</span>);<br>    <span class="hljs-keyword">var</span> DEXCL = DexClassLoader.$new(path, Java.classFactory.codeCacheDir, <span class="hljs-literal">null</span>, DexClassLoader.getSystemClassLoader());<br>    DEXFactory = Java.ClassFactory.get(DEXCL);<br>    DEXFactory.cacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/cache&quot;</span>;<br>    DEXFactory.codeCacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/code_cache&quot;</span>;<br>&#125;<br><br><br>Java.performNow(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    loadAPK(<span class="hljs-string">&quot;/data/local/tmp/1.apk&quot;</span>);<br>    <span class="hljs-keyword">var</span> utils = DEXFactory.use(<span class="hljs-string">&quot;custom.dex.utils&quot;</span>);<br>    <span class="hljs-built_in">console</span>.log(utils.returnNum());<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>加载APK并调用方法,此处方法只是简单的return 数字，也可以将一些复杂的逻辑放在APK中用于调用</p> <img src="/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/images/frida.png" class=""><h2 id="4-Frida加载DEX调用方法"><a href="#4-Frida加载DEX调用方法" class="headerlink" title="4.Frida加载DEX调用方法"></a>4.Frida加载DEX调用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Java.openClassFile(<span class="hljs-string">&quot;/data/local/tmp/xxx.dex&quot;</span>).load();<br><span class="hljs-keyword">var</span>  utils = Java.use(<span class="hljs-string">&quot;custom.dex.utils&quot;</span>);<br><span class="hljs-built_in">console</span>.log(utils.returnNum());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>frida</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>frida</tag>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
